{"version":3,"file":"expression_diagnostics.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/diagnostics/expression_diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, AstPath, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, CompileDirectiveSummary, CompileTypeMetadata, DirectiveAst, ElementAst, EmbeddedTemplateAst, Node, ParseSourceSpan, RecursiveTemplateAstVisitor, ReferenceAst, TemplateAst, TemplateAstPath, VariableAst, findNode, identifierName, templateVisitAll, tokenReference} from '@angular/compiler';\n\nimport {AstType, DiagnosticKind, ExpressionDiagnosticsContext, TypeDiagnostic} from './expression_type';\nimport {BuiltinType, Definition, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './symbols';\n\nexport interface DiagnosticTemplateInfo {\n  fileName?: string;\n  offset: number;\n  query: SymbolQuery;\n  members: SymbolTable;\n  htmlAst: Node[];\n  templateAst: TemplateAst[];\n}\n\nexport interface ExpressionDiagnostic {\n  message: string;\n  span: Span;\n  kind: DiagnosticKind;\n}\n\nexport function getTemplateExpressionDiagnostics(info: DiagnosticTemplateInfo):\n    ExpressionDiagnostic[] {\n  const visitor = new ExpressionDiagnosticsVisitor(\n      info, (path: TemplateAstPath, includeEvent: boolean) =>\n                getExpressionScope(info, path, includeEvent));\n  templateVisitAll(visitor, info.templateAst);\n  return visitor.diagnostics;\n}\n\nexport function getExpressionDiagnostics(\n    scope: SymbolTable, ast: AST, query: SymbolQuery,\n    context: ExpressionDiagnosticsContext = {}): TypeDiagnostic[] {\n  const analyzer = new AstType(scope, query, context);\n  analyzer.getDiagnostics(ast);\n  return analyzer.diagnostics;\n}\n\nfunction getReferences(info: DiagnosticTemplateInfo): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  function processReferences(references: ReferenceAst[]) {\n    for (const reference of references) {\n      let type: Symbol|undefined = undefined;\n      if (reference.value) {\n        type = info.query.getTypeSymbol(tokenReference(reference.value));\n      }\n      result.push({\n        name: reference.name,\n        kind: 'reference',\n        type: type || info.query.getBuiltinType(BuiltinType.Any),\n        get definition() { return getDefinitionOf(info, reference); }\n      });\n    }\n  }\n\n  const visitor = new class extends RecursiveTemplateAstVisitor {\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n      super.visitEmbeddedTemplate(ast, context);\n      processReferences(ast.references);\n    }\n    visitElement(ast: ElementAst, context: any): any {\n      super.visitElement(ast, context);\n      processReferences(ast.references);\n    }\n  };\n\n  templateVisitAll(visitor, info.templateAst);\n\n  return result;\n}\n\nfunction getDefinitionOf(info: DiagnosticTemplateInfo, ast: TemplateAst): Definition|undefined {\n  if (info.fileName) {\n    const templateOffset = info.offset;\n    return [{\n      fileName: info.fileName,\n      span: {\n        start: ast.sourceSpan.start.offset + templateOffset,\n        end: ast.sourceSpan.end.offset + templateOffset\n      }\n    }];\n  }\n}\n\nfunction getVarDeclarations(\n    info: DiagnosticTemplateInfo, path: TemplateAstPath): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  let current = path.tail;\n  while (current) {\n    if (current instanceof EmbeddedTemplateAst) {\n      for (const variable of current.variables) {\n        const name = variable.name;\n\n        // Find the first directive with a context.\n        const context =\n            current.directives.map(d => info.query.getTemplateContext(d.directive.type.reference))\n                .find(c => !!c);\n\n        // Determine the type of the context field referenced by variable.value.\n        let type: Symbol|undefined = undefined;\n        if (context) {\n          const value = context.get(variable.value);\n          if (value) {\n            type = value.type !;\n            let kind = info.query.getTypeKind(type);\n            if (kind === BuiltinType.Any || kind == BuiltinType.Unbound) {\n              // The any type is not very useful here. For special cases, such as ngFor, we can do\n              // better.\n              type = refinedVariableType(type, info, current);\n            }\n          }\n        }\n        if (!type) {\n          type = info.query.getBuiltinType(BuiltinType.Any);\n        }\n        result.push({\n          name,\n          kind: 'variable', type, get definition() { return getDefinitionOf(info, variable); }\n        });\n      }\n    }\n    current = path.parentOf(current);\n  }\n\n  return result;\n}\n\nfunction refinedVariableType(\n    type: Symbol, info: DiagnosticTemplateInfo, templateElement: EmbeddedTemplateAst): Symbol {\n  // Special case the ngFor directive\n  const ngForDirective = templateElement.directives.find(d => {\n    const name = identifierName(d.directive.type);\n    return name == 'NgFor' || name == 'NgForOf';\n  });\n  if (ngForDirective) {\n    const ngForOfBinding = ngForDirective.inputs.find(i => i.directiveName == 'ngForOf');\n    if (ngForOfBinding) {\n      const bindingType = new AstType(info.members, info.query, {}).getType(ngForOfBinding.value);\n      if (bindingType) {\n        const result = info.query.getElementType(bindingType);\n        if (result) {\n          return result;\n        }\n      }\n    }\n  }\n\n  // We can't do better, return any\n  return info.query.getBuiltinType(BuiltinType.Any);\n}\n\nfunction getEventDeclaration(info: DiagnosticTemplateInfo, includeEvent?: boolean) {\n  let result: SymbolDeclaration[] = [];\n  if (includeEvent) {\n    // TODO: Determine the type of the event parameter based on the Observable<T> or EventEmitter<T>\n    // of the event.\n    result = [{name: '$event', kind: 'variable', type: info.query.getBuiltinType(BuiltinType.Any)}];\n  }\n  return result;\n}\n\nexport function getExpressionScope(\n    info: DiagnosticTemplateInfo, path: TemplateAstPath, includeEvent: boolean): SymbolTable {\n  let result = info.members;\n  const references = getReferences(info);\n  const variables = getVarDeclarations(info, path);\n  const events = getEventDeclaration(info, includeEvent);\n  if (references.length || variables.length || events.length) {\n    const referenceTable = info.query.createSymbolTable(references);\n    const variableTable = info.query.createSymbolTable(variables);\n    const eventsTable = info.query.createSymbolTable(events);\n    result = info.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);\n  }\n  return result;\n}\n\nclass ExpressionDiagnosticsVisitor extends RecursiveTemplateAstVisitor {\n  private path: TemplateAstPath;\n  // TODO(issue/24571): remove '!'.\n  private directiveSummary !: CompileDirectiveSummary;\n\n  diagnostics: ExpressionDiagnostic[] = [];\n\n  constructor(\n      private info: DiagnosticTemplateInfo,\n      private getExpressionScope: (path: TemplateAstPath, includeEvent: boolean) => SymbolTable) {\n    super();\n    this.path = new AstPath<TemplateAst>([]);\n  }\n\n  visitDirective(ast: DirectiveAst, context: any): any {\n    // Override the default child visitor to ignore the host properties of a directive.\n    if (ast.inputs && ast.inputs.length) {\n      templateVisitAll(this, ast.inputs, context);\n    }\n  }\n\n  visitBoundText(ast: BoundTextAst): void {\n    this.push(ast);\n    this.diagnoseExpression(ast.value, ast.sourceSpan.start.offset, false);\n    this.pop();\n  }\n\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n    this.push(ast);\n    this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);\n    this.pop();\n  }\n\n  visitElementProperty(ast: BoundElementPropertyAst): void {\n    this.push(ast);\n    this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);\n    this.pop();\n  }\n\n  visitEvent(ast: BoundEventAst): void {\n    this.push(ast);\n    this.diagnoseExpression(ast.handler, this.attributeValueLocation(ast), true);\n    this.pop();\n  }\n\n  visitVariable(ast: VariableAst): void {\n    const directive = this.directiveSummary;\n    if (directive && ast.value) {\n      const context = this.info.query.getTemplateContext(directive.type.reference) !;\n      if (context && !context.has(ast.value)) {\n        if (ast.value === '$implicit') {\n          this.reportError(\n              'The template context does not have an implicit value', spanOf(ast.sourceSpan));\n        } else {\n          this.reportError(\n              `The template context does not defined a member called '${ast.value}'`,\n              spanOf(ast.sourceSpan));\n        }\n      }\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): void {\n    this.push(ast);\n    super.visitElement(ast, context);\n    this.pop();\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    const previousDirectiveSummary = this.directiveSummary;\n\n    this.push(ast);\n\n    // Find directive that references this template\n    this.directiveSummary =\n        ast.directives.map(d => d.directive).find(d => hasTemplateReference(d.type)) !;\n\n    // Process children\n    super.visitEmbeddedTemplate(ast, context);\n\n    this.pop();\n\n    this.directiveSummary = previousDirectiveSummary;\n  }\n\n  private attributeValueLocation(ast: TemplateAst) {\n    const path = findNode(this.info.htmlAst, ast.sourceSpan.start.offset);\n    const last = path.tail;\n    if (last instanceof Attribute && last.valueSpan) {\n      // Add 1 for the quote.\n      return last.valueSpan.start.offset + 1;\n    }\n    return ast.sourceSpan.start.offset;\n  }\n\n  private diagnoseExpression(ast: AST, offset: number, includeEvent: boolean) {\n    const scope = this.getExpressionScope(this.path, includeEvent);\n    this.diagnostics.push(...getExpressionDiagnostics(scope, ast, this.info.query, {\n                            event: includeEvent\n                          }).map(d => ({\n                                   span: offsetSpan(d.ast.span, offset + this.info.offset),\n                                   kind: d.kind,\n                                   message: d.message\n                                 })));\n  }\n\n  private push(ast: TemplateAst) { this.path.push(ast); }\n\n  private pop() { this.path.pop(); }\n\n  private reportError(message: string, span: Span|undefined) {\n    if (span) {\n      this.diagnostics.push(\n          {span: offsetSpan(span, this.info.offset), kind: DiagnosticKind.Error, message});\n    }\n  }\n\n  private reportWarning(message: string, span: Span) {\n    this.diagnostics.push(\n        {span: offsetSpan(span, this.info.offset), kind: DiagnosticKind.Warning, message});\n  }\n}\n\nfunction hasTemplateReference(type: CompileTypeMetadata): boolean {\n  if (type.diDeps) {\n    for (let diDep of type.diDeps) {\n      if (diDep.token && diDep.token.identifier &&\n          identifierName(diDep.token !.identifier !) == 'TemplateRef')\n        return true;\n    }\n  }\n  return false;\n}\n\nfunction offsetSpan(span: Span, amount: number): Span {\n  return {start: span.start + amount, end: span.end + amount};\n}\n\nfunction spanOf(sourceSpan: ParseSourceSpan): Span {\n  return {start: sourceSpan.start.offset, end: sourceSpan.end.offset};\n}"]}