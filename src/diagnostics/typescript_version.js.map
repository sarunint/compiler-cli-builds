{"version":3,"file":"typescript_version.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/diagnostics/typescript_version.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH;;;;GAIG;AACH,SAAgB,SAAS,CAAC,KAAa;IACrC,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACtC,CAAC;AAFD,8BAEC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,cAAc,CAAC,CAAW,EAAE,CAAW;IACrD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;IACzC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;IAEzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;QAC5B,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,CAAC;QAC1B,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC;KAC5B;IAED,IAAI,GAAG,KAAK,GAAG,EAAE;QACf,MAAM,YAAY,GAAG,CAAC,CAAC,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE9C,0FAA0F;QAC1F,sBAAsB;QACtB,MAAM,gBAAgB,GAAG,CAAC,CAAC,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEnD,+FAA+F;QAC/F,+FAA+F;QAC/F,KAAK,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC9B,IAAI,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;gBACvB,OAAO,gBAAgB,CAAC;aACzB;SACF;KACF;IAED,OAAO,CAAC,CAAC;AACX,CAAC;AA1BD,wCA0BC;AAED;;;;;;;;GAQG;AACH,SAAgB,gBAAgB,CAAC,OAAe,EAAE,GAAW,EAAE,IAAa;IAC1E,MAAM,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;IACrC,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,OAAO,cAAc,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC;YACjD,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;KACrD;IACD,OAAO,cAAc,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;AACxD,CAAC;AAPD,4CAOC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAAC,EAAU,EAAE,EAAU;IACpD,OAAO,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;AACtD,CAAC;AAFD,0CAEC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Converts a `string` version into an array of numbers\n * @example\n * toNumbers('2.0.1'); // returns [2, 0, 1]\n */\nexport function toNumbers(value: string): number[] {\n  return value.split('.').map(Number);\n}\n\n/**\n * Compares two arrays of positive numbers with lexicographical order in mind.\n *\n * However - unlike lexicographical order - for arrays of different length we consider:\n * [1, 2, 3] = [1, 2, 3, 0] instead of [1, 2, 3] < [1, 2, 3, 0]\n *\n * @param a The 'left hand' array in the comparison test\n * @param b The 'right hand' in the comparison test\n * @returns {-1|0|1} The comparison result: 1 if a is greater, -1 if b is greater, 0 is the two\n * arrays are equals\n */\nexport function compareNumbers(a: number[], b: number[]): -1|0|1 {\n  const max = Math.max(a.length, b.length);\n  const min = Math.min(a.length, b.length);\n\n  for (let i = 0; i < min; i++) {\n    if (a[i] > b[i]) return 1;\n    if (a[i] < b[i]) return -1;\n  }\n\n  if (min !== max) {\n    const longestArray = a.length === max ? a : b;\n\n    // The result to return in case the to arrays are considered different (1 if a is greater,\n    // -1 if b is greater)\n    const comparisonResult = a.length === max ? 1 : -1;\n\n    // Check that at least one of the remaining elements is greater than 0 to consider that the two\n    // arrays are different (e.g. [1, 0] and [1] are considered the same but not [1, 0, 1] and [1])\n    for (let i = min; i < max; i++) {\n      if (longestArray[i] > 0) {\n        return comparisonResult;\n      }\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Checks if a TypeScript version is:\n * - greater or equal than the provided `low` version,\n * - lower or equal than an optional `high` version.\n *\n * @param version The TypeScript version\n * @param low The minimum version\n * @param high The maximum version\n */\nexport function isVersionBetween(version: string, low: string, high?: string): boolean {\n  const tsNumbers = toNumbers(version);\n  if (high !== undefined) {\n    return compareNumbers(toNumbers(low), tsNumbers) <= 0 &&\n        compareNumbers(toNumbers(high), tsNumbers) >= 0;\n  }\n  return compareNumbers(toNumbers(low), tsNumbers) <= 0;\n}\n\n/**\n * Compares two versions\n *\n * @param v1 The 'left hand' version in the comparison test\n * @param v2 The 'right hand' version in the comparison test\n * @returns {-1|0|1} The comparison result: 1 if v1 is greater, -1 if v2 is greater, 0 is the two\n * versions are equals\n */\nexport function compareVersions(v1: string, v2: string): -1|0|1 {\n  return compareNumbers(toNumbers(v1), toNumbers(v2));\n}\n"]}