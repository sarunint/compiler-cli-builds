{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/host/src/reflection.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAsCH;;GAEG;AACH,IAAY,eAMX;AAND,WAAY,eAAe;IACzB,mEAAW,CAAA;IACX,yDAAM,CAAA;IACN,yDAAM,CAAA;IACN,6DAAQ,CAAA;IACR,yDAAM,CAAA;AACR,CAAC,EANW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAM1B","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Metadata extracted from an instance of a decorator on another declaration.\n */\nexport interface Decorator {\n  /**\n   * Name by which the decorator was invoked in the user's code.\n   *\n   * This is distinct from the name by which the decorator was imported (though in practice they\n   * will usually be the same).\n   */\n  name: string;\n\n  /**\n   * Identifier which refers to the decorator in source.\n   */\n  identifier: ts.Identifier;\n\n  /**\n   * `Import` by which the decorator was brought into the module in which it was invoked, or `null`\n   * if the decorator was declared in the same module and not imported.\n   */\n  import : Import | null;\n\n  /**\n   * TypeScript reference to the decorator itself.\n   */\n  node: ts.Node;\n\n  /**\n   * Arguments of the invocation of the decorator, if the decorator is invoked, or `null` otherwise.\n   */\n  args: ts.Expression[]|null;\n}\n\n/**\n * An enumeration of possible kinds of class members.\n */\nexport enum ClassMemberKind {\n  Constructor,\n  Getter,\n  Setter,\n  Property,\n  Method,\n}\n\n/**\n * A member of a class, such as a property, method, or constructor.\n */\nexport interface ClassMember {\n  /**\n   * TypeScript reference to the class member itself, or null if it is not applicable.\n   */\n  node: ts.Node|null;\n\n  /**\n   * Indication of which type of member this is (property, method, etc).\n   */\n  kind: ClassMemberKind;\n\n  /**\n   * TypeScript `ts.TypeNode` representing the type of the member, or `null` if not present or\n   * applicable.\n   */\n  type: ts.TypeNode|null;\n\n  /**\n   * Name of the class member.\n   */\n  name: string;\n\n  /**\n   * TypeScript `ts.Identifier` representing the name of the member, or `null` if no such node\n   * is present.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.Identifier|null;\n\n  /**\n   * TypeScript `ts.Expression` which represents the value of the member.\n   *\n   * If the member is a property, this will be the property initializer if there is one, or null\n   * otherwise.\n   */\n  value: ts.Expression|null;\n\n  /**\n   * TypeScript `ts.Declaration` which represents the implementation of the member.\n   *\n   * In TypeScript code this is identical to the node, but in downleveled code this should always be\n   * the Declaration which actually represents the member's runtime value.\n   *\n   * For example, the TS code:\n   *\n   * ```\n   * class Clazz {\n   *   static get property(): string {\n   *     return 'value';\n   *   }\n   * }\n   * ```\n   *\n   * Downlevels to:\n   *\n   * ```\n   * var Clazz = (function () {\n   *   function Clazz() {\n   *   }\n   *   Object.defineProperty(Clazz, \"property\", {\n   *       get: function () {\n   *           return 'value';\n   *       },\n   *       enumerable: true,\n   *       configurable: true\n   *   });\n   *   return Clazz;\n   * }());\n   * ```\n   *\n   * In this example, for the property \"property\", the node would be the entire\n   * Object.defineProperty ExpressionStatement, but the implementation would be this\n   * FunctionDeclaration:\n   *\n   * ```\n   * function () {\n   *   return 'value';\n   * },\n   * ```\n   */\n  implementation: ts.Declaration|null;\n\n  /**\n   * Whether the member is static or not.\n   */\n  isStatic: boolean;\n\n  /**\n   * Any `Decorator`s which are present on the member, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\n/**\n * A parameter to a constructor.\n */\nexport interface CtorParameter {\n  /**\n   * Name of the parameter, if available.\n   *\n   * Some parameters don't have a simple string name (for example, parameters which are destructured\n   * into multiple variables). In these cases, `name` can be `null`.\n   */\n  name: string|null;\n\n  /**\n   * TypeScript `ts.BindingName` representing the name of the parameter.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.BindingName;\n\n  /**\n   * TypeScript `ts.Expression` representing the type of the parameter, if the type is a simple\n   * expression type.\n   *\n   * If the type is not present or cannot be represented as an expression, `type` is `null`.\n   */\n  type: ts.Expression|null;\n\n  /**\n   * Any `Decorator`s which are present on the parameter, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\n/**\n * Definition of a function or method, including its body if present and any parameters.\n *\n * In TypeScript code this metadata will be a simple reflection of the declarations in the node\n * itself. In ES5 code this can be more complicated, as the default values for parameters may\n * be extracted from certain body statements.\n */\nexport interface FunctionDefinition<T extends ts.MethodDeclaration|ts.FunctionDeclaration|\n                                    ts.FunctionExpression> {\n  /**\n   * A reference to the node which declares the function.\n   */\n  node: T;\n\n  /**\n   * Statements of the function body, if a body is present, or null if no body is present.\n   *\n   * This list may have been filtered to exclude statements which perform parameter default value\n   * initialization.\n   */\n  body: ts.Statement[]|null;\n\n  /**\n   * Metadata regarding the function's parameters, including possible default value expressions.\n   */\n  parameters: Parameter[];\n}\n\n/**\n * A parameter to a function or method.\n */\nexport interface Parameter {\n  /**\n   * Name of the parameter, if available.\n   */\n  name: string|null;\n\n  /**\n   * Declaration which created this parameter.\n   */\n  node: ts.ParameterDeclaration;\n\n  /**\n   * Expression which represents the default value of the parameter, if any.\n   */\n  initializer: ts.Expression|null;\n}\n\n/**\n * The source of an imported symbol, including the original symbol name and the module from which it\n * was imported.\n */\nexport interface Import {\n  /**\n   * The name of the imported symbol under which it was exported (not imported).\n   */\n  name: string;\n\n  /**\n   * The module from which the symbol was imported.\n   *\n   * This could either be an absolute module name (@angular/core for example) or a relative path.\n   */\n  from: string;\n}\n\n/**\n * The declaration of a symbol, along with information about how it was imported into the\n * application.\n */\nexport interface Declaration {\n  /**\n   * TypeScript reference to the declaration itself.\n   */\n  node: ts.Declaration;\n\n  /**\n   * The absolute module path from which the symbol was imported into the application, if the symbol\n   * was imported via an absolute module (even through a chain of re-exports). If the symbol is part\n   * of the application and was not imported from an absolute path, this will be `null`.\n   */\n  viaModule: string|null;\n}\n\n/**\n * Abstracts reflection operations on a TypeScript AST.\n *\n * Depending on the format of the code being interpreted, different concepts are represented with\n * different syntactical structures. The `ReflectionHost` abstracts over those differences and\n * presents a single API by which the compiler can query specific information about the AST.\n *\n * All operations on the `ReflectionHost` require the use of TypeScript `ts.Node`s with binding\n * information already available (that is, nodes that come from a `ts.Program` that has been\n * type-checked, and are not synthetically created).\n */\nexport interface ReflectionHost {\n  /**\n   * Examine a declaration (for example, of a class or function) and return metadata about any\n   * decorators present on the declaration.\n   *\n   * @param declaration a TypeScript `ts.Declaration` node representing the class or function over\n   * which to reflect. For example, if the intent is to reflect the decorators of a class and the\n   * source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the source is in ES5\n   * format, this might be a `ts.VariableDeclaration` as classes in ES5 are represented as the\n   * result of an IIFE execution.\n   *\n   * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\n   * `null` if either no decorators were present or if the declaration is not of a decorable type.\n   */\n  getDecoratorsOfDeclaration(declaration: ts.Declaration): Decorator[]|null;\n\n  /**\n   * Examine a declaration which should be of a class, and return metadata about the members of the\n   * class.\n   *\n   * @param declaration a TypeScript `ts.Declaration` node representing the class over which to\n   * reflect. If the source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the\n   * source is in ES5 format, this might be a `ts.VariableDeclaration` as classes in ES5 are\n   * represented as the result of an IIFE execution.\n   *\n   * @returns an array of `ClassMember` metadata representing the members of the class.\n   *\n   * @throws if `declaration` does not resolve to a class declaration.\n   */\n  getMembersOfClass(clazz: ts.Declaration): ClassMember[];\n\n  /**\n   * Reflect over the constructor of a class and return metadata about its parameters.\n   *\n   * This method only looks at the constructor of a class directly and not at any inherited\n   * constructors.\n   *\n   * @param declaration a TypeScript `ts.Declaration` node representing the class over which to\n   * reflect. If the source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the\n   * source is in ES5 format, this might be a `ts.VariableDeclaration` as classes in ES5 are\n   * represented as the result of an IIFE execution.\n   *\n   * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\n   * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\n   * If the class has no constructor, this method returns `null`.\n   */\n  getConstructorParameters(declaration: ts.Declaration): CtorParameter[]|null;\n\n  /**\n   * Reflect over a function and return metadata about its parameters and body.\n   *\n   * Functions in TypeScript and ES5 code have different AST representations, in particular around\n   * default values for parameters. A TypeScript function has its default value as the initializer\n   * on the parameter declaration, whereas an ES5 function has its default value set in a statement\n   * of the form:\n   *\n   * if (param === void 0) { param = 3; }\n   *\n   * This method abstracts over these details, and interprets the function declaration and body to\n   * extract parameter default values and the \"real\" body.\n   *\n   * A current limitation is that this metadata has no representation for shorthand assignment of\n   * parameter objects in the function signature.\n   *\n   * @param fn a TypeScript `ts.Declaration` node representing the function over which to reflect.\n   *\n   * @returns a `FunctionDefinition` giving metadata about the function definition.\n   */\n  getDefinitionOfFunction<T extends ts.MethodDeclaration|ts.FunctionDeclaration|\n                          ts.FunctionExpression>(fn: T): FunctionDefinition<T>;\n\n  /**\n   * Determine if an identifier was imported from another module and return `Import` metadata\n   * describing its origin.\n   *\n   * @param id a TypeScript `ts.Identifer` to reflect.\n   *\n   * @returns metadata about the `Import` if the identifier was imported from another module, or\n   * `null` if the identifier doesn't resolve to an import but instead is locally defined.\n   */\n  getImportOfIdentifier(id: ts.Identifier): Import|null;\n\n  /**\n   * Trace an identifier to its declaration, if possible.\n   *\n   * This method attempts to resolve the declaration of the given identifier, tracing back through\n   * imports and re-exports until the original declaration statement is found. A `Declaration`\n   * object is returned if the original declaration is found, or `null` is returned otherwise.\n   *\n   * If the declaration is in a different module, and that module is imported via an absolute path,\n   * this method also returns the absolute path of the imported module. For example, if the code is:\n   *\n   * ```\n   * import {RouterModule} from '@angular/core';\n   *\n   * export const ROUTES = RouterModule.forRoot([...]);\n   * ```\n   *\n   * and if `getDeclarationOfIdentifier` is called on `RouterModule` in the `ROUTES` expression,\n   * then it would trace `RouterModule` via its import from `@angular/core`, and note that the\n   * definition was imported from `@angular/core` into the application where it was referenced.\n   *\n   * If the definition is re-exported several times from different absolute module names, only\n   * the first one (the one by which the application refers to the module) is returned.\n   *\n   * This module name is returned in the `viaModule` field of the `Declaration`. If The declaration\n   * is relative to the application itself and there was no import through an absolute path, then\n   * `viaModule` is `null`.\n   *\n   * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n   *\n   * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n   * otherwise.\n   */\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null;\n\n  /**\n   * Collect the declarations exported from a module by name.\n   *\n   * Iterates over the exports of a module (including re-exports) and returns a map of export\n   * name to its `Declaration`. If an exported value is itself re-exported from another module,\n   * the `Declaration`'s `viaModule` will reflect that.\n   *\n   * @param node a TypeScript `ts.Node` representing the module (for example a `ts.SourceFile`) for\n   * which to collect exports.\n   *\n   * @returns a map of `Declaration`s for the module's exports, by name.\n   */\n  getExportsOfModule(module: ts.Node): Map<string, Declaration>|null;\n\n  /**\n   * Check whether the given node actually represents a class.\n   */\n  isClass(node: ts.Node): boolean;\n\n  hasBaseClass(node: ts.Declaration): boolean;\n\n  /**\n   * Get the number of generic type parameters of a given class.\n   *\n   * @returns the number of type parameters of the class, if known, or `null` if the declaration\n   * is not a class or has an unknown number of type parameters.\n   */\n  getGenericArityOfClass(clazz: ts.Declaration): number|null;\n\n  /**\n   * Find the assigned value of a variable declaration.\n   *\n   * Normally this will be the initializer of the declaration, but where the variable is\n   * not a `const` we may need to look elsewhere for the variable's value.\n   *\n   * @param declaration a TypeScript variable declaration, whose value we want.\n   * @returns the value of the variable, as a TypeScript expression node, or `undefined`\n   * if the value cannot be computed.\n   */\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null;\n\n  /**\n   * Take an exported declaration of a class (maybe downleveled to a variable) and look up the\n   * declaration of its type in a separate .d.ts tree.\n   *\n   * This function is allowed to return `null` if the current compilation unit does not have a\n   * separate .d.ts tree. When compiling TypeScript code this is always the case, since .d.ts files\n   * are produced only during the emit of such a compilation. When compiling .js code, however,\n   * there is frequently a parallel .d.ts tree which this method exposes.\n   *\n   * Note that the `ts.ClassDeclaration` returned from this function may not be from the same\n   * `ts.Program` as the input declaration.\n   */\n  getDtsDeclarationOfClass(declaration: ts.Declaration): ts.ClassDeclaration|null;\n}\n"]}