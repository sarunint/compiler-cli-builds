{"version":3,"file":"visitor.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/util/src/visitor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Result type of visiting a node that's typically an entry in a list, which allows specifying that\n * nodes should be added before the visited node in the output.\n */\nexport type VisitListEntryResult<B extends ts.Node, T extends B> = {\n  node: T,\n  before?: B[],\n  after?: B[],\n};\n\n/**\n * Visit a node with the given visitor and return a transformed copy.\n */\nexport function visit<T extends ts.Node>(\n    node: T, visitor: Visitor, context: ts.TransformationContext): T {\n  return visitor._visit(node, context);\n}\n\n/**\n * Abstract base class for visitors, which processes certain nodes specially to allow insertion\n * of other nodes before them.\n */\nexport abstract class Visitor {\n  /**\n   * Maps statements to an array of statements that should be inserted before them.\n   */\n  private _before = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Maps statements to an array of statements that should be inserted after them.\n   */\n  private _after = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Visit a class declaration, returning at least the transformed declaration and optionally other\n   * nodes to insert before the declaration.\n   */\n  visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    return {node};\n  }\n\n  private _visitListEntryNode<T extends ts.Statement>(\n      node: T, visitor: (node: T) => VisitListEntryResult<ts.Statement, T>): T {\n    const result = visitor(node);\n    if (result.before !== undefined) {\n      // Record that some nodes should be inserted before the given declaration. The declaration's\n      // parent's _visit call is responsible for performing this insertion.\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== undefined) {\n      // Same with nodes that should be inserted after.\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n\n  /**\n   * Visit types of nodes which don't have their own explicit visitor.\n   */\n  visitOtherNode<T extends ts.Node>(node: T): T { return node; }\n\n  /**\n   * @internal\n   */\n  _visit<T extends ts.Node>(node: T, context: ts.TransformationContext): T {\n    // First, visit the node. visitedNode starts off as `null` but should be set after visiting\n    // is completed.\n    let visitedNode: T|null = null;\n\n    node = ts.visitEachChild(node, child => this._visit(child, context), context) as T;\n\n    if (ts.isClassDeclaration(node)) {\n      visitedNode = this._visitListEntryNode(\n          node, (node: ts.ClassDeclaration) => this.visitClassDeclaration(node)) as typeof node;\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n\n    // If the visited node has a `statements` array then process them, maybe replacing the visited\n    // node and adding additional statements.\n    if (hasStatements(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n\n    return visitedNode;\n  }\n\n  private _maybeProcessStatements<T extends ts.Node&{statements: ts.NodeArray<ts.Statement>}>(\n      node: T): T {\n    // Shortcut - if every statement doesn't require nodes to be prepended or appended,\n    // this is a no-op.\n    if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n\n    // There are statements to prepend, so clone the original node.\n    const clone = ts.getMutableClone(node);\n\n    // Build a new list of statements and patch it onto the clone.\n    const newStatements: ts.Statement[] = [];\n    clone.statements.forEach(stmt => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...(this._before.get(stmt) !as ts.Statement[]));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...(this._after.get(stmt) !as ts.Statement[]));\n        this._after.delete(stmt);\n      }\n    });\n    clone.statements = ts.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    return clone;\n  }\n}\n\nfunction hasStatements(node: ts.Node): node is ts.Node&{statements: ts.NodeArray<ts.Statement>} {\n  const block = node as{statements?: any};\n  return block.statements !== undefined && Array.isArray(block.statements);\n}\n"]}