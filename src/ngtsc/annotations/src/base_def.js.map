{"version":3,"file":"base_def.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/base_def.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3BaseRefMetaData, compileBaseDefFromMetadata} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ClassMember, Decorator, ReflectionHost} from '../../host';\nimport {staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\nimport {isAngularCore} from './util';\n\nfunction containsNgTopLevelDecorator(decorators: Decorator[] | null): boolean {\n  if (!decorators) {\n    return false;\n  }\n  return decorators.find(\n             decorator => (decorator.name === 'Component' || decorator.name === 'Directive' ||\n                           decorator.name === 'NgModule') &&\n                 isAngularCore(decorator)) !== undefined;\n}\n\nexport class BaseDefDecoratorHandler implements\n    DecoratorHandler<R3BaseRefMetaData, R3BaseRefDecoratorDetection> {\n  constructor(private checker: ts.TypeChecker, private reflector: ReflectionHost, ) {}\n\n  detect(node: ts.ClassDeclaration, decorators: Decorator[]|null): R3BaseRefDecoratorDetection\n      |undefined {\n    if (containsNgTopLevelDecorator(decorators)) {\n      // If the class is already decorated by @Component or @Directive let that\n      // DecoratorHandler handle this. BaseDef is unnecessary.\n      return undefined;\n    }\n\n    let result: R3BaseRefDecoratorDetection|undefined = undefined;\n\n    this.reflector.getMembersOfClass(node).forEach(property => {\n      const {decorators} = property;\n      if (decorators) {\n        for (const decorator of decorators) {\n          const decoratorName = decorator.name;\n          if (decoratorName === 'Input' && isAngularCore(decorator)) {\n            result = result || {};\n            const inputs = result.inputs = result.inputs || [];\n            inputs.push({decorator, property});\n          } else if (decoratorName === 'Output' && isAngularCore(decorator)) {\n            result = result || {};\n            const outputs = result.outputs = result.outputs || [];\n            outputs.push({decorator, property});\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n\n  analyze(node: ts.ClassDeclaration, metadata: R3BaseRefDecoratorDetection):\n      AnalysisOutput<R3BaseRefMetaData> {\n    const analysis: R3BaseRefMetaData = {};\n    if (metadata.inputs) {\n      const inputs = analysis.inputs = {} as{[key: string]: string | [string, string]};\n      metadata.inputs.forEach(({decorator, property}) => {\n        const propName = property.name;\n        const args = decorator.args;\n        let value: string|[string, string];\n        if (args && args.length > 0) {\n          const resolvedValue = staticallyResolve(args[0], this.reflector, this.checker);\n          if (typeof resolvedValue !== 'string') {\n            throw new TypeError('Input alias does not resolve to a string value');\n          }\n          value = [resolvedValue, propName];\n        } else {\n          value = propName;\n        }\n        inputs[propName] = value;\n      });\n    }\n\n    if (metadata.outputs) {\n      const outputs = analysis.outputs = {} as{[key: string]: string};\n      metadata.outputs.forEach(({decorator, property}) => {\n        const propName = property.name;\n        const args = decorator.args;\n        let value: string;\n        if (args && args.length > 0) {\n          const resolvedValue = staticallyResolve(args[0], this.reflector, this.checker);\n          if (typeof resolvedValue !== 'string') {\n            throw new TypeError('Output alias does not resolve to a string value');\n          }\n          value = resolvedValue;\n        } else {\n          value = propName;\n        }\n        outputs[propName] = value;\n      });\n    }\n\n    return {analysis};\n  }\n\n  compile(node: ts.Declaration, analysis: R3BaseRefMetaData): CompileResult[]|CompileResult {\n    const {expression, type} = compileBaseDefFromMetadata(analysis);\n\n    return {\n      name: 'ngBaseDef',\n      initializer: expression, type,\n      statements: [],\n    };\n  }\n}\n\nexport interface R3BaseRefDecoratorDetection {\n  inputs?: Array<{property: ClassMember, decorator: Decorator}>;\n  outputs?: Array<{property: ClassMember, decorator: Decorator}>;\n}\n"]}