{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/metadata.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExternalExpr, Identifiers, InvokeFunctionExpr, Statement, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {CtorParameter, Decorator, ReflectionHost} from '../../host';\n\n/**\n * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata\n * present on the class or its member fields.\n *\n * If no such metadata is present, this function returns `null`. Otherwise, the call is returned\n * as a `Statement` for inclusion along with the class.\n */\nexport function generateSetClassMetadataCall(\n    clazz: ts.Declaration, reflection: ReflectionHost, isCore: boolean): Statement|null {\n  // Classes come in two flavors, class declarations (ES2015) and variable declarations (ES5).\n  // Both must have a declared name to have metadata set on them.\n  if ((!ts.isClassDeclaration(clazz) && !ts.isVariableDeclaration(clazz)) ||\n      clazz.name === undefined || !ts.isIdentifier(clazz.name)) {\n    return null;\n  }\n  const id = ts.updateIdentifier(clazz.name);\n\n  // Reflect over the class decorators. If none are present, or those that are aren't from\n  // Angular, then return null. Otherwise, turn them into metadata.\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators =\n      classDecorators.filter(dec => isAngularDecorator(dec, isCore)).map(decoratorToMetadata);\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators = ts.createArrayLiteral(ngClassDecorators);\n\n  // Convert the constructor parameters to metadata, passing null if none are present.\n  let metaCtorParameters: ts.Expression = ts.createNull();\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    metaCtorParameters = ts.createArrayLiteral(\n        classCtorParameters.map(param => ctorParameterToMetadata(param, isCore)));\n  }\n\n  // Do the same for property decorators.\n  let metaPropDecorators: ts.Expression = ts.createNull();\n  const decoratedMembers =\n      reflection.getMembersOfClass(clazz)\n          .filter(member => !member.isStatic && member.decorators !== null)\n          .map(member => classMemberToMetadata(member.name, member.decorators !, isCore));\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = ts.createObjectLiteral(decoratedMembers);\n  }\n\n  // Generate a pure call to setClassMetadata with the class identifier and its metadata.\n  const setClassMetadata = new ExternalExpr(Identifiers.setClassMetadata);\n  const fnCall = new InvokeFunctionExpr(\n      /* fn */ setClassMetadata,\n      /* args */\n      [\n        new WrappedNodeExpr(id),\n        new WrappedNodeExpr(metaDecorators),\n        new WrappedNodeExpr(metaCtorParameters),\n        new WrappedNodeExpr(metaPropDecorators),\n      ],\n      /* type */ undefined,\n      /* sourceSpan */ undefined,\n      /* pure */ true);\n  return fnCall.toStmt();\n}\n\n/**\n * Convert a reflected constructor parameter to metadata.\n */\nfunction ctorParameterToMetadata(param: CtorParameter, isCore: boolean): ts.Expression {\n  // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise\n  // its type is undefined.\n  const type = param.type !== null ? param.type : ts.createIdentifier('undefined');\n  const properties: ts.ObjectLiteralElementLike[] = [\n    ts.createPropertyAssignment('type', type),\n  ];\n\n  // If the parameter has decorators, include the ones from Angular.\n  if (param.decorators !== null) {\n    const ngDecorators =\n        param.decorators.filter(dec => isAngularDecorator(dec, isCore)).map(decoratorToMetadata);\n    properties.push(ts.createPropertyAssignment('decorators', ts.createArrayLiteral(ngDecorators)));\n  }\n  return ts.createObjectLiteral(properties, true);\n}\n\n/**\n * Convert a reflected class member to metadata.\n */\nfunction classMemberToMetadata(\n    name: string, decorators: Decorator[], isCore: boolean): ts.PropertyAssignment {\n  const ngDecorators =\n      decorators.filter(dec => isAngularDecorator(dec, isCore)).map(decoratorToMetadata);\n  const decoratorMeta = ts.createArrayLiteral(ngDecorators);\n  return ts.createPropertyAssignment(name, decoratorMeta);\n}\n\n/**\n * Convert a reflected decorator to metadata.\n */\nfunction decoratorToMetadata(decorator: Decorator): ts.ObjectLiteralExpression {\n  // Decorators have a type.\n  const properties: ts.ObjectLiteralElementLike[] = [\n    ts.createPropertyAssignment('type', ts.updateIdentifier(decorator.identifier)),\n  ];\n  // Sometimes they have arguments.\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map(arg => ts.getMutableClone(arg));\n    properties.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));\n  }\n  return ts.createObjectLiteral(properties, true);\n}\n\n/**\n * Whether a given decorator should be treated as an Angular decorator.\n *\n * Either it's used in @angular/core, or it's imported from there.\n */\nfunction isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');\n}\n"]}