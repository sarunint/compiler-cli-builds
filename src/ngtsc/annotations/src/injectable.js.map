{"version":3,"file":"injectable.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, LiteralExpr, R3DependencyMetadata, R3InjectableMetadata, R3ResolvedDependencyType, Statement, WrappedNodeExpr, compileInjectable as compileIvyInjectable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {Decorator, ReflectionHost} from '../../host';\nimport {reflectObjectLiteral} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {generateSetClassMetadataCall} from './metadata';\nimport {getConstructorDependencies, isAngularCore} from './util';\n\nexport interface InjectableHandlerData {\n  meta: R3InjectableMetadata;\n  metadataStmt: Statement|null;\n}\n\n/**\n * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n */\nexport class InjectableDecoratorHandler implements\n    DecoratorHandler<InjectableHandlerData, Decorator> {\n  constructor(private reflector: ReflectionHost, private isCore: boolean) {}\n\n  detect(node: ts.Declaration, decorators: Decorator[]|null): Decorator|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    return decorators.find(\n        decorator => decorator.name === 'Injectable' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<InjectableHandlerData> {\n    return {\n      analysis: {\n        meta: extractInjectableMetadata(node, decorator, this.reflector, this.isCore),\n        metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.isCore),\n      },\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: InjectableHandlerData): CompileResult {\n    const res = compileIvyInjectable(analysis.meta);\n    const statements = res.statements;\n    if (analysis.metadataStmt !== null) {\n      statements.push(analysis.metadataStmt);\n    }\n    return {\n      name: 'ngInjectableDef',\n      initializer: res.expression, statements,\n      type: res.type,\n    };\n  }\n}\n\n/**\n * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the input\n * metadata needed to run `compileIvyInjectable`.\n */\nfunction extractInjectableMetadata(\n    clazz: ts.ClassDeclaration, decorator: Decorator, reflector: ReflectionHost,\n    isCore: boolean): R3InjectableMetadata {\n  if (clazz.name === undefined) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ON_ANONYMOUS_CLASS, decorator.node, `@Injectable on anonymous class`);\n  }\n  const name = clazz.name.text;\n  const type = new WrappedNodeExpr(clazz.name);\n  const ctorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_NOT_CALLED, decorator.node, '@Injectable must be called');\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      providedIn: new LiteralExpr(null), ctorDeps,\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n    // transport references from one location to another. This is the problem that lowering\n    // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n    if (!ts.isObjectLiteralExpression(metaNode)) {\n      throw new Error(`In Ivy, decorator metadata must be inline.`);\n    }\n\n    // Resolve the fields of the literal into a map of field name to expression.\n    const meta = reflectObjectLiteral(metaNode);\n    let providedIn: Expression = new LiteralExpr(null);\n    if (meta.has('providedIn')) {\n      providedIn = new WrappedNodeExpr(meta.get('providedIn') !);\n    }\n\n    let userDeps: R3DependencyMetadata[]|undefined = undefined;\n    if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {\n      const depsExpr = meta.get('deps') !;\n      if (!ts.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(\n            ErrorCode.VALUE_NOT_LITERAL, depsExpr,\n            `In Ivy, deps metadata must be an inline array.`);\n      }\n      if (depsExpr.elements.length > 0) {\n        throw new Error(`deps not yet supported`);\n      }\n      userDeps = depsExpr.elements.map(dep => getDep(dep, reflector));\n    }\n\n    if (meta.has('useValue')) {\n      return {\n        name,\n        type,\n        ctorDeps,\n        providedIn,\n        useValue: new WrappedNodeExpr(meta.get('useValue') !)\n      };\n    } else if (meta.has('useExisting')) {\n      return {\n        name,\n        type,\n        ctorDeps,\n        providedIn,\n        useExisting: new WrappedNodeExpr(meta.get('useExisting') !)\n      };\n    } else if (meta.has('useClass')) {\n      return {\n        name,\n        type,\n        ctorDeps,\n        providedIn,\n        useClass: new WrappedNodeExpr(meta.get('useClass') !), userDeps\n      };\n    } else if (meta.has('useFactory')) {\n      // useFactory is special - the 'deps' property must be analyzed.\n      const factory = new WrappedNodeExpr(meta.get('useFactory') !);\n      return {name, type, providedIn, useFactory: factory, ctorDeps, userDeps};\n    } else {\n      return {name, type, providedIn, ctorDeps};\n    }\n  } else {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');\n  }\n}\n\n\n\nfunction getDep(dep: ts.Expression, reflector: ReflectionHost): R3DependencyMetadata {\n  const meta: R3DependencyMetadata = {\n    token: new WrappedNodeExpr(dep),\n    host: false,\n    resolved: R3ResolvedDependencyType.Token,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  function maybeUpdateDecorator(\n      dec: ts.Identifier, reflector: ReflectionHost, token?: ts.Expression): void {\n    const source = reflector.getImportOfIdentifier(dec);\n    if (source === null || source.from !== '@angular/core') {\n      return;\n    }\n    switch (source.name) {\n      case 'Inject':\n        if (token !== undefined) {\n          meta.token = new WrappedNodeExpr(token);\n        }\n        break;\n      case 'Optional':\n        meta.optional = true;\n        break;\n      case 'SkipSelf':\n        meta.skipSelf = true;\n        break;\n      case 'Self':\n        meta.self = true;\n        break;\n    }\n  }\n\n  if (ts.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      if (ts.isIdentifier(el)) {\n        maybeUpdateDecorator(el, reflector);\n      } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n        maybeUpdateDecorator(el.expression, reflector, token);\n      }\n    });\n  }\n  return meta;\n}\n"]}