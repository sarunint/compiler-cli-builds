{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, R3DependencyMetadata, R3Reference, R3ResolvedDependencyType, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {ClassMemberKind, Decorator, ReflectionHost} from '../../host';\nimport {AbsoluteReference, ImportMode, Reference} from '../../metadata';\n\nexport function getConstructorDependencies(\n    clazz: ts.ClassDeclaration, reflector: ReflectionHost, isCore: boolean): R3DependencyMetadata[]|\n    null {\n  const useType: R3DependencyMetadata[] = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let tokenExpr = param.type;\n    let optional = false, self = false, skipSelf = false, host = false;\n    let resolved = R3ResolvedDependencyType.Token;\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      if (dec.name === 'Inject') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, dec.node,\n              `Unexpected number of arguments to @Inject().`);\n        }\n        tokenExpr = dec.args[0];\n      } else if (dec.name === 'Optional') {\n        optional = true;\n      } else if (dec.name === 'SkipSelf') {\n        skipSelf = true;\n      } else if (dec.name === 'Self') {\n        self = true;\n      } else if (dec.name === 'Host') {\n        host = true;\n      } else if (dec.name === 'Attribute') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, dec.node,\n              `Unexpected number of arguments to @Attribute().`);\n        }\n        tokenExpr = dec.args[0];\n        resolved = R3ResolvedDependencyType.Attribute;\n      } else {\n        throw new FatalDiagnosticError(\n            ErrorCode.DECORATOR_UNEXPECTED, dec.node,\n            `Unexpected decorator ${dec.name} on parameter.`);\n      }\n    });\n    if (tokenExpr === null) {\n      throw new FatalDiagnosticError(\n          ErrorCode.PARAM_MISSING_TOKEN, param.nameNode,\n          `No suitable token for parameter ${param.name || idx} of class ${clazz.name!.text}`);\n    }\n    const token = new WrappedNodeExpr(tokenExpr);\n    useType.push({token, optional, self, skipSelf, host, resolved});\n  });\n  return useType;\n}\n\nexport function toR3Reference(\n    valueRef: Reference, typeRef: Reference, valueContext: ts.SourceFile,\n    typeContext: ts.SourceFile): R3Reference {\n  const value = valueRef.toExpression(valueContext, ImportMode.UseExistingImport);\n  const type = typeRef.toExpression(typeContext, ImportMode.ForceNewImport);\n  if (value === null || type === null) {\n    throw new Error(`Could not refer to ${ts.SyntaxKind[valueRef.node.kind]}`);\n  }\n  return {value, type};\n}\n\nexport function isAngularCore(decorator: Decorator): boolean {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\n/**\n * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\n * lowest level form.\n *\n * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\n */\nexport function unwrapExpression(node: ts.Expression): ts.Expression {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n\nfunction expandForwardRef(arg: ts.Expression): ts.Expression|null {\n  if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n    return null;\n  }\n\n  const body = arg.body;\n  // Either the body is a ts.Expression directly, or a block with a single return statement.\n  if (ts.isBlock(body)) {\n    // Block body - look for a single return statement.\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    // Shorthand body - return as an expression.\n    return body;\n  }\n}\n\n/**\n * Possibly resolve a forwardRef() expression into the inner value.\n *\n * @param node the forwardRef() expression to resolve\n * @param reflector a ReflectionHost\n * @returns the resolved expression, if the original expression was a forwardRef(), or the original\n * expression otherwise\n */\nexport function unwrapForwardRef(node: ts.Expression, reflector: ReflectionHost): ts.Expression {\n  if (!ts.isCallExpression(node) || !ts.isIdentifier(node.expression) ||\n      node.arguments.length !== 1) {\n    return node;\n  }\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return node;\n  }\n  const imp = reflector.getImportOfIdentifier(node.expression);\n  if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {\n    return node;\n  } else {\n    return expr;\n  }\n}\n\n/**\n * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.\n *\n * @param ref a Reference to the declaration of the function being called (which might be\n * forwardRef)\n * @param args the arguments to the invocation of the forwardRef expression\n * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise\n */\nexport function forwardRefResolver(\n    ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration>,\n    args: ts.Expression[]): ts.Expression|null {\n  if (!(ref instanceof AbsoluteReference) || ref.moduleName !== '@angular/core' ||\n      ref.symbolName !== 'forwardRef' || args.length !== 1) {\n    return null;\n  }\n  return expandForwardRef(args[0]);\n}\n\nexport function extractDirectiveGuards(node: ts.Declaration, reflector: ReflectionHost): {\n  ngTemplateGuards: string[],\n  hasNgTemplateContextGuard: boolean,\n} {\n  const methods = nodeStaticMethodNames(node, reflector);\n  const ngTemplateGuards = methods.filter(method => method.startsWith('ngTemplateGuard_'))\n                               .map(method => method.split('_', 2)[1]);\n  const hasNgTemplateContextGuard = methods.some(name => name === 'ngTemplateContextGuard');\n  return {hasNgTemplateContextGuard, ngTemplateGuards};\n}\n\nfunction nodeStaticMethodNames(node: ts.Declaration, reflector: ReflectionHost): string[] {\n  return reflector.getMembersOfClass(node)\n      .filter(member => member.kind === ClassMemberKind.Method && member.isStatic)\n      .map(member => member.name);\n}\n"]}