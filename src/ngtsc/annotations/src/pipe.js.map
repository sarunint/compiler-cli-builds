{"version":3,"file":"pipe.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LiteralExpr, R3PipeMetadata, Statement, WrappedNodeExpr, compilePipeFromMetadata} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {Decorator, ReflectionHost} from '../../host';\nimport {reflectObjectLiteral, staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {generateSetClassMetadataCall} from './metadata';\nimport {SelectorScopeRegistry} from './selector_scope';\nimport {getConstructorDependencies, isAngularCore, unwrapExpression} from './util';\n\nexport interface PipeHandlerData {\n  meta: R3PipeMetadata;\n  metadataStmt: Statement|null;\n}\n\nexport class PipeDecoratorHandler implements DecoratorHandler<PipeHandlerData, Decorator> {\n  constructor(\n      private checker: ts.TypeChecker, private reflector: ReflectionHost,\n      private scopeRegistry: SelectorScopeRegistry, private isCore: boolean) {}\n\n  detect(node: ts.Declaration, decorators: Decorator[]|null): Decorator|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    return decorators.find(\n        decorator => decorator.name === 'Pipe' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(clazz: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<PipeHandlerData> {\n    if (clazz.name === undefined) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ON_ANONYMOUS_CLASS, clazz, `@Pipes must have names`);\n    }\n    const name = clazz.name.text;\n    const type = new WrappedNodeExpr(clazz.name);\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_NOT_CALLED, decorator.node, `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, '@Pipe must have exactly one argument');\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');\n    }\n    const pipe = reflectObjectLiteral(meta);\n\n    if (!pipe.has('name')) {\n      throw new FatalDiagnosticError(\n          ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get('name') !;\n    const pipeName = staticallyResolve(pipeNameExpr, this.reflector, this.checker);\n    if (typeof pipeName !== 'string') {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, pipeNameExpr, `@Pipe.name must be a string`);\n    }\n    this.scopeRegistry.registerPipe(clazz, pipeName);\n\n    let pure = true;\n    if (pipe.has('pure')) {\n      const expr = pipe.get('pure') !;\n      const pureValue = staticallyResolve(expr, this.reflector, this.checker);\n      if (typeof pureValue !== 'boolean') {\n        throw new FatalDiagnosticError(\n            ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          pipeName,\n          deps: getConstructorDependencies(clazz, this.reflector, this.isCore), pure,\n        },\n        metadataStmt: generateSetClassMetadataCall(clazz, this.reflector, this.isCore),\n      },\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: PipeHandlerData): CompileResult {\n    const res = compilePipeFromMetadata(analysis.meta);\n    const statements = res.statements;\n    if (analysis.metadataStmt !== null) {\n      statements.push(analysis.metadataStmt);\n    }\n    return {\n      name: 'ngPipeDef',\n      initializer: res.expression, statements,\n      type: res.type,\n    };\n  }\n}\n"]}