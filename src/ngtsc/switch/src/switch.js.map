{"version":3,"file":"switch.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/switch/src/switch.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,iCAAiC;AAEjC,MAAM,qBAAqB,GAAG,YAAY,CAAC;AAC3C,MAAM,sBAAsB,GAAG,aAAa,CAAC;AAE7C,SAAgB,kBAAkB,CAAC,CAA2B;IAC5D,OAAO,mBAAmB,CAAC;AAC7B,CAAC;AAFD,gDAEC;AAED,SAAS,mBAAmB,CAAC,EAAiB;IAC5C,+FAA+F;IAC/F,gGAAgG;IAChG,IAAI,aAAa,GAA6B,SAAS,CAAC;IAExD,2CAA2C;IAC3C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7C,MAAM,SAAS,GAAG,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAEnC,wDAAwD;QACxD,IAAI,CAAC,EAAE,CAAC,mBAAmB,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;YACpE,SAAS;SACV;QAED,2FAA2F;QAC3F,oDAAoD;QACpD,IAAI,aAAa,KAAK,SAAS,EAAE;YAC/B,aAAa,GAAG,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,CAAC;SACpC;QAED,yFAAyF;QACzF,iDAAiD;QACjD,aAAa,CAAC,CAAC,CAAC,GAAG,kCAAkC,CAAC,SAAS,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC;KACjF;IAED,oEAAoE;IACpE,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,EAAE,CAAC,UAAU,GAAG,EAAE,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;KACnD;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;;;;;;;;GAUG;AACH,SAAS,wBAAwB,CAC7B,UAAuC,EAAE,IAAY;IACvD,KAAK,MAAM,IAAI,IAAI,UAAU,EAAE;QAC7B,IAAI,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE;YAChC,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,CAC/C,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;YACnE,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,OAAO,IAAI,CAAC,IAAqB,CAAC;aACnC;SACF;aAAM,IAAI,EAAE,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE;YACxE,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;gBACpF,OAAO,IAAI,CAAC,IAAI,CAAC;aAClB;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,SAAS,kCAAkC,CACvC,IAA0B,EAAE,UAAuC;IACrE,6FAA6F;IAC7F,2FAA2F;IAC3F,cAAc;IACd,MAAM,eAAe,GAAG,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC;IAC/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC/C,MAAM,IAAI,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAEhC,8DAA8D;QAC9D,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YACxE,SAAS;SACV;QAED,8CAA8C;QAC9C,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,EAAE;YAC1D,SAAS;SACV;QAED,kDAAkD;QAClD,MAAM,cAAc,GAChB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,sBAAsB,CAAC,CAAC;QAEjF,0FAA0F;QAC1F,6FAA6F;QAC7F,IAAI,aAAa,GAAG,wBAAwB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;QACzE,IAAI,aAAa,KAAK,IAAI,EAAE;YAC1B,MAAM,IAAI,KAAK,CACX,6BAA6B,cAAc,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,sBAAsB,CAAC,CAAC;SAC5G;QAED,0FAA0F;QAC1F,4DAA4D;QAC5D,aAAa,GAAG,EAAE,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAEnD,eAAe,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,yBAAyB;QAC7C,UAAU,CAAC,IAAI;QACf,UAAU,CAAC,IAAI,CAAC,IAAI;QACpB,UAAU,CAAC,IAAI,CAAC,IAAI;QACpB,iBAAiB,CAAC,aAAa,CAAC,CAAC;QAErC,4DAA4D;QAC5D,aAAa,CAAC,MAAM,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;KAC3C;IAED,MAAM,WAAW,GAAG,EAAE,CAAC,6BAA6B;IAChD,qBAAqB,CAAC,IAAI,CAAC,eAAe;IAC1C,kBAAkB,CAAC,eAAe,CAAC,CAAC;IAExC,MAAM,OAAO,GAAG,EAAE,CAAC,uBAAuB;IACtC,eAAe,CAAC,IAAI;IACpB,eAAe,CAAC,IAAI,CAAC,SAAS;IAC9B,qBAAqB,CAAC,WAAW,CAAC,CAAC;IAEvC,4DAA4D;IAC5D,KAAK,MAAM,IAAI,IAAI,eAAe,EAAE;QAClC,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC;KAC3B;IACD,WAAW,CAAC,MAAM,GAAG,OAAO,CAAC;IAC7B,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;IAC7B,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;GAEG;AACH,SAAS,cAAc,CAAC,IAA0B;IAChD,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,CACzC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,IAAI,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;QACvE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,CAAC,CAAC;AACjE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nconst IVY_SWITCH_PRE_SUFFIX = '__PRE_R3__';\nconst IVY_SWITCH_POST_SUFFIX = '__POST_R3__';\n\nexport function ivySwitchTransform(_: ts.TransformationContext): ts.Transformer<ts.SourceFile> {\n  return flipIvySwitchInFile;\n}\n\nfunction flipIvySwitchInFile(sf: ts.SourceFile): ts.SourceFile {\n  // To replace the statements array, it must be copied. This only needs to happen if a statement\n  // must actually be replaced within the array, so the newStatements array is lazily initialized.\n  let newStatements: ts.Statement[]|undefined = undefined;\n\n  // Iterate over the statements in the file.\n  for (let i = 0; i < sf.statements.length; i++) {\n    const statement = sf.statements[i];\n\n    // Skip over everything that isn't a variable statement.\n    if (!ts.isVariableStatement(statement) || !hasIvySwitches(statement)) {\n      continue;\n    }\n\n    // This statement needs to be replaced. Check if the newStatements array needs to be lazily\n    // initialized to a copy of the original statements.\n    if (newStatements === undefined) {\n      newStatements = [...sf.statements];\n    }\n\n    // Flip any switches in the VariableStatement. If there were any, a new statement will be\n    // returned; otherwise the old statement will be.\n    newStatements[i] = flipIvySwitchesInVariableStatement(statement, sf.statements);\n  }\n\n  // Only update the statements in the SourceFile if any have changed.\n  if (newStatements !== undefined) {\n    sf.statements = ts.createNodeArray(newStatements);\n  }\n  return sf;\n}\n\n/**\n * Look for the ts.Identifier of a ts.Declaration with this name.\n *\n * The real identifier is needed (rather than fabricating one) as TypeScript decides how to\n * reference this identifier based on information stored against its node in the AST, which a\n * synthetic node would not have. In particular, since the post-switch variable is often exported,\n * TypeScript needs to know this so it can write `exports.VAR` instead of just `VAR` when emitting\n * code.\n *\n * Only variable, function, and class declarations are currently searched.\n */\nfunction findPostSwitchIdentifier(\n    statements: ReadonlyArray<ts.Statement>, name: string): ts.Identifier|null {\n  for (const stmt of statements) {\n    if (ts.isVariableStatement(stmt)) {\n      const decl = stmt.declarationList.declarations.find(\n          decl => ts.isIdentifier(decl.name) && decl.name.text === name);\n      if (decl !== undefined) {\n        return decl.name as ts.Identifier;\n      }\n    } else if (ts.isFunctionDeclaration(stmt) || ts.isClassDeclaration(stmt)) {\n      if (stmt.name !== undefined && ts.isIdentifier(stmt.name) && stmt.name.text === name) {\n        return stmt.name;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Flip any Ivy switches which are discovered in the given ts.VariableStatement.\n */\nfunction flipIvySwitchesInVariableStatement(\n    stmt: ts.VariableStatement, statements: ReadonlyArray<ts.Statement>): ts.VariableStatement {\n  // Build a new list of variable declarations. Specific declarations that are initialized to a\n  // pre-switch identifier will be replaced with a declaration initialized to the post-switch\n  // identifier.\n  const newDeclarations = [...stmt.declarationList.declarations];\n  for (let i = 0; i < newDeclarations.length; i++) {\n    const decl = newDeclarations[i];\n\n    // Skip declarations that aren't initialized to an identifier.\n    if (decl.initializer === undefined || !ts.isIdentifier(decl.initializer)) {\n      continue;\n    }\n\n    // Skip declarations that aren't Ivy switches.\n    if (!decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX)) {\n      continue;\n    }\n\n    // Determine the name of the post-switch variable.\n    const postSwitchName =\n        decl.initializer.text.replace(IVY_SWITCH_PRE_SUFFIX, IVY_SWITCH_POST_SUFFIX);\n\n    // Find the post-switch variable identifier. If one can't be found, it's an error. This is\n    // reported as a thrown error and not a diagnostic as transformers cannot output diagnostics.\n    let newIdentifier = findPostSwitchIdentifier(statements, postSwitchName);\n    if (newIdentifier === null) {\n      throw new Error(\n          `Unable to find identifier ${postSwitchName} in ${stmt.getSourceFile().fileName} for the Ivy switch.`);\n    }\n\n    // Copy the identifier with updateIdentifier(). This copies the internal information which\n    // allows TS to write a correct reference to the identifier.\n    newIdentifier = ts.updateIdentifier(newIdentifier);\n\n    newDeclarations[i] = ts.updateVariableDeclaration(\n        /* node */ decl,\n        /* name */ decl.name,\n        /* type */ decl.type,\n        /* initializer */ newIdentifier);\n\n    // Keeping parent pointers up to date is important for emit.\n    newIdentifier.parent = newDeclarations[i];\n  }\n\n  const newDeclList = ts.updateVariableDeclarationList(\n      /* declarationList */ stmt.declarationList,\n      /* declarations */ newDeclarations);\n\n  const newStmt = ts.updateVariableStatement(\n      /* statement */ stmt,\n      /* modifiers */ stmt.modifiers,\n      /* declarationList */ newDeclList);\n\n  // Keeping parent pointers up to date is important for emit.\n  for (const decl of newDeclarations) {\n    decl.parent = newDeclList;\n  }\n  newDeclList.parent = newStmt;\n  newStmt.parent = stmt.parent;\n  return newStmt;\n}\n\n/**\n * Check whether the given VariableStatement has any Ivy switch variables.\n */\nfunction hasIvySwitches(stmt: ts.VariableStatement) {\n  return stmt.declarationList.declarations.some(\n      decl => decl.initializer !== undefined && ts.isIdentifier(decl.initializer) &&\n          decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX));\n}\n"]}