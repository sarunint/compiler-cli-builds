{"version":3,"file":"type_constructor.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,iCAAiC;AAIjC;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,SAAgB,gBAAgB,CAC5B,IAAyB,EAAE,IAAsB;IACnD,8FAA8F;IAC9F,uEAAuE;IACvE,yEAAyE;IACzE,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,KAAK,SAAS,CAAC,CAAC;QACnD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;QACrF,SAAS,CAAC;IACd,MAAM,OAAO,GAAgB,EAAE,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAM,EAAE,WAAW,CAAC,CAAC;IAElF,sFAAsF;IACtF,8EAA8E;IAC9E,EAAE;IACF,kEAAkE;IAClE,EAAE;IACF,8FAA8F;IAC9F,+FAA+F;IAC/F,2BAA2B;IAC3B,EAAE;IACF,8EAA8E;IAC9E,IAAI,QAAqB,CAAC;IAE1B,MAAM,IAAI,GAAa;QACrB,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM;QACrB,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO;QACtB,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO;KACvB,CAAC;IACF,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,4FAA4F;QAC5F,QAAQ,GAAG,EAAE,CAAC,qBAAqB,CAAC,EAAE,CAAC,CAAC;KACzC;SAAM;QACL,4CAA4C;QAC5C,MAAM,YAAY,GAAG,EAAE,CAAC,mBAAmB,CACvC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,qBAAqB,CAAC,EAAE,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAE5E,6CAA6C;QAC7C,MAAM,QAAQ,GAAG,EAAE,CAAC,uBAAuB,CAAC,MAAM,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC,CAAC;QAE7E,mCAAmC;QACnC,QAAQ,GAAG,EAAE,CAAC,uBAAuB,CAAC,SAAS,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;KAC9D;IAED,8FAA8F;IAC9F,+FAA+F;IAC/F,oBAAoB;IACpB,IAAI,IAAI,GAAuB,SAAS,CAAC;IACzC,IAAI,IAAI,CAAC,IAAI,EAAE;QACb,IAAI,GAAG,EAAE,CAAC,WAAW,CAAC;YACpB,EAAE,CAAC,YAAY,CAAC,EAAE,CAAC,uBAAuB,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC;SAC7D,CAAC,CAAC;KACJ;IAED,sCAAsC;IACtC,MAAM,SAAS,GAAG,EAAE,CAAC,eAAe;IAChC,gBAAgB,CAAC,SAAS;IAC1B,eAAe,CAAC,SAAS;IACzB,oBAAoB,CAAC,SAAS;IAC9B,UAAU,CAAC,MAAM;IACjB,mBAAmB,CAAC,SAAS;IAC7B,UAAU,CAAC,QAAQ;IACnB,iBAAiB,CAAC,SAAS,CAAG,CAAC;IAEnC,kDAAkD;IAClD,OAAO,EAAE,CAAC,YAAY;IAClB,gBAAgB,CAAC,SAAS;IAC1B,eAAe,CAAA,CAAC,EAAE,CAAC,cAAc,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;IAC/D,mBAAmB,CAAC,SAAS;IAC7B,UAAU,CAAC,IAAI,CAAC,MAAM;IACtB,mBAAmB,CAAC,SAAS;IAC7B,oBAAoB,CAAC,IAAI,CAAC,cAAc;IACxC,gBAAgB,CAAA,CAAC,SAAS,CAAC;IAC3B,UAAU,CAAC,OAAO;IAClB,UAAU,CAAC,IAAI,CAAG,CAAC;AACzB,CAAC;AAzED,4CAyEC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {TypeCtorMetadata} from './api';\n\n/**\n * Generate a type constructor for the given class and metadata.\n *\n * A type constructor is a specially shaped TypeScript static method, intended to be placed within\n * a directive class itself, that permits type inference of any generic type parameters of the class\n * from the types of expressions bound to inputs or outputs, and the types of elements that match\n * queries performed by the directive. It also catches any errors in the types of these expressions.\n * This method is never called at runtime, but is used in type-check blocks to construct directive\n * types.\n *\n * A type constructor for NgFor looks like:\n *\n * static ngTypeCtor<T>(init: Partial<Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>>):\n *   NgForOf<T>;\n *\n * A typical usage would be:\n *\n * NgForOf.ngTypeCtor(init: {ngForOf: ['foo', 'bar']}); // Infers a type of NgForOf<string>.\n *\n * @param node the `ts.ClassDeclaration` for which a type constructor will be generated.\n * @param meta additional metadata required to generate the type constructor.\n * @returns a `ts.MethodDeclaration` for the type constructor.\n */\nexport function generateTypeCtor(\n    node: ts.ClassDeclaration, meta: TypeCtorMetadata): ts.MethodDeclaration {\n  // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from\n  // the definition without any type bounds. For example, if the class is\n  // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.\n  const rawTypeArgs = node.typeParameters !== undefined ?\n      node.typeParameters.map(param => ts.createTypeReferenceNode(param.name, undefined)) :\n      undefined;\n  const rawType: ts.TypeNode = ts.createTypeReferenceNode(node.name !, rawTypeArgs);\n\n  // initType is the type of 'init', the single argument to the type constructor method.\n  // If the Directive has any inputs, outputs, or queries, its initType will be:\n  //\n  // Partial<Pick<rawType, 'inputField'|'outputField'|'queryField'>>\n  //\n  // Pick here is used to select only those fields from which the generic type parameters of the\n  // directive will be inferred. Partial is used because inputs are optional, so there may not be\n  // bindings for each field.\n  //\n  // In the special case there are no inputs/outputs/etc, initType is set to {}.\n  let initType: ts.TypeNode;\n\n  const keys: string[] = [\n    ...meta.fields.inputs,\n    ...meta.fields.outputs,\n    ...meta.fields.queries,\n  ];\n  if (keys.length === 0) {\n    // Special case - no inputs, outputs, or other fields which could influence the result type.\n    initType = ts.createTypeLiteralNode([]);\n  } else {\n    // Construct a union of all the field names.\n    const keyTypeUnion = ts.createUnionTypeNode(\n        keys.map(key => ts.createLiteralTypeNode(ts.createStringLiteral(key))));\n\n    // Construct the Pick<rawType, keyTypeUnion>.\n    const pickType = ts.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);\n\n    // Construct the Partial<pickType>.\n    initType = ts.createTypeReferenceNode('Partial', [pickType]);\n  }\n\n  // If this constructor is being generated into a .ts file, then it needs a fake body. The body\n  // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,\n  // it needs no body.\n  let body: ts.Block|undefined = undefined;\n  if (meta.body) {\n    body = ts.createBlock([\n      ts.createReturn(ts.createNonNullExpression(ts.createNull())),\n    ]);\n  }\n\n  // Create the 'init' parameter itself.\n  const initParam = ts.createParameter(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'init',\n      /* questionToken */ undefined,\n      /* type */ initType,\n      /* initializer */ undefined, );\n\n  // Create the type constructor method declaration.\n  return ts.createMethod(\n      /* decorators */ undefined,\n      /* modifiers */[ts.createModifier(ts.SyntaxKind.StaticKeyword)],\n      /* asteriskToken */ undefined,\n      /* name */ meta.fnName,\n      /* questionToken */ undefined,\n      /* typeParameters */ node.typeParameters,\n      /* parameters */[initParam],\n      /* type */ rawType,\n      /* body */ body, );\n}\n"]}