{"version":3,"file":"type_check_block.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingType, BoundTarget, ImplicitReceiver, PropertyRead, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../metadata';\nimport {ImportManager, translateExpression} from '../../translator';\n\nimport {TypeCheckBlockMetadata, TypeCheckableDirectiveMeta} from './api';\nimport {astToTypescript} from './expression';\n\n\n/**\n * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n * \"type check block\" function.\n *\n * When passed through TypeScript's TypeChecker, type errors that arise within the type check block\n * function indicate issues in the template itself.\n *\n * @param node the TypeScript node for the component class.\n * @param meta metadata about the component's template and the function being generated.\n * @param importManager an `ImportManager` for the file into which the TCB will be written.\n */\nexport function generateTypeCheckBlock(\n    node: ts.ClassDeclaration, meta: TypeCheckBlockMetadata,\n    importManager: ImportManager): ts.FunctionDeclaration {\n  const tcb = new Context(meta.boundTarget, node.getSourceFile(), importManager);\n  const scope = new Scope(tcb);\n  tcbProcessNodes(meta.boundTarget.target.template !, tcb, scope);\n\n  const body = ts.createBlock([ts.createIf(ts.createTrue(), scope.getBlock())]);\n\n  return ts.createFunctionDeclaration(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* asteriskToken */ undefined,\n      /* name */ meta.fnName,\n      /* typeParameters */ node.typeParameters,\n      /* parameters */[tcbCtxParam(node)],\n      /* type */ undefined,\n      /* body */ body);\n}\n\n/**\n * Overall generation context for the type check block.\n *\n * `Context` handles operations during code generation which are global with respect to the whole\n * block. It's responsible for variable name allocation and management of any imports needed. It\n * also contains the template metadata itself.\n */\nclass Context {\n  private nextId = 1;\n\n  constructor(\n      readonly boundTarget: BoundTarget<TypeCheckableDirectiveMeta>,\n      private sourceFile: ts.SourceFile, private importManager: ImportManager) {}\n\n  /**\n   * Allocate a new variable name for use within the `Context`.\n   *\n   * Currently this uses a monotonically increasing counter, but in the future the variable name\n   * might change depending on the type of data being stored.\n   */\n  allocateId(): ts.Identifier { return ts.createIdentifier(`_t${this.nextId++}`); }\n\n  /**\n   * Write a `ts.Expression` that references the given node.\n   *\n   * This may involve importing the node into the file if it's not declared there already.\n   */\n  reference(ref: Reference<ts.Node>): ts.Expression {\n    const ngExpr = ref.toExpression(this.sourceFile);\n    if (ngExpr === null) {\n      throw new Error(`Unreachable reference: ${ref.node}`);\n    }\n\n    // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n    return translateExpression(ngExpr, this.importManager);\n  }\n}\n\n/**\n * Local scope within the type check block for a particular template.\n *\n * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a\n * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type\n * check block, where each nested template is encased in an `if` structure.\n *\n * As a template is processed in a given `Scope`, statements are added via `addStatement()`. When\n * this processing is complete, the `Scope` can be turned into a `ts.Block` via `getBlock()`.\n */\nclass Scope {\n  /**\n   * Map of nodes to information about that node within the TCB.\n   *\n   * For example, this stores the `ts.Identifier` within the TCB for an element or <ng-template>.\n   */\n  private elementData = new Map<TmplAstElement|TmplAstTemplate, TcbNodeData>();\n\n  /**\n   * Map of immediately nested <ng-template>s (within this `Scope`) to the `ts.Identifier` of their\n   * rendering contexts.\n   */\n  private templateCtx = new Map<TmplAstTemplate, ts.Identifier>();\n\n  /**\n   * Map of variables declared on the template that created this `Scope` to their `ts.Identifier`s\n   * within the TCB.\n   */\n  private varMap = new Map<TmplAstVariable, ts.Identifier>();\n\n  /**\n   * Statements for this template.\n   */\n  private statements: ts.Statement[] = [];\n\n  constructor(private tcb: Context, private parent: Scope|null = null) {}\n\n  /**\n   * Get the identifier within the TCB for a given `TmplAstElement`.\n   */\n  getElementId(el: TmplAstElement): ts.Identifier|null {\n    const data = this.getElementData(el, false);\n    if (data !== null && data.htmlNode !== null) {\n      return data.htmlNode;\n    }\n    return this.parent !== null ? this.parent.getElementId(el) : null;\n  }\n\n  /**\n   * Get the identifier of a directive instance on a given template node.\n   */\n  getDirectiveId(el: TmplAstElement|TmplAstTemplate, dir: TypeCheckableDirectiveMeta): ts.Identifier\n      |null {\n    const data = this.getElementData(el, false);\n    if (data !== null && data.directives !== null && data.directives.has(dir)) {\n      return data.directives.get(dir) !;\n    }\n    return this.parent !== null ? this.parent.getDirectiveId(el, dir) : null;\n  }\n\n  /**\n   * Get the identifier of a template's rendering context.\n   */\n  getTemplateCtx(tmpl: TmplAstTemplate): ts.Identifier|null {\n    return this.templateCtx.get(tmpl) ||\n        (this.parent !== null ? this.parent.getTemplateCtx(tmpl) : null);\n  }\n\n  /**\n   * Get the identifier of a template variable.\n   */\n  getVariableId(v: TmplAstVariable): ts.Identifier|null {\n    return this.varMap.get(v) || (this.parent !== null ? this.parent.getVariableId(v) : null);\n  }\n\n  /**\n   * Allocate an identifier for the given template element.\n   */\n  allocateElementId(el: TmplAstElement): ts.Identifier {\n    const data = this.getElementData(el, true);\n    if (data.htmlNode === null) {\n      data.htmlNode = this.tcb.allocateId();\n    }\n    return data.htmlNode;\n  }\n\n  /**\n   * Allocate an identifier for the given template variable.\n   */\n  allocateVariableId(v: TmplAstVariable): ts.Identifier {\n    if (!this.varMap.has(v)) {\n      this.varMap.set(v, this.tcb.allocateId());\n    }\n    return this.varMap.get(v) !;\n  }\n\n  /**\n   * Allocate an identifier for an instance of the given directive on the given template node.\n   */\n  allocateDirectiveId(el: TmplAstElement|TmplAstTemplate, dir: TypeCheckableDirectiveMeta):\n      ts.Identifier {\n    // Look up the data for this template node.\n    const data = this.getElementData(el, true);\n\n    // Lazily populate the directives map, if it exists.\n    if (data.directives === null) {\n      data.directives = new Map<TypeCheckableDirectiveMeta, ts.Identifier>();\n    }\n    if (!data.directives.has(dir)) {\n      data.directives.set(dir, this.tcb.allocateId());\n    }\n    return data.directives.get(dir) !;\n  }\n\n  /**\n   * Allocate an identifier for the rendering context of a given template.\n   */\n  allocateTemplateCtx(tmpl: TmplAstTemplate): ts.Identifier {\n    if (!this.templateCtx.has(tmpl)) {\n      this.templateCtx.set(tmpl, this.tcb.allocateId());\n    }\n    return this.templateCtx.get(tmpl) !;\n  }\n\n  /**\n   * Add a statement to this scope.\n   */\n  addStatement(stmt: ts.Statement): void { this.statements.push(stmt); }\n\n  /**\n   * Get a `ts.Block` containing the statements in this scope.\n   */\n  getBlock(): ts.Block { return ts.createBlock(this.statements); }\n\n  /**\n   * Internal helper to get the data associated with a particular element.\n   *\n   * This can either return `null` if the data is not present (when the `alloc` flag is set to\n   * `false`), or it can initialize the data for the element (when `alloc` is `true`).\n   */\n  private getElementData(el: TmplAstElement|TmplAstTemplate, alloc: true): TcbNodeData;\n  private getElementData(el: TmplAstElement|TmplAstTemplate, alloc: false): TcbNodeData|null;\n  private getElementData(el: TmplAstElement|TmplAstTemplate, alloc: boolean): TcbNodeData|null {\n    if (alloc && !this.elementData.has(el)) {\n      this.elementData.set(el, {htmlNode: null, directives: null});\n    }\n    return this.elementData.get(el) || null;\n  }\n}\n\n/**\n * Data stored for a template node in a TCB.\n */\ninterface TcbNodeData {\n  /**\n   * The identifier of the node element instance, if any.\n   */\n  htmlNode: ts.Identifier|null;\n  directives: Map<TypeCheckableDirectiveMeta, ts.Identifier>|null;\n}\n\n/**\n * Create the `ctx` parameter to the top-level TCB function.\n *\n * This is a parameter with a type equivalent to the component type, with all generic type\n * parameters listed (without their generic bounds).\n */\nfunction tcbCtxParam(node: ts.ClassDeclaration): ts.ParameterDeclaration {\n  let typeArguments: ts.TypeNode[]|undefined = undefined;\n  // Check if the component is generic, and pass generic type parameters if so.\n  if (node.typeParameters !== undefined) {\n    typeArguments =\n        node.typeParameters.map(param => ts.createTypeReferenceNode(param.name, undefined));\n  }\n  const type = ts.createTypeReferenceNode(node.name !, typeArguments);\n  return ts.createParameter(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'ctx',\n      /* questionToken */ undefined,\n      /* type */ type,\n      /* initializer */ undefined);\n}\n\n/**\n * Process an array of template nodes and generate type checking code for them within the given\n * `Scope`.\n *\n * @param nodes template node array over which to iterate.\n * @param tcb context of the overall type check block.\n * @param scope\n */\nfunction tcbProcessNodes(nodes: TmplAstNode[], tcb: Context, scope: Scope): void {\n  nodes.forEach(node => {\n    // Process elements, templates, and bindings.\n    if (node instanceof TmplAstElement) {\n      tcbProcessElement(node, tcb, scope);\n    } else if (node instanceof TmplAstTemplate) {\n      tcbProcessTemplateDeclaration(node, tcb, scope);\n    } else if (node instanceof TmplAstBoundText) {\n      const expr = tcbExpression(node.value, tcb, scope);\n      scope.addStatement(ts.createStatement(expr));\n    }\n  });\n}\n\n/**\n * Process an element, generating type checking code for it, its directives, and its children.\n */\nfunction tcbProcessElement(el: TmplAstElement, tcb: Context, scope: Scope): ts.Identifier {\n  let id = scope.getElementId(el);\n  if (id !== null) {\n    // This element has been processed before. No need to run through it again.\n    return id;\n  }\n  id = scope.allocateElementId(el);\n\n  // Add the declaration of the element using document.createElement.\n  scope.addStatement(tsCreateVariable(id, tsCreateElement(el.name)));\n\n\n  // Construct a set of all the input bindings. Anything matched by directives will be removed from\n  // this set. The rest are bindings being made on the element itself.\n  const inputs = new Set(\n      el.inputs.filter(input => input.type === BindingType.Property).map(input => input.name));\n\n  // Process directives of the node.\n  tcbProcessDirectives(el, inputs, tcb, scope);\n\n  // At this point, `inputs` now contains only those bindings not matched by any directive. These\n  // bindings go to the element itself.\n  inputs.forEach(name => {\n    const binding = el.inputs.find(input => input.name === name) !;\n    const expr = tcbExpression(binding.value, tcb, scope);\n\n    const prop = ts.createPropertyAccess(id !, name);\n    const assign = ts.createBinary(prop, ts.SyntaxKind.EqualsToken, expr);\n    scope.addStatement(ts.createStatement(assign));\n  });\n\n  // Recurse into children.\n  tcbProcessNodes(el.children, tcb, scope);\n\n  return id;\n}\n\n/**\n * Process all the directives associated with a given template node.\n */\nfunction tcbProcessDirectives(\n    el: TmplAstElement | TmplAstTemplate, unclaimed: Set<string>, tcb: Context,\n    scope: Scope): void {\n  const directives = tcb.boundTarget.getDirectivesOfNode(el);\n  if (directives === null) {\n    // No directives, nothing to do.\n    return;\n  }\n  directives.forEach(dir => tcbProcessDirective(el, dir, unclaimed, tcb, scope));\n}\n\n/**\n * Process a directive, generating type checking code for it.\n */\nfunction tcbProcessDirective(\n    el: TmplAstElement | TmplAstTemplate, dir: TypeCheckableDirectiveMeta, unclaimed: Set<string>,\n    tcb: Context, scope: Scope): ts.Identifier {\n  let id = scope.getDirectiveId(el, dir);\n  if (id !== null) {\n    // This directive has been processed before. No need to run through it again.\n    return id;\n  }\n  id = scope.allocateDirectiveId(el, dir);\n\n  const bindings = tcbGetInputBindingExpressions(el, dir, tcb, scope);\n\n\n  // Call the type constructor of the directive to infer a type, and assign the directive instance.\n  scope.addStatement(tsCreateVariable(id, tcbCallTypeCtor(el, dir, tcb, scope, bindings)));\n\n  tcbProcessBindings(id, bindings, unclaimed, tcb, scope);\n\n  return id;\n}\n\nfunction tcbProcessBindings(\n    recv: ts.Expression, bindings: TcbBinding[], unclaimed: Set<string>, tcb: Context,\n    scope: Scope): void {\n  // Iterate through all the bindings this directive is consuming.\n  bindings.forEach(binding => {\n    // Generate an assignment statement for this binding.\n    const prop = ts.createPropertyAccess(recv, binding.field);\n    const assign = ts.createBinary(prop, ts.SyntaxKind.EqualsToken, binding.expression);\n    scope.addStatement(ts.createStatement(assign));\n\n    // Remove the binding from the set of unclaimed inputs, as this directive has 'claimed' it.\n    unclaimed.delete(binding.property);\n  });\n}\n\n/**\n * Process a nested <ng-template>, generating type-checking code for it and its children.\n *\n * The nested <ng-template> is represented with an `if` structure, which creates a new syntactical\n * scope for the type checking code for the template. If the <ng-template> has any directives, they\n * can influence type inference within the `if` block through defined guard functions.\n */\nfunction tcbProcessTemplateDeclaration(tmpl: TmplAstTemplate, tcb: Context, scope: Scope) {\n  // Create a new Scope to represent bindings captured in the template.\n  const tmplScope = new Scope(tcb, scope);\n\n  // Allocate a template ctx variable and declare it with an 'any' type.\n  const ctx = tmplScope.allocateTemplateCtx(tmpl);\n  const type = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n  scope.addStatement(tsDeclareVariable(ctx, type));\n\n  // Process directives on the template.\n  tcbProcessDirectives(tmpl, new Set(), tcb, scope);\n\n  // Process the template itself (inside the inner Scope).\n  tcbProcessNodes(tmpl.children, tcb, tmplScope);\n\n  // An `if` will be constructed, within which the template's children will be type checked. The\n  // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared in\n  // the template's TCB from the outer context, and it allows any directives on the templates to\n  // perform type narrowing of either expressions or the template's context.\n\n  // The guard is the `if` block's condition. It's usually set to `true` but directives that exist\n  // on the template can trigger extra guard expressions that serve to narrow types within the\n  // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.\n  // Collect these into `guards` by processing the directives.\n  const directiveGuards: ts.Expression[] = [];\n\n  const directives = tcb.boundTarget.getDirectivesOfNode(tmpl);\n  if (directives !== null) {\n    directives.forEach(dir => {\n      const dirInstId = scope.getDirectiveId(tmpl, dir) !;\n      const dirId = tcb.reference(dir.ref);\n\n      // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of\n      // the expression passed to an @Input of the directive. Scan the directive to see if it has\n      // any template guards, and generate them if needed.\n      dir.ngTemplateGuards.forEach(inputName => {\n        // For each template guard function on the directive, look for a binding to that input.\n        const boundInput = tmpl.inputs.find(i => i.name === inputName);\n        if (boundInput !== undefined) {\n          // If there is such a binding, generate an expression for it.\n          const expr = tcbExpression(boundInput.value, tcb, scope);\n          // Call the guard function on the directive with the directive instance and that\n          // expression.\n          const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${inputName}`, [\n            dirInstId,\n            expr,\n          ]);\n          directiveGuards.push(guardInvoke);\n        }\n      });\n\n      // The second kind of guard is a template context guard. This guard narrows the template\n      // rendering context variable `ctx`.\n      if (dir.hasNgTemplateContextGuard) {\n        const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);\n        directiveGuards.push(guardInvoke);\n      }\n    });\n  }\n\n  // By default the guard is simply `true`.\n  let guard: ts.Expression = ts.createTrue();\n\n  // If there are any guards from directives, use them instead.\n  if (directiveGuards.length > 0) {\n    // Pop the first value and use it as the initializer to reduce(). This way, a single guard\n    // will be used on its own, but two or more will be combined into binary expressions.\n    guard = directiveGuards.reduce(\n        (expr, dirGuard) => ts.createBinary(expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard),\n        directiveGuards.pop() !);\n  }\n\n  // Construct the `if` block for the template with the generated guard expression.\n  const tmplIf = ts.createIf(\n      /* expression */ guard,\n      /* thenStatement */ tmplScope.getBlock());\n  scope.addStatement(tmplIf);\n}\n\n/**\n * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the\n * correct identifiers in the current scope.\n */\nfunction tcbExpression(ast: AST, tcb: Context, scope: Scope): ts.Expression {\n  // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed which\n  // interprets specific expression nodes that interact with the `ImplicitReceiver`. These nodes\n  // actually refer to identifiers within the current scope.\n  return astToTypescript(ast, (ast) => tcbResolve(ast, tcb, scope));\n}\n\n/**\n * Call the type constructor of a directive instance on a given template node, inferring a type for\n * the directive instance from any bound inputs.\n */\nfunction tcbCallTypeCtor(\n    el: TmplAstElement | TmplAstTemplate, dir: TypeCheckableDirectiveMeta, tcb: Context,\n    scope: Scope, bindings: TcbBinding[]): ts.Expression {\n  const dirClass = tcb.reference(dir.ref);\n\n  // Construct an array of `ts.PropertyAssignment`s for each input of the directive that has a\n  // matching binding.\n  const members = bindings.map(b => ts.createPropertyAssignment(b.field, b.expression));\n\n  // Call the `ngTypeCtor` method on the directive class, with an object literal argument created\n  // from the matched inputs.\n  return tsCallMethod(\n      /* receiver */ dirClass,\n      /* methodName */ 'ngTypeCtor',\n      /* args */[ts.createObjectLiteral(members)]);\n}\n\ninterface TcbBinding {\n  field: string;\n  property: string;\n  expression: ts.Expression;\n}\n\nfunction tcbGetInputBindingExpressions(\n    el: TmplAstElement | TmplAstTemplate, dir: TypeCheckableDirectiveMeta, tcb: Context,\n    scope: Scope): TcbBinding[] {\n  const bindings: TcbBinding[] = [];\n  // `dir.inputs` is an object map of field names on the directive class to property names.\n  // This is backwards from what's needed to match bindings - a map of properties to field names\n  // is desired. Invert `dir.inputs` into `propMatch` to create this map.\n  const propMatch = new Map<string, string>();\n  const inputs = dir.inputs;\n  Object.keys(inputs).forEach(key => {\n    Array.isArray(inputs[key]) ? propMatch.set(inputs[key][0], key) :\n                                 propMatch.set(inputs[key] as string, key);\n  });\n\n  // Add a binding expression to the map for each input of the directive that has a\n  // matching binding.\n  el.inputs.filter(input => propMatch.has(input.name)).forEach(input => {\n    // Produce an expression representing the value of the binding.\n    const expr = tcbExpression(input.value, tcb, scope);\n\n    // Call the callback.\n    bindings.push({\n      property: input.name,\n      field: propMatch.get(input.name) !,\n      expression: expr,\n    });\n  });\n  return bindings;\n}\n\n/**\n * Create an expression which instantiates an element by its HTML tagName.\n *\n * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred\n * based on the tag name, including for custom elements that have appropriate .d.ts definitions.\n */\nfunction tsCreateElement(tagName: string): ts.Expression {\n  const createElement = ts.createPropertyAccess(\n      /* expression */ ts.createIdentifier('document'), 'createElement');\n  return ts.createCall(\n      /* expression */ createElement,\n      /* typeArguments */ undefined,\n      /* argumentsArray */[ts.createLiteral(tagName)]);\n}\n\n/**\n * Create a `ts.VariableStatement` which declares a variable without explicit initialization.\n *\n * The initializer `null!` is used to bypass strict variable initialization checks.\n *\n * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.\n */\nfunction tsDeclareVariable(id: ts.Identifier, type: ts.TypeNode): ts.VariableStatement {\n  const decl = ts.createVariableDeclaration(\n      /* name */ id,\n      /* type */ type,\n      /* initializer */ ts.createNonNullExpression(ts.createNull()));\n  return ts.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Create a `ts.VariableStatement` that initializes a variable with a given expression.\n *\n * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer\n * expression.\n */\nfunction tsCreateVariable(id: ts.Identifier, initializer: ts.Expression): ts.VariableStatement {\n  const decl = ts.createVariableDeclaration(\n      /* name */ id,\n      /* type */ undefined,\n      /* initializer */ initializer);\n  return ts.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Construct a `ts.CallExpression` that calls a method on a receiver.\n */\nfunction tsCallMethod(\n    receiver: ts.Expression, methodName: string, args: ts.Expression[] = []): ts.CallExpression {\n  const methodAccess = ts.createPropertyAccess(receiver, methodName);\n  return ts.createCall(\n      /* expression */ methodAccess,\n      /* typeArguments */ undefined,\n      /* argumentsArray */ args);\n}\n\n/**\n * Resolve an `AST` expression within the given scope.\n *\n * Some `AST` expressions refer to top-level concepts (references, variables, the component\n * context). This method assists in resolving those.\n */\nfunction tcbResolve(ast: AST, tcb: Context, scope: Scope): ts.Expression|null {\n  // Short circuit for AST types that won't have mappings.\n  if (!(ast instanceof ImplicitReceiver || ast instanceof PropertyRead)) {\n    return null;\n  }\n\n  if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {\n    // Check whether the template metadata has bound a target for this expression. If so, then\n    // resolve that target. If not, then the expression is referencing the top-level component\n    // context.\n    const binding = tcb.boundTarget.getExpressionTarget(ast);\n    if (binding !== null) {\n      // This expression has a binding to some variable or reference in the template. Resolve it.\n      if (binding instanceof TmplAstVariable) {\n        return tcbResolveVariable(binding, tcb, scope);\n      } else {\n        throw new Error(`Not handled: ${binding}`);\n      }\n    } else {\n      // This is a PropertyRead(ImplicitReceiver) and probably refers to a property access on the\n      // component context. Let it fall through resolution here so it will be caught when the\n      // ImplicitReceiver is resolved in the branch below.\n      return null;\n    }\n  } else if (ast instanceof ImplicitReceiver) {\n    // AST instances representing variables and references look very similar to property reads from\n    // the component context: both have the shape PropertyRead(ImplicitReceiver, 'propertyName').\n    // `tcbExpression` will first try to `tcbResolve` the outer PropertyRead. If this works, it's\n    // because the `BoundTarget` found an expression target for the whole expression, and therefore\n    // `tcbExpression` will never attempt to `tcbResolve` the ImplicitReceiver of that PropertyRead.\n    //\n    // Therefore if `tcbResolve` is called on an `ImplicitReceiver`, it's because no outer\n    // PropertyRead resolved to a variable or reference, and therefore this is a property read on\n    // the component context itself.\n    return ts.createIdentifier('ctx');\n  } else {\n    // This AST isn't special after all.\n    return null;\n  }\n}\n\n/**\n * Resolve a variable to an identifier that represents its value.\n */\nfunction tcbResolveVariable(binding: TmplAstVariable, tcb: Context, scope: Scope): ts.Identifier {\n  // Look to see whether the variable was already initialized. If so, just reuse it.\n  let id = scope.getVariableId(binding);\n  if (id !== null) {\n    return id;\n  }\n\n  // Look for the template which declares this variable.\n  const tmpl = tcb.boundTarget.getTemplateOfSymbol(binding);\n  if (tmpl === null) {\n    throw new Error(`Expected TmplAstVariable to be mapped to a TmplAstTemplate`);\n  }\n  // Look for a context variable for the template. This should've been declared before anything\n  // that could reference the template's variables.\n  const ctx = scope.getTemplateCtx(tmpl);\n  if (ctx === null) {\n    throw new Error('Expected template context to exist.');\n  }\n\n  // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable on\n  // the template context.\n  id = scope.allocateVariableId(binding);\n  const initializer = ts.createPropertyAccess(\n      /* expression */ ctx,\n      /* name */ binding.value);\n\n  // Declare the variable, and return its identifier.\n  scope.addStatement(tsCreateVariable(id, initializer));\n  return id;\n}\n"]}