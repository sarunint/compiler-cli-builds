{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ASTWithSource, Binary, Conditional, Interpolation, LiteralPrimitive, MethodCall, PropertyRead} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nconst BINARY_OPS = new Map<string, ts.SyntaxKind>([\n  ['+', ts.SyntaxKind.PlusToken],\n  ['-', ts.SyntaxKind.MinusToken],\n  ['<', ts.SyntaxKind.LessThanToken],\n  ['>', ts.SyntaxKind.GreaterThanToken],\n  ['<=', ts.SyntaxKind.LessThanEqualsToken],\n  ['>=', ts.SyntaxKind.GreaterThanEqualsToken],\n  ['==', ts.SyntaxKind.EqualsEqualsToken],\n  ['===', ts.SyntaxKind.EqualsEqualsEqualsToken],\n  ['*', ts.SyntaxKind.AsteriskToken],\n  ['/', ts.SyntaxKind.SlashToken],\n  ['%', ts.SyntaxKind.PercentToken],\n  ['!=', ts.SyntaxKind.ExclamationEqualsToken],\n  ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken],\n  ['||', ts.SyntaxKind.BarBarToken],\n  ['&&', ts.SyntaxKind.AmpersandAmpersandToken],\n  ['&', ts.SyntaxKind.AmpersandToken],\n  ['|', ts.SyntaxKind.BarToken],\n]);\n\n/**\n * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`\n * AST.\n */\nexport function astToTypescript(\n    ast: AST, maybeResolve: (ast: AST) => ts.Expression | null): ts.Expression {\n  const resolved = maybeResolve(ast);\n  if (resolved !== null) {\n    return resolved;\n  }\n  // Branch based on the type of expression being processed.\n  if (ast instanceof ASTWithSource) {\n    // Fall through to the underlying AST.\n    return astToTypescript(ast.ast, maybeResolve);\n  } else if (ast instanceof PropertyRead) {\n    // This is a normal property read - convert the receiver to an expression and emit the correct\n    // TypeScript expression to read the property.\n    const receiver = astToTypescript(ast.receiver, maybeResolve);\n    return ts.createPropertyAccess(receiver, ast.name);\n  } else if (ast instanceof Interpolation) {\n    return astArrayToExpression(ast.expressions, maybeResolve);\n  } else if (ast instanceof Binary) {\n    const lhs = astToTypescript(ast.left, maybeResolve);\n    const rhs = astToTypescript(ast.right, maybeResolve);\n    const op = BINARY_OPS.get(ast.operation);\n    if (op === undefined) {\n      throw new Error(`Unsupported Binary.operation: ${ast.operation}`);\n    }\n    return ts.createBinary(lhs, op as any, rhs);\n  } else if (ast instanceof LiteralPrimitive) {\n    if (ast.value === undefined) {\n      return ts.createIdentifier('undefined');\n    } else if (ast.value === null) {\n      return ts.createNull();\n    } else {\n      return ts.createLiteral(ast.value);\n    }\n  } else if (ast instanceof MethodCall) {\n    const receiver = astToTypescript(ast.receiver, maybeResolve);\n    const method = ts.createPropertyAccess(receiver, ast.name);\n    const args = ast.args.map(expr => astToTypescript(expr, maybeResolve));\n    return ts.createCall(method, undefined, args);\n  } else if (ast instanceof Conditional) {\n    const condExpr = astToTypescript(ast.condition, maybeResolve);\n    const trueExpr = astToTypescript(ast.trueExp, maybeResolve);\n    const falseExpr = astToTypescript(ast.falseExp, maybeResolve);\n    return ts.createParen(ts.createConditional(condExpr, trueExpr, falseExpr));\n  } else {\n    throw new Error(`Unknown node type: ${Object.getPrototypeOf(ast).constructor}`);\n  }\n}\n\n/**\n * Convert an array of `AST` expressions into a single `ts.Expression`, by converting them all\n * and separating them with commas.\n */\nfunction astArrayToExpression(\n    astArray: AST[], maybeResolve: (ast: AST) => ts.Expression | null): ts.Expression {\n  // Reduce the `asts` array into a `ts.Expression`. Multiple expressions are combined into a\n  // `ts.BinaryExpression` with a comma separator. First make a copy of the input array, as\n  // it will be modified during the reduction.\n  const asts = astArray.slice();\n  return asts.reduce(\n      (lhs, ast) =>\n          ts.createBinary(lhs, ts.SyntaxKind.CommaToken, astToTypescript(ast, maybeResolve)),\n      astToTypescript(asts.pop() !, maybeResolve));\n}\n"]}