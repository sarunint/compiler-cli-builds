{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/context.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3TargetBinder, SelectorMatcher, TmplAstNode} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ImportManager} from '../../translator';\n\nimport {TypeCheckBlockMetadata, TypeCheckableDirectiveMeta, TypeCtorMetadata} from './api';\nimport {generateTypeCheckBlock} from './type_check_block';\nimport {generateTypeCtor} from './type_constructor';\n\n\n/**\n * A template type checking context for a program.\n *\n * The `TypeCheckContext` allows registration of components and their templates which need to be\n * type checked. It also allows generation of modified `ts.SourceFile`s which contain the type\n * checking code.\n */\nexport class TypeCheckContext {\n  /**\n   * A `Set` of classes which will be used to generate type constructors.\n   */\n  private typeCtors = new Set<ts.ClassDeclaration>();\n\n  /**\n   * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods\n   * or type-check blocks) that need to be eventually performed on that file.\n   */\n  private opMap = new Map<ts.SourceFile, Op[]>();\n\n  /**\n   * Record a template for the given component `node`, with a `SelectorMatcher` for directive\n   * matching.\n   *\n   * @param node class of the node being recorded.\n   * @param template AST nodes of the template being recorded.\n   * @param matcher `SelectorMatcher` which tracks directives that are in scope for this template.\n   */\n  addTemplate(\n      node: ts.ClassDeclaration, template: TmplAstNode[],\n      matcher: SelectorMatcher<TypeCheckableDirectiveMeta>): void {\n    // Only write TCBs for named classes.\n    if (node.name === undefined) {\n      throw new Error(`Assertion: class must be named`);\n    }\n\n    // Bind the template, which will:\n    //   - Extract the metadata needed to generate type check blocks.\n    //   - Perform directive matching, which informs the context which directives are used in the\n    //     template. This allows generation of type constructors for only those directives which\n    //     are actually used by the templates.\n    const binder = new R3TargetBinder(matcher);\n    const boundTarget = binder.bind({template});\n\n    // Get all of the directives used in the template and record type constructors for all of them.\n    boundTarget.getUsedDirectives().forEach(dir => {\n      const dirNode = dir.ref.node;\n      // Add a type constructor operation for the directive.\n      this.addTypeCtor(dirNode.getSourceFile(), dirNode, {\n        fnName: 'ngTypeCtor',\n        // The constructor should have a body if the directive comes from a .ts file, but not if it\n        // comes from a .d.ts file. .d.ts declarations don't have bodies.\n        body: !dirNode.getSourceFile().fileName.endsWith('.d.ts'),\n        fields: {\n          inputs: Object.keys(dir.inputs),\n          outputs: Object.keys(dir.outputs),\n          // TODO: support queries\n          queries: dir.queries,\n        },\n      });\n    });\n\n    // Record the type check block operation for the template itself.\n    this.addTypeCheckBlock(node.getSourceFile(), node, {\n      boundTarget,\n      fnName: `${node.name.text}_TypeCheckBlock`,\n    });\n  }\n\n  /**\n   * Record a type constructor for the given `node` with the given `ctorMetadata`.\n   */\n  addTypeCtor(sf: ts.SourceFile, node: ts.ClassDeclaration, ctorMeta: TypeCtorMetadata): void {\n    if (this.hasTypeCtor(node)) {\n      return;\n    }\n    // Lazily construct the operation map.\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf) !;\n\n    // Push a `TypeCtorOp` into the operation queue for the source file.\n    ops.push(new TypeCtorOp(node, ctorMeta));\n  }\n\n  /**\n   * Transform a `ts.SourceFile` into a version that includes type checking code.\n   *\n   * If this particular source file has no directives that require type constructors, or components\n   * that require type check blocks, then it will be returned directly. Otherwise, a new\n   * `ts.SourceFile` is parsed from modified text of the original. This is necessary to ensure the\n   * added code has correct positional information associated with it.\n   */\n  transform(sf: ts.SourceFile): ts.SourceFile {\n    // If there are no operations pending for this particular file, return it directly.\n    if (!this.opMap.has(sf)) {\n      return sf;\n    }\n\n    // Imports may need to be added to the file to support type-checking of directives used in the\n    // template within it.\n    const importManager = new ImportManager(false, '_i');\n\n    // Each Op has a splitPoint index into the text where it needs to be inserted. Split the\n    // original source text into chunks at these split points, where code will be inserted between\n    // the chunks.\n    const ops = this.opMap.get(sf) !.sort(orderOps);\n    const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));\n\n    // Use a `ts.Printer` to generate source code.\n    const printer = ts.createPrinter({omitTrailingSemicolon: true});\n\n    // Begin with the intial section of the code text.\n    let code = textParts[0];\n\n    // Process each operation and use the printer to generate source code for it, inserting it into\n    // the source code in between the original chunks.\n    ops.forEach((op, idx) => {\n      const text = op.execute(importManager, sf, printer);\n      code += text + textParts[idx + 1];\n    });\n\n    // Write out the imports that need to be added to the beginning of the file.\n    let imports = importManager.getAllImports(sf.fileName, null)\n                      .map(i => `import * as ${i.as} from '${i.name}';`)\n                      .join('\\n');\n    code = imports + '\\n' + code;\n\n    // Parse the new source file and return it.\n    return ts.createSourceFile(sf.fileName, code, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);\n  }\n\n  /**\n   * Whether the given `node` has a type constructor already.\n   */\n  private hasTypeCtor(node: ts.ClassDeclaration): boolean { return this.typeCtors.has(node); }\n\n  private addTypeCheckBlock(\n      sf: ts.SourceFile, node: ts.ClassDeclaration, tcbMeta: TypeCheckBlockMetadata): void {\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf) !;\n    ops.push(new TcbOp(node, tcbMeta));\n  }\n}\n\n/**\n * A code generation operation that needs to happen within a given source file.\n */\ninterface Op {\n  /**\n   * The node in the file which will have code generated for it.\n   */\n  readonly node: ts.ClassDeclaration;\n\n  /**\n   * Index into the source text where the code generated by the operation should be inserted.\n   */\n  readonly splitPoint: number;\n\n  /**\n   * Execute the operation and return the generated code as text.\n   */\n  execute(im: ImportManager, sf: ts.SourceFile, printer: ts.Printer): string;\n}\n\n/**\n * A type check block operation which produces type check code for a particular component.\n */\nclass TcbOp implements Op {\n  constructor(readonly node: ts.ClassDeclaration, readonly meta: TypeCheckBlockMetadata) {}\n\n  /**\n   * Type check blocks are inserted immediately after the end of the component class.\n   */\n  get splitPoint(): number { return this.node.end + 1; }\n\n  execute(im: ImportManager, sf: ts.SourceFile, printer: ts.Printer): string {\n    const tcb = generateTypeCheckBlock(this.node, this.meta, im);\n    return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);\n  }\n}\n\n/**\n * A type constructor operation which produces type constructor code for a particular directive.\n */\nclass TypeCtorOp implements Op {\n  constructor(readonly node: ts.ClassDeclaration, readonly meta: TypeCtorMetadata) {}\n\n  /**\n   * Type constructor operations are inserted immediately before the end of the directive class.\n   */\n  get splitPoint(): number { return this.node.end - 1; }\n\n  execute(im: ImportManager, sf: ts.SourceFile, printer: ts.Printer): string {\n    const tcb = generateTypeCtor(this.node, this.meta);\n    return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);\n  }\n}\n\n/**\n * Compare two operations and return their split point ordering.\n */\nfunction orderOps(op1: Op, op2: Op): number {\n  return op1.splitPoint - op2.splitPoint;\n}\n\n/**\n * Split a string into chunks at any number of split points.\n */\nfunction splitStringAtPoints(str: string, points: number[]): string[] {\n  const splits: string[] = [];\n  let start = 0;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    splits.push(str.substring(start, point));\n    start = point;\n  }\n  splits.push(str.substring(start));\n  return splits;\n}\n"]}