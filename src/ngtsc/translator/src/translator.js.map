{"version":3,"file":"translator.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/translator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeVisitor, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {relativePathBetween} from '../../util/src/path';\n\nexport class Context {\n  constructor(readonly isStatement: boolean) {}\n\n  get withExpressionMode(): Context { return this.isStatement ? new Context(false) : this; }\n\n  get withStatementMode(): Context { return this.isStatement ? new Context(true) : this; }\n}\n\nconst BINARY_OPERATORS = new Map<BinaryOperator, ts.BinaryOperator>([\n  [BinaryOperator.And, ts.SyntaxKind.AmpersandAmpersandToken],\n  [BinaryOperator.Bigger, ts.SyntaxKind.GreaterThanToken],\n  [BinaryOperator.BiggerEquals, ts.SyntaxKind.GreaterThanEqualsToken],\n  [BinaryOperator.BitwiseAnd, ts.SyntaxKind.AmpersandToken],\n  [BinaryOperator.Divide, ts.SyntaxKind.SlashToken],\n  [BinaryOperator.Equals, ts.SyntaxKind.EqualsEqualsToken],\n  [BinaryOperator.Identical, ts.SyntaxKind.EqualsEqualsEqualsToken],\n  [BinaryOperator.Lower, ts.SyntaxKind.LessThanToken],\n  [BinaryOperator.LowerEquals, ts.SyntaxKind.LessThanEqualsToken],\n  [BinaryOperator.Minus, ts.SyntaxKind.MinusToken],\n  [BinaryOperator.Modulo, ts.SyntaxKind.PercentToken],\n  [BinaryOperator.Multiply, ts.SyntaxKind.AsteriskToken],\n  [BinaryOperator.NotEquals, ts.SyntaxKind.ExclamationEqualsToken],\n  [BinaryOperator.NotIdentical, ts.SyntaxKind.ExclamationEqualsEqualsToken],\n  [BinaryOperator.Or, ts.SyntaxKind.BarBarToken],\n  [BinaryOperator.Plus, ts.SyntaxKind.PlusToken],\n]);\n\nconst CORE_SUPPORTED_SYMBOLS = new Set<string>([\n  'defineInjectable',\n  'defineInjector',\n  'ɵdefineNgModule',\n  'inject',\n  'ɵsetClassMetadata',\n  'ɵInjectableDef',\n  'ɵInjectorDef',\n  'ɵNgModuleDefWithMeta',\n  'ɵNgModuleFactory',\n]);\n\nexport class ImportManager {\n  private moduleToIndex = new Map<string, string>();\n  private nextIndex = 0;\n\n  constructor(protected isCore: boolean, private prefix = 'i') {}\n\n  generateNamedImport(moduleName: string, symbol: string): string|null {\n    if (!this.moduleToIndex.has(moduleName)) {\n      this.moduleToIndex.set(moduleName, `${this.prefix}${this.nextIndex++}`);\n    }\n    if (this.isCore && moduleName === '@angular/core' && !CORE_SUPPORTED_SYMBOLS.has(symbol)) {\n      throw new Error(`Importing unexpected symbol ${symbol} while compiling core`);\n    }\n    return this.moduleToIndex.get(moduleName) !;\n  }\n\n  getAllImports(contextPath: string, rewriteCoreImportsTo: ts.SourceFile|null):\n      {name: string, as: string}[] {\n    return Array.from(this.moduleToIndex.keys()).map(name => {\n      const as: string|null = this.moduleToIndex.get(name) !;\n      if (rewriteCoreImportsTo !== null && name === '@angular/core') {\n        const relative = relativePathBetween(contextPath, rewriteCoreImportsTo.fileName);\n        if (relative === null) {\n          throw new Error(\n              `Failed to rewrite import inside core: ${contextPath} -> ${rewriteCoreImportsTo.fileName}`);\n        }\n        name = relative;\n      }\n      return {name, as};\n    });\n  }\n}\n\nexport function translateExpression(expression: Expression, imports: ImportManager): ts.Expression {\n  return expression.visitExpression(new ExpressionTranslatorVisitor(imports), new Context(false));\n}\n\nexport function translateStatement(statement: Statement, imports: ImportManager): ts.Statement {\n  return statement.visitStatement(new ExpressionTranslatorVisitor(imports), new Context(true));\n}\n\nexport function translateType(type: Type, imports: ImportManager): string {\n  return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n}\n\nclass ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: Context): ts.VariableStatement {\n    const nodeFlags = stmt.hasModifier(StmtModifier.Final) ? ts.NodeFlags.Const : ts.NodeFlags.None;\n    return ts.createVariableStatement(\n        undefined, ts.createVariableDeclarationList(\n                       [ts.createVariableDeclaration(\n                           stmt.name, undefined, stmt.value &&\n                               stmt.value.visitExpression(this, context.withExpressionMode))],\n                       nodeFlags));\n  }\n\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: Context): ts.FunctionDeclaration {\n    return ts.createFunctionDeclaration(\n        undefined, undefined, undefined, stmt.name, undefined,\n        stmt.params.map(param => ts.createParameter(undefined, undefined, undefined, param.name)),\n        undefined, ts.createBlock(stmt.statements.map(\n                       child => child.visitStatement(this, context.withStatementMode))));\n  }\n\n  visitExpressionStmt(stmt: ExpressionStatement, context: Context): ts.ExpressionStatement {\n    return ts.createStatement(stmt.expr.visitExpression(this, context.withStatementMode));\n  }\n\n  visitReturnStmt(stmt: ReturnStatement, context: Context): ts.ReturnStatement {\n    return ts.createReturn(stmt.value.visitExpression(this, context.withExpressionMode));\n  }\n\n  visitDeclareClassStmt(stmt: ClassStmt, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitIfStmt(stmt: IfStmt, context: Context): ts.IfStatement {\n    return ts.createIf(\n        stmt.condition.visitExpression(this, context),\n        ts.createBlock(\n            stmt.trueCase.map(child => child.visitStatement(this, context.withStatementMode))),\n        stmt.falseCase.length > 0 ?\n            ts.createBlock(stmt.falseCase.map(\n                child => child.visitStatement(this, context.withStatementMode))) :\n            undefined);\n  }\n\n  visitTryCatchStmt(stmt: TryCatchStmt, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitThrowStmt(stmt: ThrowStmt, context: Context) { throw new Error('Method not implemented.'); }\n\n  visitCommentStmt(stmt: CommentStmt, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: Context): ts.NotEmittedStatement {\n    const commentStmt = ts.createNotEmittedStatement(ts.createLiteral(''));\n    const text = stmt.toString();\n    const kind = ts.SyntaxKind.MultiLineCommentTrivia;\n    ts.setSyntheticLeadingComments(commentStmt, [{kind, text, pos: -1, end: -1}]);\n    return commentStmt;\n  }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.Identifier {\n    return ts.createIdentifier(ast.name !);\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: Context): ts.Expression {\n    const result: ts.Expression = ts.createBinary(\n        ts.createIdentifier(expr.name), ts.SyntaxKind.EqualsToken,\n        expr.value.visitExpression(this, context));\n    return context.isStatement ? result : ts.createParen(result);\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: Context): ts.BinaryExpression {\n    return ts.createBinary(\n        ts.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name),\n        ts.SyntaxKind.EqualsToken, expr.value.visitExpression(this, context));\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): ts.CallExpression {\n    const target = ast.receiver.visitExpression(this, context);\n    return ts.createCall(\n        ast.name !== null ? ts.createPropertyAccess(target, ast.name) : target, undefined,\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): ts.CallExpression {\n    const expr = ts.createCall(\n        ast.fn.visitExpression(this, context), undefined,\n        ast.args.map(arg => arg.visitExpression(this, context)));\n    if (ast.pure) {\n      ts.addSyntheticLeadingComment(expr, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', false);\n    }\n    return expr;\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: Context): ts.NewExpression {\n    return ts.createNew(\n        ast.classExpr.visitExpression(this, context), undefined,\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: Context): ts.Expression {\n    if (ast.value === undefined) {\n      return ts.createIdentifier('undefined');\n    } else if (ast.value === null) {\n      return ts.createNull();\n    } else {\n      return ts.createLiteral(ast.value);\n    }\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: Context): ts.PropertyAccessExpression\n      |ts.Identifier {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol ${ast.value}`);\n    }\n    const importIdentifier = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    if (importIdentifier === null) {\n      return ts.createIdentifier(ast.value.name);\n    } else {\n      return ts.createPropertyAccess(\n          ts.createIdentifier(importIdentifier), ts.createIdentifier(ast.value.name));\n    }\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: Context): ts.ParenthesizedExpression {\n    return ts.createParen(ts.createConditional(\n        ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context),\n        ast.falseCase !.visitExpression(this, context)));\n  }\n\n  visitNotExpr(ast: NotExpr, context: Context): ts.PrefixUnaryExpression {\n    return ts.createPrefix(\n        ts.SyntaxKind.ExclamationToken, ast.condition.visitExpression(this, context));\n  }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: Context): ts.NonNullExpression {\n    return ts.createNonNullExpression(ast.condition.visitExpression(this, context));\n  }\n\n  visitCastExpr(ast: CastExpr, context: Context): ts.Expression {\n    return ast.value.visitExpression(this, context);\n  }\n\n  visitFunctionExpr(ast: FunctionExpr, context: Context): ts.FunctionExpression {\n    return ts.createFunctionExpression(\n        undefined, undefined, ast.name || undefined, undefined,\n        ast.params.map(\n            param => ts.createParameter(\n                undefined, undefined, undefined, param.name, undefined, undefined, undefined)),\n        undefined, ts.createBlock(ast.statements.map(stmt => stmt.visitStatement(this, context))));\n  }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context): ts.Expression {\n    if (!BINARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown binary operator: ${BinaryOperator[ast.operator]}`);\n    }\n    const binEx = ts.createBinary(\n        ast.lhs.visitExpression(this, context), BINARY_OPERATORS.get(ast.operator) !,\n        ast.rhs.visitExpression(this, context));\n    return ast.parens ? ts.createParen(binEx) : binEx;\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: Context): ts.PropertyAccessExpression {\n    return ts.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n  }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: Context): ts.ElementAccessExpression {\n    return ts.createElementAccess(\n        ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n  }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.ArrayLiteralExpression {\n    return ts.createArrayLiteral(ast.entries.map(expr => expr.visitExpression(this, context)));\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): ts.ObjectLiteralExpression {\n    const entries = ast.entries.map(\n        entry => ts.createPropertyAssignment(\n            entry.quoted ? ts.createLiteral(entry.key) : ts.createIdentifier(entry.key),\n            entry.value.visitExpression(this, context)));\n    return ts.createObjectLiteral(entries);\n  }\n\n  visitCommaExpr(ast: CommaExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): any { return ast.node; }\n\n  visitTypeofExpr(ast: TypeofExpr, context: Context): ts.TypeOfExpression {\n    return ts.createTypeOf(ast.expr.visitExpression(this, context));\n  }\n}\n\nexport class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitBuiltinType(type: BuiltinType, context: Context): string {\n    switch (type.name) {\n      case BuiltinTypeName.Bool:\n        return 'boolean';\n      case BuiltinTypeName.Dynamic:\n        return 'any';\n      case BuiltinTypeName.Int:\n      case BuiltinTypeName.Number:\n        return 'number';\n      case BuiltinTypeName.String:\n        return 'string';\n      case BuiltinTypeName.None:\n        return 'never';\n      default:\n        throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);\n    }\n  }\n\n  visitExpressionType(type: ExpressionType, context: Context): string {\n    const exprStr = type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      const typeSegments = type.typeParams.map(param => param.visitType(this, context));\n      return `${exprStr}<${typeSegments.join(', ')}>`;\n    } else {\n      return exprStr;\n    }\n  }\n\n  visitArrayType(type: ArrayType, context: Context): string {\n    return `Array<${type.visitType(this, context)}>`;\n  }\n\n  visitMapType(type: MapType, context: Context): string {\n    if (type.valueType !== null) {\n      return `{[key: string]: ${type.valueType.visitType(this, context)}}`;\n    } else {\n      return '{[key: string]: any}';\n    }\n  }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: Context): string {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ast.name;\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: Context): string {\n    if (typeof ast.value === 'string') {\n      const escaped = ast.value.replace(/\\'/g, '\\\\\\'');\n      return `'${escaped}'`;\n    } else {\n      return `${ast.value}`;\n    }\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: Context): string {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const moduleSymbol = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    const base = `${moduleSymbol}.${ast.value.name}`;\n    if (ast.typeParams !== null) {\n      const generics = ast.typeParams.map(type => type.visitType(this, context)).join(', ');\n      return `${base}<${generics}>`;\n    } else {\n      return base;\n    }\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitNotExpr(ast: NotExpr, context: Context) { throw new Error('Method not implemented.'); }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitCastExpr(ast: CastExpr, context: Context) { throw new Error('Method not implemented.'); }\n\n  visitFunctionExpr(ast: FunctionExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): string {\n    const values = ast.entries.map(expr => expr.visitExpression(this, context));\n    return `[${values.join(', ')}]`;\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context) {\n    const entries = ast.entries.map(entry => {\n      const {key, quoted} = entry;\n      const value = entry.value.visitExpression(this, context);\n      if (quoted) {\n        return `'${key}': ${value}`;\n      } else {\n        return `${key}: ${value}`;\n      }\n    });\n    return `{${entries.join(', ')}}`;\n  }\n\n  visitCommaExpr(ast: CommaExpr, context: Context) { throw new Error('Method not implemented.'); }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context) {\n    const node: ts.Node = ast.node;\n    if (ts.isIdentifier(node)) {\n      return node.text;\n    } else {\n      throw new Error(\n          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n    }\n  }\n\n  visitTypeofExpr(ast: TypeofExpr, context: Context): string {\n    return `typeof ${ast.expr.visitExpression(this, context)}`;\n  }\n}\n"]}