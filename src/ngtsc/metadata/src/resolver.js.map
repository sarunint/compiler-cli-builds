{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * resolver.ts implements partial computation of expressions, resolving expressions to static\n * values where possible and returning a `DynamicValue` signal when not.\n */\n\nimport {Expression, ExternalExpr, ExternalReference, WrappedNodeExpr} from '@angular/compiler';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {ClassMemberKind, ReflectionHost} from '../../host';\n\nconst TS_DTS_JS_EXTENSION = /(\\.d)?\\.ts|\\.js$/;\n\n/**\n * Represents a value which cannot be determined statically.\n *\n * Use `isDynamicValue` to determine whether a `ResolvedValue` is a `DynamicValue`.\n */\nexport class DynamicValue {\n  /**\n   * This is needed so the \"is DynamicValue\" assertion of `isDynamicValue` actually has meaning.\n   *\n   * Otherwise, \"is DynamicValue\" is akin to \"is {}\" which doesn't trigger narrowing.\n   */\n  private _isDynamic = true;\n}\n\n/**\n * An internal flyweight for `DynamicValue`. Eventually the dynamic value will carry information\n * on the location of the node that could not be statically computed.\n */\nconst DYNAMIC_VALUE: DynamicValue = new DynamicValue();\n\n/**\n * Used to test whether a `ResolvedValue` is a `DynamicValue`.\n */\nexport function isDynamicValue(value: any): value is DynamicValue {\n  return value === DYNAMIC_VALUE;\n}\n\n/**\n * A value resulting from static resolution.\n *\n * This could be a primitive, collection type, reference to a `ts.Node` that declares a\n * non-primitive value, or a special `DynamicValue` type which indicates the value was not\n * available statically.\n */\nexport type ResolvedValue = number | boolean | string | null | undefined | Reference | EnumValue |\n    ResolvedValueArray | ResolvedValueMap | DynamicValue;\n\n/**\n * An array of `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueArray`\n * ->\n * `ResolvedValue`.\n */\nexport interface ResolvedValueArray extends Array<ResolvedValue> {}\n\n/**\n * A map of strings to `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueMap` ->\n * `ResolvedValue`.\n */ export interface ResolvedValueMap extends Map<string, ResolvedValue> {}\n\n/**\n * A value member of an enumeration.\n *\n * Contains a `Reference` to the enumeration itself, and the name of the referenced member.\n */\nexport class EnumValue {\n  constructor(readonly enumRef: Reference<ts.EnumDeclaration>, readonly name: string) {}\n}\n\n/**\n * Tracks the scope of a function body, which includes `ResolvedValue`s for the parameters of that\n * body.\n */\ntype Scope = Map<ts.ParameterDeclaration, ResolvedValue>;\n\nexport enum ImportMode {\n  UseExistingImport,\n  ForceNewImport,\n}\n\n/**\n * A reference to a `ts.Node`.\n *\n * For example, if an expression evaluates to a function or class definition, it will be returned\n * as a `Reference` (assuming references are allowed in evaluation).\n */\nexport abstract class Reference<T extends ts.Node = ts.Node> {\n  constructor(readonly node: T) {}\n\n  /**\n   * Whether an `Expression` can be generated which references the node.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly expressable !: boolean;\n\n  /**\n   * Generate an `Expression` representing this type, in the context of the given SourceFile.\n   *\n   * This could be a local variable reference, if the symbol is imported, or it could be a new\n   * import if needed.\n   */\n  abstract toExpression(context: ts.SourceFile, importMode?: ImportMode): Expression|null;\n\n  abstract addIdentifier(identifier: ts.Identifier): void;\n}\n\n/**\n * A reference to a node only, without any ability to get an `Expression` representing that node.\n *\n * This is used for returning references to things like method declarations, which are not directly\n * referenceable.\n */\nexport class NodeReference<T extends ts.Node = ts.Node> extends Reference<T> {\n  constructor(node: T, readonly moduleName: string|null) { super(node); }\n\n  toExpression(context: ts.SourceFile): null { return null; }\n\n  addIdentifier(identifier: ts.Identifier): void {}\n}\n\n/**\n * A reference to a node which has a `ts.Identifier` and can be resolved to an `Expression`.\n *\n * Imports generated by `ResolvedReference`s are always relative.\n */\nexport class ResolvedReference<T extends ts.Node = ts.Node> extends Reference<T> {\n  protected identifiers: ts.Identifier[] = [];\n\n  constructor(node: T, protected primaryIdentifier: ts.Identifier) { super(node); }\n\n  readonly expressable = true;\n\n  toExpression(context: ts.SourceFile, importMode: ImportMode = ImportMode.UseExistingImport):\n      Expression {\n    const localIdentifier =\n        pickIdentifier(context, this.primaryIdentifier, this.identifiers, importMode);\n    if (localIdentifier !== null) {\n      return new WrappedNodeExpr(localIdentifier);\n    } else {\n      // Relative import from context -> this.node.getSourceFile().\n      // TODO(alxhub): investigate the impact of multiple source roots here.\n      // TODO(alxhub): investigate the need to map such paths via the Host for proper g3 support.\n      let relative =\n          path.posix.relative(path.dirname(context.fileName), this.node.getSourceFile().fileName)\n              .replace(TS_DTS_JS_EXTENSION, '');\n\n      // path.relative() does not include the leading './'.\n      if (!relative.startsWith('.')) {\n        relative = `./${relative}`;\n      }\n\n      // path.relative() returns the empty string (converted to './' above) if the two paths are the\n      // same.\n      if (relative === './') {\n        // Same file after all.\n        return new WrappedNodeExpr(this.primaryIdentifier);\n      } else {\n        return new ExternalExpr(new ExternalReference(relative, this.primaryIdentifier.text));\n      }\n    }\n  }\n\n  addIdentifier(identifier: ts.Identifier): void { this.identifiers.push(identifier); }\n}\n\n/**\n * A reference to a node which has a `ts.Identifer` and an expected absolute module name.\n *\n * An `AbsoluteReference` can be resolved to an `Expression`, and if that expression is an import\n * the module specifier will be an absolute module name, not a relative path.\n */\nexport class AbsoluteReference<T extends ts.Node> extends Reference<T> {\n  private identifiers: ts.Identifier[] = [];\n  constructor(\n      node: T, private primaryIdentifier: ts.Identifier, readonly moduleName: string,\n      readonly symbolName: string) {\n    super(node);\n  }\n\n  readonly expressable = true;\n\n  toExpression(context: ts.SourceFile, importMode: ImportMode = ImportMode.UseExistingImport):\n      Expression {\n    const localIdentifier =\n        pickIdentifier(context, this.primaryIdentifier, this.identifiers, importMode);\n    if (localIdentifier !== null) {\n      return new WrappedNodeExpr(localIdentifier);\n    } else {\n      return new ExternalExpr(new ExternalReference(this.moduleName, this.symbolName));\n    }\n  }\n\n  addIdentifier(identifier: ts.Identifier): void { this.identifiers.push(identifier); }\n}\n\nfunction pickIdentifier(\n    context: ts.SourceFile, primary: ts.Identifier, secondaries: ts.Identifier[],\n    mode: ImportMode): ts.Identifier|null {\n  context = ts.getOriginalNode(context) as ts.SourceFile;\n\n  if (ts.getOriginalNode(primary).getSourceFile() === context) {\n    return primary;\n  } else if (mode === ImportMode.UseExistingImport) {\n    return secondaries.find(id => ts.getOriginalNode(id).getSourceFile() === context) || null;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Statically resolve the given `ts.Expression` into a `ResolvedValue`.\n *\n * @param node the expression to statically resolve if possible\n * @param checker a `ts.TypeChecker` used to understand the expression\n * @param foreignFunctionResolver a function which will be used whenever a \"foreign function\" is\n * encountered. A foreign function is a function which has no body - usually the result of calling\n * a function declared in another library's .d.ts file. In these cases, the foreignFunctionResolver\n * will be called with the function's declaration, and can optionally return a `ts.Expression`\n * (possibly extracted from the foreign function's type signature) which will be used as the result\n * of the call.\n * @returns a `ResolvedValue` representing the resolved value\n */\nexport function staticallyResolve(\n    node: ts.Expression, host: ReflectionHost, checker: ts.TypeChecker,\n    foreignFunctionResolver?:\n        (node: Reference<ts.FunctionDeclaration|ts.MethodDeclaration>, args: ts.Expression[]) =>\n            ts.Expression | null): ResolvedValue {\n  return new StaticInterpreter(host, checker).visit(node, {\n    absoluteModuleName: null,\n    scope: new Map<ts.ParameterDeclaration, ResolvedValue>(), foreignFunctionResolver,\n  });\n}\n\ninterface BinaryOperatorDef {\n  literal: boolean;\n  op: (a: any, b: any) => ResolvedValue;\n}\n\nfunction literalBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: true};\n}\n\nfunction referenceBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: false};\n}\n\nconst BINARY_OPERATORS = new Map<ts.SyntaxKind, BinaryOperatorDef>([\n  [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\n\nconst UNARY_OPERATORS = new Map<ts.SyntaxKind, (a: any) => any>([\n  [ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a],\n  [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]\n]);\n\ninterface Context {\n  absoluteModuleName: string|null;\n  scope: Scope;\n  foreignFunctionResolver?\n      (ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n       args: ReadonlyArray<ts.Expression>): ts.Expression|null;\n}\n\nclass StaticInterpreter {\n  constructor(private host: ReflectionHost, private checker: ts.TypeChecker) {}\n\n  visit(node: ts.Expression, context: Context): ResolvedValue {\n    return this.visitExpression(node, context);\n  }\n\n  private visitExpression(node: ts.Expression, context: Context): ResolvedValue {\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts.isTemplateExpression(node)) {\n      return this.visitTemplateExpression(node, context);\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      return this.visitObjectLiteralExpression(node, context);\n    } else if (ts.isIdentifier(node)) {\n      return this.visitIdentifier(node, context);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      return this.visitPropertyAccessExpression(node, context);\n    } else if (ts.isCallExpression(node)) {\n      return this.visitCallExpression(node, context);\n    } else if (ts.isConditionalExpression(node)) {\n      return this.visitConditionalExpression(node, context);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      return this.visitPrefixUnaryExpression(node, context);\n    } else if (ts.isBinaryExpression(node)) {\n      return this.visitBinaryExpression(node, context);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      return this.visitArrayLiteralExpression(node, context);\n    } else if (ts.isParenthesizedExpression(node)) {\n      return this.visitParenthesizedExpression(node, context);\n    } else if (ts.isElementAccessExpression(node)) {\n      return this.visitElementAccessExpression(node, context);\n    } else if (ts.isAsExpression(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isNonNullExpression(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (isPossibleClassDeclaration(node) && this.host.isClass(node)) {\n      return this.visitDeclaration(node, context);\n    } else {\n      return DYNAMIC_VALUE;\n    }\n  }\n\n  private visitArrayLiteralExpression(node: ts.ArrayLiteralExpression, context: Context):\n      ResolvedValue {\n    const array: ResolvedValueArray = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts.isSpreadElement(element)) {\n        const spread = this.visitExpression(element.expression, context);\n        if (isDynamicValue(spread)) {\n          return DYNAMIC_VALUE;\n        }\n        if (!Array.isArray(spread)) {\n          throw new Error(`Unexpected value in spread expression: ${spread}`);\n        }\n\n        array.push(...spread);\n      } else {\n        const result = this.visitExpression(element, context);\n        if (isDynamicValue(result)) {\n          return DYNAMIC_VALUE;\n        }\n\n        array.push(result);\n      }\n    }\n    return array;\n  }\n\n  private visitObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: Context):\n      ResolvedValue {\n    const map: ResolvedValueMap = new Map<string, ResolvedValue>();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n\n        // Check whether the name can be determined statically.\n        if (name === undefined) {\n          return DYNAMIC_VALUE;\n        }\n\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          return DYNAMIC_VALUE;\n        }\n        map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (isDynamicValue(spread)) {\n          return DYNAMIC_VALUE;\n        }\n        if (!(spread instanceof Map)) {\n          throw new Error(`Unexpected value in spread assignment: ${spread}`);\n        }\n        spread.forEach((value, key) => map.set(key, value));\n      } else {\n        return DYNAMIC_VALUE;\n      }\n    }\n    return map;\n  }\n\n  private visitTemplateExpression(node: ts.TemplateExpression, context: Context): ResolvedValue {\n    const pieces: string[] = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = this.visit(span.expression, context);\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' ||\n          value == null) {\n        pieces.push(`${value}`);\n      } else {\n        return DYNAMIC_VALUE;\n      }\n      pieces.push(span.literal.text);\n    }\n    return pieces.join('');\n  }\n\n  private visitIdentifier(node: ts.Identifier, context: Context): ResolvedValue {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      return DYNAMIC_VALUE;\n    }\n    const result = this.visitDeclaration(\n        decl.node, {...context, absoluteModuleName: decl.viaModule || context.absoluteModuleName});\n    if (result instanceof Reference) {\n      result.addIdentifier(node);\n    }\n    return result;\n  }\n\n  private visitDeclaration(node: ts.Declaration, context: Context): ResolvedValue {\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node) !;\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n\n  private visitVariableDeclaration(node: ts.VariableDeclaration, context: Context): ResolvedValue {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      return this.getReference(node, context);\n    } else {\n      return undefined;\n    }\n  }\n\n  private visitEnumDeclaration(node: ts.EnumDeclaration, context: Context): ResolvedValue {\n    const enumRef = this.getReference(node, context) as Reference<ts.EnumDeclaration>;\n    const map = new Map<string, EnumValue>();\n    node.members.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== undefined) {\n        map.set(name, new EnumValue(enumRef, name));\n      }\n    });\n    return map;\n  }\n\n  private visitElementAccessExpression(node: ts.ElementAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (node.argumentExpression === undefined) {\n      throw new Error(`Expected argument in ElementAccessExpression`);\n    }\n    if (isDynamicValue(lhs)) {\n      return DYNAMIC_VALUE;\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (isDynamicValue(rhs)) {\n      return DYNAMIC_VALUE;\n    }\n    if (typeof rhs !== 'string' && typeof rhs !== 'number') {\n      throw new Error(\n          `ElementAccessExpression index should be string or number, got ${typeof rhs}: ${rhs}`);\n    }\n\n    return this.accessHelper(lhs, rhs, context);\n  }\n\n  private visitPropertyAccessExpression(node: ts.PropertyAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    // TODO: handle reference to class declaration.\n    if (isDynamicValue(lhs)) {\n      return DYNAMIC_VALUE;\n    }\n\n    return this.accessHelper(lhs, rhs, context);\n  }\n\n  private visitSourceFile(node: ts.SourceFile, context: Context): ResolvedValue {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DYNAMIC_VALUE;\n    }\n    const map = new Map<string, ResolvedValue>();\n    declarations.forEach((decl, name) => {\n      const value = this.visitDeclaration(decl.node, {\n        ...context,\n        absoluteModuleName: decl.viaModule || context.absoluteModuleName,\n      });\n      map.set(name, value);\n    });\n    return map;\n  }\n\n  private accessHelper(lhs: ResolvedValue, rhs: string|number, context: Context): ResolvedValue {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex) !;\n      } else {\n        throw new Error(`Invalid map access: [${Array.from(lhs.keys())}] dot ${rhs}`);\n      }\n    } else if (Array.isArray(lhs)) {\n      if (rhs === 'length') {\n        return lhs.length;\n      }\n      if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {\n        return DYNAMIC_VALUE;\n      }\n      if (rhs < 0 || rhs >= lhs.length) {\n        throw new Error(`Index out of bounds: ${rhs} vs ${lhs.length}`);\n      }\n      return lhs[rhs];\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (isPossibleClassDeclaration(ref) && this.host.isClass(ref)) {\n        let absoluteModuleName = context.absoluteModuleName;\n        if (lhs instanceof NodeReference || lhs instanceof AbsoluteReference) {\n          absoluteModuleName = lhs.moduleName || absoluteModuleName;\n        }\n        let value: ResolvedValue = undefined;\n        const member = this.host.getMembersOfClass(ref).find(\n            member => member.isStatic && member.name === strIndex);\n        if (member !== undefined) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new NodeReference(member.implementation, absoluteModuleName);\n          } else if (member.node) {\n            value = new NodeReference(member.node, absoluteModuleName);\n          }\n        }\n        return value;\n      }\n    }\n    throw new Error(`Invalid dot property access: ${lhs} dot ${rhs}`);\n  }\n\n  private visitCallExpression(node: ts.CallExpression, context: Context): ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (!(lhs instanceof Reference)) {\n      throw new Error(`attempting to call something that is not a function: ${lhs}`);\n    } else if (!isFunctionOrMethodReference(lhs)) {\n      throw new Error(\n          `calling something that is not a function declaration? ${ts.SyntaxKind[lhs.node.kind]} (${node.getText()})`);\n    }\n\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n\n    // If the function is foreign (declared through a d.ts file), attempt to resolve it with the\n    // foreignFunctionResolver, if one is specified.\n    if (fn.body === null) {\n      let expr: ts.Expression|null = null;\n      if (context.foreignFunctionResolver) {\n        expr = context.foreignFunctionResolver(lhs, node.arguments);\n      }\n      if (expr === null) {\n        throw new Error(\n            `could not resolve foreign function declaration: ${node.getSourceFile().fileName} ${(lhs.node.name as ts.Identifier).text}`);\n      }\n\n      // If the function is declared in a different file, resolve the foreign function expression\n      // using the absolute module name of that file (if any).\n      let absoluteModuleName: string|null = context.absoluteModuleName;\n      if (lhs instanceof NodeReference || lhs instanceof AbsoluteReference) {\n        absoluteModuleName = lhs.moduleName || absoluteModuleName;\n      }\n\n      return this.visitExpression(expr, {...context, absoluteModuleName});\n    }\n\n    const body = fn.body;\n    if (body.length !== 1 || !ts.isReturnStatement(body[0])) {\n      throw new Error('Function body must have a single return statement only.');\n    }\n    const ret = body[0] as ts.ReturnStatement;\n\n    const newScope: Scope = new Map<ts.ParameterDeclaration, ResolvedValue>();\n    fn.parameters.forEach((param, index) => {\n      let value: ResolvedValue = undefined;\n      if (index < node.arguments.length) {\n        const arg = node.arguments[index];\n        value = this.visitExpression(arg, context);\n      }\n      if (value === undefined && param.initializer !== null) {\n        value = this.visitExpression(param.initializer, context);\n      }\n      newScope.set(param.node, value);\n    });\n\n    return ret.expression !== undefined ?\n        this.visitExpression(ret.expression, {...context, scope: newScope}) :\n        undefined;\n  }\n\n  private visitConditionalExpression(node: ts.ConditionalExpression, context: Context):\n      ResolvedValue {\n    const condition = this.visitExpression(node.condition, context);\n    if (isDynamicValue(condition)) {\n      return condition;\n    }\n\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n\n  private visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression, context: Context):\n      ResolvedValue {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      throw new Error(`Unsupported prefix unary operator: ${ts.SyntaxKind[operatorKind]}`);\n    }\n\n    const op = UNARY_OPERATORS.get(operatorKind) !;\n    const value = this.visitExpression(node.operand, context);\n    return isDynamicValue(value) ? DYNAMIC_VALUE : op(value);\n  }\n\n  private visitBinaryExpression(node: ts.BinaryExpression, context: Context): ResolvedValue {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      throw new Error(`Unsupported binary operator: ${ts.SyntaxKind[tokenKind]}`);\n    }\n\n    const opRecord = BINARY_OPERATORS.get(tokenKind) !;\n    let lhs: ResolvedValue, rhs: ResolvedValue;\n    if (opRecord.literal) {\n      lhs = literal(this.visitExpression(node.left, context));\n      rhs = literal(this.visitExpression(node.right, context));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n\n    return isDynamicValue(lhs) || isDynamicValue(rhs) ? DYNAMIC_VALUE : opRecord.op(lhs, rhs);\n  }\n\n  private visitParenthesizedExpression(node: ts.ParenthesizedExpression, context: Context):\n      ResolvedValue {\n    return this.visitExpression(node.expression, context);\n  }\n\n  private stringNameFromPropertyName(node: ts.PropertyName, context: Context): string|undefined {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else {  // ts.ComputedPropertyName\n      const literal = this.visitExpression(node.expression, context);\n      return typeof literal === 'string' ? literal : undefined;\n    }\n  }\n\n  private getReference(node: ts.Declaration, context: Context): Reference {\n    const id = identifierOfDeclaration(node);\n    if (id === undefined) {\n      throw new Error(`Don't know how to refer to ${ts.SyntaxKind[node.kind]}`);\n    }\n    if (context.absoluteModuleName !== null) {\n      // TODO(alxhub): investigate whether this can get symbol names wrong in the event of\n      // re-exports under different names.\n      return new AbsoluteReference(node, id, context.absoluteModuleName, id.text);\n    } else {\n      return new ResolvedReference(node, id);\n    }\n  }\n}\n\nfunction isFunctionOrMethodReference(ref: Reference<ts.Node>):\n    ref is Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression> {\n  return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) ||\n      ts.isFunctionExpression(ref.node);\n}\n\nfunction literal(value: ResolvedValue): any {\n  if (value === null || value === undefined || typeof value === 'string' ||\n      typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  if (isDynamicValue(value)) {\n    return DYNAMIC_VALUE;\n  }\n  throw new Error(`Value ${value} is not literal and cannot be used in this context.`);\n}\n\nfunction identifierOfDeclaration(decl: ts.Declaration): ts.Identifier|undefined {\n  if (ts.isClassDeclaration(decl)) {\n    return decl.name;\n  } else if (ts.isEnumDeclaration(decl)) {\n    return decl.name;\n  } else if (ts.isFunctionDeclaration(decl)) {\n    return decl.name;\n  } else if (ts.isVariableDeclaration(decl) && ts.isIdentifier(decl.name)) {\n    return decl.name;\n  } else if (ts.isShorthandPropertyAssignment(decl)) {\n    return decl.name;\n  } else {\n    return undefined;\n  }\n}\n\nfunction isPossibleClassDeclaration(node: ts.Node): node is ts.Declaration {\n  return ts.isClassDeclaration(node) || ts.isVariableDeclaration(node);\n}\n\nfunction isVariableDeclarationDeclared(node: ts.VariableDeclaration): boolean {\n  if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  return varStmt.modifiers !== undefined &&\n      varStmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.DeclareKeyword);\n}\n"]}