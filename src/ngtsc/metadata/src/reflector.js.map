{"version":3,"file":"reflector.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/reflector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ClassMember, ClassMemberKind, CtorParameter, Declaration, Decorator, FunctionDefinition, Import, ReflectionHost} from '../../host';\n\n/**\n * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\n */\n\nexport class TypeScriptReflectionHost implements ReflectionHost {\n  constructor(protected checker: ts.TypeChecker) {}\n\n  getDecoratorsOfDeclaration(declaration: ts.Declaration): Decorator[]|null {\n    if (declaration.decorators === undefined || declaration.decorators.length === 0) {\n      return null;\n    }\n    return declaration.decorators.map(decorator => this._reflectDecorator(decorator))\n        .filter((dec): dec is Decorator => dec !== null);\n  }\n\n  getMembersOfClass(declaration: ts.Declaration): ClassMember[] {\n    const clazz = castDeclarationToClassOrDie(declaration);\n    return clazz.members.map(member => this._reflectMember(member))\n        .filter((member): member is ClassMember => member !== null);\n  }\n\n  getConstructorParameters(declaration: ts.Declaration): CtorParameter[]|null {\n    const clazz = castDeclarationToClassOrDie(declaration);\n\n    // First, find the constructor.\n    const ctor = clazz.members.find(ts.isConstructorDeclaration);\n    if (ctor === undefined) {\n      return null;\n    }\n\n    return ctor.parameters.map(node => {\n      // The name of the parameter is easy.\n      const name = parameterName(node.name);\n\n      const decorators = this.getDecoratorsOfDeclaration(node);\n\n      // It may or may not be possible to write an expression that refers to the value side of the\n      // type named for the parameter.\n      let typeValueExpr: ts.Expression|null = null;\n\n      // It's not possible to get a value expression if the parameter doesn't even have a type.\n      if (node.type !== undefined) {\n        // It's only valid to convert a type reference to a value reference if the type actually has\n        // a\n        // value declaration associated with it.\n        const type = this.checker.getTypeFromTypeNode(node.type);\n        if (type.symbol !== undefined && type.symbol.valueDeclaration !== undefined) {\n          // The type points to a valid value declaration. Rewrite the TypeReference into an\n          // Expression\n          // which references the value pointed to by the TypeReference, if possible.\n          typeValueExpr = typeNodeToValueExpr(node.type);\n        }\n      }\n\n      return {\n        name,\n        nameNode: node.name,\n        type: typeValueExpr, decorators,\n      };\n    });\n  }\n\n  getImportOfIdentifier(id: ts.Identifier): Import|null {\n    const symbol = this.checker.getSymbolAtLocation(id);\n\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      return null;\n    }\n\n    // Ignore decorators that are defined locally (not imported).\n    const decl: ts.Declaration = symbol.declarations[0];\n    if (!ts.isImportSpecifier(decl)) {\n      return null;\n    }\n\n    // Walk back from the specifier to find the declaration, which carries the module specifier.\n    const importDecl = decl.parent !.parent !.parent !;\n\n    // The module specifier is guaranteed to be a string literal, so this should always pass.\n    if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n      // Not allowed to happen in TypeScript ASTs.\n      return null;\n    }\n\n    // Read the module specifier.\n    const from = importDecl.moduleSpecifier.text;\n\n    // Compute the name by which the decorator was exported, not imported.\n    const name = (decl.propertyName !== undefined ? decl.propertyName : decl.name).text;\n\n    return {from, name};\n  }\n\n  getExportsOfModule(node: ts.Node): Map<string, Declaration>|null {\n    // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.\n    if (!ts.isSourceFile(node)) {\n      throw new Error(`getDeclarationsOfModule() called on non-SourceFile in TS code`);\n    }\n    const map = new Map<string, Declaration>();\n\n    // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported\n    // Symbols.\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return null;\n    }\n    this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {\n      // Map each exported Symbol to a Declaration and add it to the map.\n      const decl = this.getDeclarationOfSymbol(exportSymbol);\n      if (decl !== null) {\n        map.set(exportSymbol.name, decl);\n      }\n    });\n    return map;\n  }\n\n  isClass(node: ts.Node): boolean {\n    // In TypeScript code, classes are ts.ClassDeclarations.\n    return ts.isClassDeclaration(node);\n  }\n\n  hasBaseClass(node: ts.Declaration): boolean {\n    return ts.isClassDeclaration(node) && node.heritageClauses !== undefined &&\n        node.heritageClauses.some(clause => clause.token === ts.SyntaxKind.ExtendsKeyword);\n  }\n\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    // Resolve the identifier to a Symbol, and return the declaration of that.\n    let symbol: ts.Symbol|undefined = this.checker.getSymbolAtLocation(id);\n    if (symbol === undefined) {\n      return null;\n    }\n    return this.getDeclarationOfSymbol(symbol);\n  }\n\n  getDefinitionOfFunction<T extends ts.FunctionDeclaration|ts.MethodDeclaration|\n                          ts.FunctionExpression>(node: T): FunctionDefinition<T> {\n    return {\n      node,\n      body: node.body !== undefined ? Array.from(node.body.statements) : null,\n      parameters: node.parameters.map(param => {\n        const name = parameterName(param.name);\n        const initializer = param.initializer || null;\n        return {name, node: param, initializer};\n      }),\n    };\n  }\n\n  getGenericArityOfClass(clazz: ts.Declaration): number|null {\n    if (!ts.isClassDeclaration(clazz)) {\n      return null;\n    }\n    return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;\n  }\n\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null {\n    return declaration.initializer || null;\n  }\n\n  getDtsDeclarationOfClass(_: ts.Declaration): ts.ClassDeclaration|null { return null; }\n\n  /**\n   * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.\n   *\n   * @internal\n   */\n  protected getDeclarationOfSymbol(symbol: ts.Symbol): Declaration|null {\n    let viaModule: string|null = null;\n    // Look through the Symbol's immediate declarations, and see if any of them are import-type\n    // statements.\n    if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      for (let i = 0; i < symbol.declarations.length; i++) {\n        const decl = symbol.declarations[i];\n        if (ts.isImportSpecifier(decl) && decl.parent !== undefined &&\n            decl.parent.parent !== undefined && decl.parent.parent.parent !== undefined) {\n          // Find the ImportDeclaration that imported this Symbol.\n          const importDecl = decl.parent.parent.parent;\n          // The moduleSpecifier should always be a string.\n          if (ts.isStringLiteral(importDecl.moduleSpecifier)) {\n            // Check if the moduleSpecifier is absolute. If it is, this symbol comes from an\n            // external module, and the import path becomes the viaModule.\n            const moduleSpecifier = importDecl.moduleSpecifier.text;\n            if (!moduleSpecifier.startsWith('.')) {\n              viaModule = moduleSpecifier;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Now, resolve the Symbol to its declaration by following any and all aliases.\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n\n    // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations\n    // are given precedence over type declarations.\n    if (symbol.valueDeclaration !== undefined) {\n      return {\n        node: symbol.valueDeclaration,\n        viaModule,\n      };\n    } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      return {\n        node: symbol.declarations[0],\n        viaModule,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  private _reflectDecorator(node: ts.Decorator): Decorator|null {\n    // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The\n    // expression may contain a call to a function which returns the decorator function, in which\n    // case we want to return the arguments.\n    let decoratorExpr: ts.Expression = node.expression;\n    let args: ts.Expression[]|null = null;\n\n    // Check for call expressions.\n    if (ts.isCallExpression(decoratorExpr)) {\n      args = Array.from(decoratorExpr.arguments);\n      decoratorExpr = decoratorExpr.expression;\n    }\n\n    // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is\n    // wrong and the decorator can't be resolved statically.\n    if (!ts.isIdentifier(decoratorExpr)) {\n      return null;\n    }\n\n    const importDecl = this.getImportOfIdentifier(decoratorExpr);\n\n    return {\n      name: decoratorExpr.text,\n      identifier: decoratorExpr,\n      import: importDecl, node, args,\n    };\n  }\n\n  private _reflectMember(node: ts.ClassElement): ClassMember|null {\n    let kind: ClassMemberKind|null = null;\n    let value: ts.Expression|null = null;\n    let name: string|null = null;\n    let nameNode: ts.Identifier|null = null;\n\n    if (ts.isPropertyDeclaration(node)) {\n      kind = ClassMemberKind.Property;\n      value = node.initializer || null;\n    } else if (ts.isGetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Getter;\n    } else if (ts.isSetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Setter;\n    } else if (ts.isMethodDeclaration(node)) {\n      kind = ClassMemberKind.Method;\n    } else if (ts.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n    } else {\n      return null;\n    }\n\n    if (ts.isConstructorDeclaration(node)) {\n      name = 'constructor';\n    } else if (ts.isIdentifier(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else {\n      return null;\n    }\n\n    const decorators = this.getDecoratorsOfDeclaration(node);\n    const isStatic = node.modifiers !== undefined &&\n        node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n\n    return {\n      node,\n      implementation: node, kind,\n      type: node.type || null, name, nameNode, decorators, value, isStatic,\n    };\n  }\n}\n\nexport function reflectNameOfDeclaration(decl: ts.Declaration): string|null {\n  const id = reflectIdentifierOfDeclaration(decl);\n  return id && id.text || null;\n}\n\nexport function reflectIdentifierOfDeclaration(decl: ts.Declaration): ts.Identifier|null {\n  if (ts.isClassDeclaration(decl) || ts.isFunctionDeclaration(decl)) {\n    return decl.name || null;\n  } else if (ts.isVariableDeclaration(decl)) {\n    if (ts.isIdentifier(decl.name)) {\n      return decl.name;\n    }\n  }\n  return null;\n}\n\nexport function reflectTypeEntityToDeclaration(\n    type: ts.EntityName, checker: ts.TypeChecker): {node: ts.Declaration, from: string | null} {\n  let realSymbol = checker.getSymbolAtLocation(type);\n  if (realSymbol === undefined) {\n    throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);\n  }\n  while (realSymbol.flags & ts.SymbolFlags.Alias) {\n    realSymbol = checker.getAliasedSymbol(realSymbol);\n  }\n\n  let node: ts.Declaration|null = null;\n  if (realSymbol.valueDeclaration !== undefined) {\n    node = realSymbol.valueDeclaration;\n  } else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {\n    node = realSymbol.declarations[0];\n  } else {\n    throw new Error(`Cannot resolve type entity symbol to declaration`);\n  }\n\n  if (ts.isQualifiedName(type)) {\n    if (!ts.isIdentifier(type.left)) {\n      throw new Error(`Cannot handle qualified name with non-identifier lhs`);\n    }\n    const symbol = checker.getSymbolAtLocation(type.left);\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      throw new Error(`Cannot resolve qualified type entity lhs to symbol`);\n    }\n    const decl = symbol.declarations[0];\n    if (ts.isNamespaceImport(decl)) {\n      const clause = decl.parent !;\n      const importDecl = clause.parent !;\n      if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n        throw new Error(`Module specifier is not a string`);\n      }\n      return {node, from: importDecl.moduleSpecifier.text};\n    } else {\n      throw new Error(`Unknown import type?`);\n    }\n  } else {\n    return {node, from: null};\n  }\n}\n\nexport function filterToMembersWithDecorator(members: ClassMember[], name: string, module?: string):\n    {member: ClassMember, decorators: Decorator[]}[] {\n  return members.filter(member => !member.isStatic)\n      .map(member => {\n        if (member.decorators === null) {\n          return null;\n        }\n\n        const decorators = member.decorators.filter(dec => {\n          if (dec.import !== null) {\n            return dec.import.name === name && (module === undefined || dec.import.from === module);\n          } else {\n            return dec.name === name && module === undefined;\n          }\n        });\n\n        if (decorators.length === 0) {\n          return null;\n        }\n\n        return {member, decorators};\n      })\n      .filter((value): value is {member: ClassMember, decorators: Decorator[]} => value !== null);\n}\n\nexport function findMember(\n    members: ClassMember[], name: string, isStatic: boolean = false): ClassMember|null {\n  return members.find(member => member.isStatic === isStatic && member.name === name) || null;\n}\n\nexport function reflectObjectLiteral(node: ts.ObjectLiteralExpression): Map<string, ts.Expression> {\n  const map = new Map<string, ts.Expression>();\n  node.properties.forEach(prop => {\n    if (ts.isPropertyAssignment(prop)) {\n      const name = propertyNameToString(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\n\nfunction castDeclarationToClassOrDie(declaration: ts.Declaration): ts.ClassDeclaration {\n  if (!ts.isClassDeclaration(declaration)) {\n    throw new Error(\n        `Reflecting on a ${ts.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);\n  }\n  return declaration;\n}\n\nfunction parameterName(name: ts.BindingName): string|null {\n  if (ts.isIdentifier(name)) {\n    return name.text;\n  } else {\n    return null;\n  }\n}\n\nfunction typeNodeToValueExpr(node: ts.TypeNode): ts.Expression|null {\n  if (ts.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\n\nfunction entityNameToValue(node: ts.EntityName): ts.Expression|null {\n  if (ts.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts.createPropertyAccess(left, node.right) : null;\n  } else if (ts.isIdentifier(node)) {\n    return ts.getMutableClone(node);\n  } else {\n    return null;\n  }\n}\n\nfunction propertyNameToString(node: ts.PropertyName): string|null {\n  if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\n"]}