{"version":3,"file":"factory_generator.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/factory_generator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {relativePathBetween} from '../../util/src/path';\n\nimport {ShimGenerator} from './host';\nimport {isNonDeclarationTsFile} from './util';\n\nconst TS_DTS_SUFFIX = /(\\.d)?\\.ts$/;\nconst STRIP_NG_FACTORY = /(.*)NgFactory$/;\n\n/**\n * Generates ts.SourceFiles which contain variable declarations for NgFactories for every exported\n * class of an input ts.SourceFile.\n */\nexport class FactoryGenerator implements ShimGenerator {\n  private constructor(private map: Map<string, string>) {}\n\n  get factoryFileMap(): Map<string, string> { return this.map; }\n\n  getOriginalSourceOfShim(fileName: string): string|null { return this.map.get(fileName) || null; }\n\n  generate(original: ts.SourceFile, genFilePath: string): ts.SourceFile {\n    const relativePathToSource =\n        './' + path.posix.basename(original.fileName).replace(TS_DTS_SUFFIX, '');\n    // Collect a list of classes that need to have factory types emitted for them. This list is\n    // overly broad as at this point the ts.TypeChecker hasn't been created, and can't be used to\n    // semantically understand which decorated types are actually decorated with Angular decorators.\n    //\n    // The exports generated here are pruned in the factory transform during emit.\n    const symbolNames = original\n                            .statements\n                            // Pick out top level class declarations...\n                            .filter(ts.isClassDeclaration)\n                            // which are named, exported, and have decorators.\n                            .filter(\n                                decl => isExported(decl) && decl.decorators !== undefined &&\n                                    decl.name !== undefined)\n                            // Grab the symbol name.\n                            .map(decl => decl.name !.text);\n\n    // For each symbol name, generate a constant export of the corresponding NgFactory.\n    // This will encompass a lot of symbols which don't need factories, but that's okay\n    // because it won't miss any that do.\n    const varLines = symbolNames.map(\n        name => `export const ${name}NgFactory = new i0.ɵNgModuleFactory(${name});`);\n    const sourceText = [\n      // This might be incorrect if the current package being compiled is Angular core, but it's\n      // okay to leave in at type checking time. TypeScript can handle this reference via its path\n      // mapping, but downstream bundlers can't. If the current package is core itself, this will be\n      // replaced in the factory transformer before emit.\n      `import * as i0 from '@angular/core';`,\n      `import {${symbolNames.join(', ')}} from '${relativePathToSource}';`,\n      ...varLines,\n    ].join('\\n');\n    return ts.createSourceFile(\n        genFilePath, sourceText, original.languageVersion, true, ts.ScriptKind.TS);\n  }\n\n  static forRootFiles(files: ReadonlyArray<string>): FactoryGenerator {\n    const map = new Map<string, string>();\n    files.filter(sourceFile => isNonDeclarationTsFile(sourceFile))\n        .forEach(sourceFile => map.set(sourceFile.replace(/\\.ts$/, '.ngfactory.ts'), sourceFile));\n    return new FactoryGenerator(map);\n  }\n}\n\nfunction isExported(decl: ts.Declaration): boolean {\n  return decl.modifiers !== undefined &&\n      decl.modifiers.some(mod => mod.kind == ts.SyntaxKind.ExportKeyword);\n}\n\nexport interface FactoryInfo {\n  sourceFilePath: string;\n  moduleSymbolNames: Set<string>;\n}\n\nexport function generatedFactoryTransform(\n    factoryMap: Map<string, FactoryInfo>,\n    coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return transformFactorySourceFile(factoryMap, context, coreImportsFrom, file);\n    };\n  };\n}\n\nfunction transformFactorySourceFile(\n    factoryMap: Map<string, FactoryInfo>, context: ts.TransformationContext,\n    coreImportsFrom: ts.SourceFile | null, file: ts.SourceFile): ts.SourceFile {\n  // If this is not a generated file, it won't have factory info associated with it.\n  if (!factoryMap.has(file.fileName)) {\n    // Don't transform non-generated code.\n    return file;\n  }\n\n  const {moduleSymbolNames, sourceFilePath} = factoryMap.get(file.fileName) !;\n\n  const clone = ts.getMutableClone(file);\n\n  const transformedStatements = file.statements.map(stmt => {\n    if (coreImportsFrom !== null && ts.isImportDeclaration(stmt) &&\n        ts.isStringLiteral(stmt.moduleSpecifier) && stmt.moduleSpecifier.text === '@angular/core') {\n      const path = relativePathBetween(sourceFilePath, coreImportsFrom.fileName);\n      if (path !== null) {\n        return ts.updateImportDeclaration(\n            stmt, stmt.decorators, stmt.modifiers, stmt.importClause, ts.createStringLiteral(path));\n      } else {\n        return ts.createNotEmittedStatement(stmt);\n      }\n    } else if (ts.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {\n      const decl = stmt.declarationList.declarations[0];\n      if (ts.isIdentifier(decl.name)) {\n        const match = STRIP_NG_FACTORY.exec(decl.name.text);\n        if (match === null || !moduleSymbolNames.has(match[1])) {\n          // Remove the given factory as it wasn't actually for an NgModule.\n          return ts.createNotEmittedStatement(stmt);\n        }\n      }\n      return stmt;\n    } else {\n      return stmt;\n    }\n  });\n  if (!transformedStatements.some(ts.isVariableStatement)) {\n    // If the resulting file has no factories, include an empty export to\n    // satisfy closure compiler.\n    transformedStatements.push(ts.createVariableStatement(\n        [ts.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.createVariableDeclarationList(\n            [ts.createVariableDeclaration('ɵNonEmptyModule', undefined, ts.createTrue())],\n            ts.NodeFlags.Const)));\n  }\n  clone.statements = ts.createNodeArray(transformedStatements);\n  return clone;\n}\n"]}