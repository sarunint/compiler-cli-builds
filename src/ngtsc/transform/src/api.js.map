{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/api.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, Expression, Statement, Type} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator} from '../../host';\nimport {TypeCheckContext} from '../../typecheck';\n\n\n/**\n * Provides the interface between a decorator compiler from @angular/compiler and the Typescript\n * compiler/transform.\n *\n * The decorator compilers in @angular/compiler do not depend on Typescript. The handler is\n * responsible for extracting the information required to perform compilation from the decorators\n * and Typescript source, invoking the decorator compiler, and returning the result.\n */\nexport interface DecoratorHandler<A, M> {\n  /**\n   * Scan a set of reflected decorators and determine if this handler is responsible for compilation\n   * of one of them.\n   */\n  detect(node: ts.Declaration, decorators: Decorator[]|null): M|undefined;\n\n\n  /**\n   * Asynchronously perform pre-analysis on the decorator/class combination.\n   *\n   * `preAnalyze` is optional and is not guaranteed to be called through all compilation flows. It\n   * will only be called if asynchronicity is supported in the CompilerHost.\n   */\n  preanalyze?(node: ts.Declaration, metadata: M): Promise<void>|undefined;\n\n  /**\n   * Perform analysis on the decorator/class combination, producing instructions for compilation\n   * if successful, or an array of diagnostic messages if the analysis fails or the decorator\n   * isn't valid.\n   */\n  analyze(node: ts.Declaration, metadata: M): AnalysisOutput<A>;\n\n  typeCheck?(ctx: TypeCheckContext, node: ts.Declaration, metadata: A): void;\n\n  /**\n   * Generate a description of the field which should be added to the class, including any\n   * initialization code to be generated.\n   */\n  compile(node: ts.Declaration, analysis: A, constantPool: ConstantPool): CompileResult\n      |CompileResult[];\n}\n\n/**\n * The output of an analysis operation, consisting of possibly an arbitrary analysis object (used as\n * the input to code generation) and potentially diagnostics if there were errors uncovered during\n * analysis.\n */\nexport interface AnalysisOutput<A> {\n  analysis?: A;\n  diagnostics?: ts.Diagnostic[];\n  factorySymbolName?: string;\n  typeCheck?: boolean;\n}\n\n/**\n * A description of the static field to add to a class, including an initialization expression\n * and a type for the .d.ts file.\n */\nexport interface CompileResult {\n  name: string;\n  initializer: Expression;\n  statements: Statement[];\n  type: Type;\n}\n"]}