{"version":3,"file":"compilation.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/compilation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {FatalDiagnosticError} from '../../diagnostics';\nimport {Decorator, ReflectionHost} from '../../host';\nimport {reflectNameOfDeclaration} from '../../metadata/src/reflector';\nimport {TypeCheckContext} from '../../typecheck';\n\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from './api';\nimport {DtsFileTransformer} from './declaration';\n\n\n/**\n * Record of an adapter which decided to emit a static field, and the analysis it performed to\n * prepare for that operation.\n */\ninterface EmitFieldOperation<A, M> {\n  adapter: DecoratorHandler<A, M>;\n  analysis: AnalysisOutput<A>;\n  metadata: M;\n}\n\n/**\n * Manages a compilation of Ivy decorators into static fields across an entire ts.Program.\n *\n * The compilation is stateful - source files are analyzed and records of the operations that need\n * to be performed during the transform/emit process are maintained internally.\n */\nexport class IvyCompilation {\n  /**\n   * Tracks classes which have been analyzed and found to have an Ivy decorator, and the\n   * information recorded about them for later compilation.\n   */\n  private analysis = new Map<ts.Declaration, EmitFieldOperation<any, any>>();\n  private typeCheckMap = new Map<ts.Declaration, DecoratorHandler<any, any>>();\n\n  /**\n   * Tracks factory information which needs to be generated.\n   */\n\n  /**\n   * Tracks the `DtsFileTransformer`s for each TS file that needs .d.ts transformations.\n   */\n  private dtsMap = new Map<string, DtsFileTransformer>();\n  private _diagnostics: ts.Diagnostic[] = [];\n\n\n  /**\n   * @param handlers array of `DecoratorHandler`s which will be executed against each class in the\n   * program\n   * @param checker TypeScript `TypeChecker` instance for the program\n   * @param reflector `ReflectionHost` through which all reflection operations will be performed\n   * @param coreImportsFrom a TypeScript `SourceFile` which exports symbols needed for Ivy imports\n   * when compiling @angular/core, or `null` if the current program is not @angular/core. This is\n   * `null` in most cases.\n   */\n  constructor(\n      private handlers: DecoratorHandler<any, any>[], private checker: ts.TypeChecker,\n      private reflector: ReflectionHost, private coreImportsFrom: ts.SourceFile|null,\n      private sourceToFactorySymbols: Map<string, Set<string>>|null) {}\n\n\n  analyzeSync(sf: ts.SourceFile): void { return this.analyze(sf, false); }\n\n  analyzeAsync(sf: ts.SourceFile): Promise<void>|undefined { return this.analyze(sf, true); }\n\n  /**\n   * Analyze a source file and produce diagnostics for it (if any).\n   */\n  private analyze(sf: ts.SourceFile, preanalyze: false): undefined;\n  private analyze(sf: ts.SourceFile, preanalyze: true): Promise<void>|undefined;\n  private analyze(sf: ts.SourceFile, preanalyze: boolean): Promise<void>|undefined {\n    const promises: Promise<void>[] = [];\n\n    const analyzeClass = (node: ts.Declaration): void => {\n      // The first step is to reflect the decorators.\n      const classDecorators = this.reflector.getDecoratorsOfDeclaration(node);\n\n      // Look through the DecoratorHandlers to see if any are relevant.\n      this.handlers.forEach(adapter => {\n\n        // An adapter is relevant if it matches one of the decorators on the class.\n        const metadata = adapter.detect(node, classDecorators);\n        if (metadata === undefined) {\n          return;\n        }\n\n        const completeAnalysis = () => {\n          // Check for multiple decorators on the same node. Technically speaking this\n          // could be supported, but right now it's an error.\n          if (this.analysis.has(node)) {\n            throw new Error('TODO.Diagnostic: Class has multiple Angular decorators.');\n          }\n\n          // Run analysis on the metadata. This will produce either diagnostics, an\n          // analysis result, or both.\n          try {\n            const analysis = adapter.analyze(node, metadata);\n            if (analysis.analysis !== undefined) {\n              this.analysis.set(node, {\n                adapter,\n                analysis: analysis.analysis,\n                metadata: metadata,\n              });\n              if (!!analysis.typeCheck) {\n                this.typeCheckMap.set(node, adapter);\n              }\n            }\n\n            if (analysis.diagnostics !== undefined) {\n              this._diagnostics.push(...analysis.diagnostics);\n            }\n\n            if (analysis.factorySymbolName !== undefined && this.sourceToFactorySymbols !== null &&\n                this.sourceToFactorySymbols.has(sf.fileName)) {\n              this.sourceToFactorySymbols.get(sf.fileName) !.add(analysis.factorySymbolName);\n            }\n          } catch (err) {\n            if (err instanceof FatalDiagnosticError) {\n              this._diagnostics.push(err.toDiagnostic());\n            } else {\n              throw err;\n            }\n          }\n        };\n\n        if (preanalyze && adapter.preanalyze !== undefined) {\n          const preanalysis = adapter.preanalyze(node, metadata);\n          if (preanalysis !== undefined) {\n            promises.push(preanalysis.then(() => completeAnalysis()));\n          } else {\n            completeAnalysis();\n          }\n        } else {\n          completeAnalysis();\n        }\n      });\n    };\n\n    const visit = (node: ts.Node): void => {\n      // Process nodes recursively, and look for class declarations with decorators.\n      if (ts.isClassDeclaration(node)) {\n        analyzeClass(node);\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sf);\n\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => undefined);\n    } else {\n      return undefined;\n    }\n  }\n\n  typeCheck(context: TypeCheckContext): void {\n    this.typeCheckMap.forEach((handler, node) => {\n      if (handler.typeCheck !== undefined) {\n        handler.typeCheck(context, node, this.analysis.get(node) !.analysis);\n      }\n    });\n  }\n\n  /**\n   * Perform a compilation operation on the given class declaration and return instructions to an\n   * AST transformer if any are available.\n   */\n  compileIvyFieldFor(node: ts.Declaration, constantPool: ConstantPool): CompileResult[]|undefined {\n    // Look to see whether the original node was analyzed. If not, there's nothing to do.\n    const original = ts.getOriginalNode(node) as ts.Declaration;\n    if (!this.analysis.has(original)) {\n      return undefined;\n    }\n    const op = this.analysis.get(original) !;\n\n    // Run the actual compilation, which generates an Expression for the Ivy field.\n    let res: CompileResult|CompileResult[] = op.adapter.compile(node, op.analysis, constantPool);\n    if (!Array.isArray(res)) {\n      res = [res];\n    }\n\n    // Look up the .d.ts transformer for the input file and record that a field was generated,\n    // which will allow the .d.ts to be transformed later.\n    const fileName = original.getSourceFile().fileName;\n    const dtsTransformer = this.getDtsTransformer(fileName);\n    dtsTransformer.recordStaticField(reflectNameOfDeclaration(node) !, res);\n\n    // Return the instruction to the transformer so the field will be added.\n    return res;\n  }\n\n  /**\n   * Lookup the `ts.Decorator` which triggered transformation of a particular class declaration.\n   */\n  ivyDecoratorFor(node: ts.Declaration): Decorator|undefined {\n    const original = ts.getOriginalNode(node) as ts.Declaration;\n    if (!this.analysis.has(original)) {\n      return undefined;\n    }\n\n    return this.analysis.get(original) !.metadata;\n  }\n\n  /**\n   * Process a .d.ts source string and return a transformed version that incorporates the changes\n   * made to the source file.\n   */\n  transformedDtsFor(tsFileName: string, dtsOriginalSource: string): string {\n    // No need to transform if no changes have been requested to the input file.\n    if (!this.dtsMap.has(tsFileName)) {\n      return dtsOriginalSource;\n    }\n\n    // Return the transformed .d.ts source.\n    return this.dtsMap.get(tsFileName) !.transform(dtsOriginalSource, tsFileName);\n  }\n\n  get diagnostics(): ReadonlyArray<ts.Diagnostic> { return this._diagnostics; }\n\n  private getDtsTransformer(tsFileName: string): DtsFileTransformer {\n    if (!this.dtsMap.has(tsFileName)) {\n      this.dtsMap.set(tsFileName, new DtsFileTransformer(this.coreImportsFrom));\n    }\n    return this.dtsMap.get(tsFileName) !;\n  }\n}\n"]}