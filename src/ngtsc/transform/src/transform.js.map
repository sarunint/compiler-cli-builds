{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Decorator, ReflectionHost} from '../../host';\nimport {ImportManager, translateExpression, translateStatement} from '../../translator';\nimport {relativePathBetween} from '../../util/src/path';\nimport {VisitListEntryResult, Visitor, visit} from '../../util/src/visitor';\n\nimport {CompileResult} from './api';\nimport {IvyCompilation} from './compilation';\n\nconst NO_DECORATORS = new Set<ts.Decorator>();\n\nexport function ivyTransformFactory(\n    compilation: IvyCompilation, reflector: ReflectionHost,\n    coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return transformIvySourceFile(compilation, context, reflector, coreImportsFrom, file);\n    };\n  };\n}\n\nclass IvyVisitor extends Visitor {\n  constructor(\n      private compilation: IvyCompilation, private reflector: ReflectionHost,\n      private importManager: ImportManager, private isCore: boolean,\n      private constantPool: ConstantPool) {\n    super();\n  }\n\n  visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    // Determine if this class has an Ivy field that needs to be added, and compile the field\n    // to an expression if so.\n    const res = this.compilation.compileIvyFieldFor(node, this.constantPool);\n\n    if (res !== undefined) {\n      // There is at least one field to add.\n      const statements: ts.Statement[] = [];\n      const members = [...node.members];\n\n      res.forEach(field => {\n        // Translate the initializer for the field into TS nodes.\n        const exprNode = translateExpression(field.initializer, this.importManager);\n\n        // Create a static property declaration for the new field.\n        const property = ts.createProperty(\n            undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined,\n            undefined, exprNode);\n\n        field.statements.map(stmt => translateStatement(stmt, this.importManager))\n            .forEach(stmt => statements.push(stmt));\n\n        members.push(property);\n      });\n\n      // Replace the class declaration with an updated version.\n      node = ts.updateClassDeclaration(\n          node,\n          // Remove the decorator which triggered this compilation, leaving the others alone.\n          maybeFilterDecorator(\n              node.decorators, this.compilation.ivyDecoratorFor(node) !.node as ts.Decorator),\n          node.modifiers, node.name, node.typeParameters, node.heritageClauses || [],\n          // Map over the class members and remove any Angular decorators from them.\n          members.map(member => this._stripAngularDecorators(member)));\n      return {node, after: statements};\n    }\n\n    return {node};\n  }\n\n  /**\n   * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none\n   * are.\n   */\n  private _angularCoreDecorators(decl: ts.Declaration): Set<ts.Decorator> {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec))\n                               .map(dec => dec.node as ts.Decorator);\n    if (coreDecorators.length > 0) {\n      return new Set<ts.Decorator>(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n\n  /**\n   * Given a `ts.Node`, filter the decorators array and return a version containing only non-Angular\n   * decorators.\n   *\n   * If all decorators are removed (or none existed in the first place), this method returns\n   * `undefined`.\n   */\n  private _nonCoreDecoratorsOnly(node: ts.Declaration): ts.NodeArray<ts.Decorator>|undefined {\n    // Shortcut if the node has no decorators.\n    if (node.decorators === undefined) {\n      return undefined;\n    }\n    // Build a Set of the decorators on this node from @angular/core.\n    const coreDecorators = this._angularCoreDecorators(node);\n\n    if (coreDecorators.size === node.decorators.length) {\n      // If all decorators are to be removed, return `undefined`.\n      return undefined;\n    } else if (coreDecorators.size === 0) {\n      // If no decorators need to be removed, return the original decorators array.\n      return node.decorators;\n    }\n\n    // Filter out the core decorators.\n    const filtered = node.decorators.filter(dec => !coreDecorators.has(dec));\n\n    // If no decorators survive, return `undefined`. This can only happen if a core decorator is\n    // repeated on the node.\n    if (filtered.length === 0) {\n      return undefined;\n    }\n\n    // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.\n    const array = ts.createNodeArray(filtered);\n    array.pos = node.decorators.pos;\n    array.end = node.decorators.end;\n    return array;\n  }\n\n  /**\n   * Remove Angular decorators from a `ts.Node` in a shallow manner.\n   *\n   * This will remove decorators from class elements (getters, setters, properties, methods) as well\n   * as parameters of constructors.\n   */\n  private _stripAngularDecorators<T extends ts.Node>(node: T): T {\n    if (ts.isParameter(node)) {\n      // Strip decorators from parameters (probably of the constructor).\n      node = ts.updateParameter(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken,\n                 node.name, node.questionToken, node.type, node.initializer) as T &\n          ts.ParameterDeclaration;\n    } else if (ts.isMethodDeclaration(node) && node.decorators !== undefined) {\n      // Strip decorators of methods.\n      node = ts.updateMethod(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken,\n                 node.name, node.questionToken, node.typeParameters, node.parameters, node.type,\n                 node.body) as T &\n          ts.MethodDeclaration;\n    } else if (ts.isPropertyDeclaration(node) && node.decorators !== undefined) {\n      // Strip decorators of properties.\n      node = ts.updateProperty(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.questionToken, node.type, node.initializer) as T &\n          ts.PropertyDeclaration;\n    } else if (ts.isGetAccessor(node)) {\n      // Strip decorators of getters.\n      node = ts.updateGetAccessor(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.parameters, node.type, node.body) as T &\n          ts.GetAccessorDeclaration;\n    } else if (ts.isSetAccessor(node)) {\n      // Strip decorators of setters.\n      node = ts.updateSetAccessor(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.parameters, node.body) as T &\n          ts.SetAccessorDeclaration;\n    } else if (ts.isConstructorDeclaration(node)) {\n      // For constructors, strip decorators of the parameters.\n      const parameters = node.parameters.map(param => this._stripAngularDecorators(param));\n      node =\n          ts.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body) as T &\n          ts.ConstructorDeclaration;\n    }\n    return node;\n  }\n}\n\n/**\n * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.\n */\nfunction transformIvySourceFile(\n    compilation: IvyCompilation, context: ts.TransformationContext, reflector: ReflectionHost,\n    coreImportsFrom: ts.SourceFile | null, file: ts.SourceFile): ts.SourceFile {\n  const constantPool = new ConstantPool();\n  const importManager = new ImportManager(coreImportsFrom !== null);\n\n  // Recursively scan through the AST and perform any updates requested by the IvyCompilation.\n  const visitor =\n      new IvyVisitor(compilation, reflector, importManager, coreImportsFrom !== null, constantPool);\n  const sf = visit(file, visitor, context);\n\n  // Generate the constant statements first, as they may involve adding additional imports\n  // to the ImportManager.\n  const constants = constantPool.statements.map(stmt => translateStatement(stmt, importManager));\n\n  // Generate the import statements to prepend.\n  const addedImports = importManager.getAllImports(file.fileName, coreImportsFrom).map(i => {\n    return ts.createImportDeclaration(\n        undefined, undefined,\n        ts.createImportClause(undefined, ts.createNamespaceImport(ts.createIdentifier(i.as))),\n        ts.createLiteral(i.name));\n  });\n\n  // Filter out the existing imports and the source file body. All new statements\n  // will be inserted between them.\n  const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));\n  const body = sf.statements.filter(stmt => !isImportStatement(stmt));\n\n  // Prepend imports if needed.\n  if (addedImports.length > 0) {\n    sf.statements =\n        ts.createNodeArray([...existingImports, ...addedImports, ...constants, ...body]);\n  }\n  return sf;\n}\n\nfunction maybeFilterDecorator(\n    decorators: ts.NodeArray<ts.Decorator>| undefined,\n    toRemove: ts.Decorator): ts.NodeArray<ts.Decorator>|undefined {\n  if (decorators === undefined) {\n    return undefined;\n  }\n  const filtered = decorators.filter(dec => ts.getOriginalNode(dec) !== toRemove);\n  if (filtered.length === 0) {\n    return undefined;\n  }\n  return ts.createNodeArray(filtered);\n}\n\nfunction isFromAngularCore(decorator: Decorator): boolean {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\nfunction isImportStatement(stmt: ts.Statement): boolean {\n  return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) ||\n      ts.isNamespaceImport(stmt);\n}\n"]}