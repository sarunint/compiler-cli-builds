{"version":3,"file":"collector.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/metadata/collector.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,iCAAiC;AAEjC,2CAAmE;AACnE,qCAAu1B;AACv1B,uCAAkC;AAElC,MAAM,QAAQ,GAAG,CAAC,IAAoB,EAAE,EAAE,CACtC,EAAE,CAAC,wBAAwB,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC;AA4BhE;;GAEG;AACH,MAAa,iBAAiB;IAC5B,YAAoB,UAA4B,EAAE;QAA9B,YAAO,GAAP,OAAO,CAAuB;IAAG,CAAC;IAEtD;;;OAGG;IACI,WAAW,CACd,UAAyB,EAAE,SAAkB,KAAK,EAClD,oBAA6E;QAE/E,MAAM,MAAM,GAAG,IAAI,iBAAO,CAAC,UAAU,CAAC,CAAC;QACvC,MAAM,OAAO,GACT,IAAI,GAAG,EAA2E,CAAC;QACvF,MAAM,mBAAmB,GAAG,oBAAoB,IAAI,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC;YACnF,CAAC,KAAoB,EAAE,IAAa,EAAE,EAAE,CACpC,IAAI,CAAC,OAAO,CAAC,oBAAsB,CAAC,oBAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;YAClF,oBAAoB,CAAC;QACzB,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,CAAC,mBACvC,IAAI,CAAC,OAAO,IAAE,oBAAoB,EAAE,mBAAmB,IAAE,CAAC;YAC9D,IAAI,CAAC,OAAO,CAAC;QACjB,IAAI,QAAsF,CAAC;QAC3F,MAAM,SAAS,GAAG,IAAI,qBAAS,CAAC,MAAM,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;YACjF,IAAI,CAAC,QAAQ;gBAAE,QAAQ,GAAG,EAAE,CAAC;YAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;QACzB,CAAC,CAAC,CAAC;QACH,IAAI,OAAO,GAAqC,SAAS,CAAC;QAE1D,SAAS,gBAAgB,CAAC,aAA2B;YACnD,OAAmC,SAAS,CAAC,YAAY,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QACtF,CAAC;QAED,SAAS,WAAW,CAA0B,KAAQ,EAAE,IAAa;YACnE,IAAI,mBAAmB,EAAE;gBACvB,KAAK,GAAG,mBAAmB,CAAC,KAAsB,EAAE,IAAI,CAAM,CAAC;aAChE;YACD,OAAO,0BAAc,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;QAC1D,CAAC;QAED,SAAS,QAAQ,CACb,OAAe,EAAE,IAAc,EAAE,OAAkC;YACrE,OAAO,uBAAW,CAAC,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;QACzD,CAAC;QAED,SAAS,sBAAsB,CAC3B,mBACoB;YACtB,IAAI,mBAAmB,CAAC,IAAI,IAAI,mBAAmB,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE;gBACzF,MAAM,QAAQ,GAAkB,mBAAmB,CAAC,IAAI,CAAC;gBACzD,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;gBACnC,MAAM,YAAY,GAAG,mBAAmB,CAAC,IAAI,CAAC;gBAC9C,IAAI,YAAY,IAAI,YAAY,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE;oBACvD,MAAM,SAAS,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC7C,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,EAAE;wBACpD,MAAM,eAAe,GAAuB,SAAS,CAAC;wBACtD,IAAI,eAAe,CAAC,UAAU,EAAE;4BAC9B,MAAM,IAAI,GAAqB;gCAC7B,UAAU,EAAE,UAAU;gCACtB,UAAU,EAAE,OAAO,CAAC,mBAAmB,CAAC,UAAU,CAAC;gCACnD,KAAK,EAAE,SAAS,CAAC,YAAY,CAAC,eAAe,CAAC,UAAU,CAAC;6BAC1D,CAAC;4BACF,IAAI,mBAAmB,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,IAAI,CAAC,EAAE;gCACnE,IAAI,CAAC,QAAQ,GAAG,mBAAmB,CAAC,UAAU,CAAC,GAAG,CAC9C,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;6BAClE;4BACD,OAAO,WAAW,CAAC,EAAC,IAAI,EAAE,IAAI,EAAE,YAAY,EAAC,EAAE,mBAAmB,CAAC,CAAC;yBACrE;qBACF;iBACF;aACF;QACH,CAAC;QAED,SAAS,eAAe,CAAC,gBAAqC;YAC5D,MAAM,MAAM,GAAkB,EAAC,UAAU,EAAE,OAAO,EAAC,CAAC;YAEpD,SAAS,aAAa,CAAC,UAAkD;gBAEvE,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM;oBACjC,OAAO,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;gBAClE,OAAO,SAAS,CAAC;YACnB,CAAC;YAED,SAAS,aAAa,CAAC,IAAa;gBAElC,MAAM,MAAM,GAAG,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,wBAAe,CAAC,MAAM,CAAC,IAAI,8CAAqC,CAAC,MAAM,CAAC;oBACxE,2CAAkC,CAAC,MAAM,CAAC,EAAE;oBAC9C,OAAO,MAAM,CAAC;iBACf;qBAAM;oBACL,OAAO,QAAQ,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC;iBACpD;YACH,CAAC;YAED,oBAAoB;YACpB,IAAI,gBAAgB,CAAC,eAAe,EAAE;gBACpC,gBAAgB,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;oBAC9C,IAAI,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc,IAAI,EAAE,CAAC,KAAK,EAAE;wBACzD,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,GAAG,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;qBAC3E;gBACH,CAAC,CAAC,CAAC;aACJ;YAED,mCAAmC;YACnC,MAAM,cAAc,GAAG,gBAAgB,CAAC,cAAc,CAAC;YACvD,IAAI,cAAc,IAAI,cAAc,CAAC,MAAM,EAAE;gBAC3C,MAAM,CAAC,KAAK,GAAG,cAAc,CAAC,MAAM,CAAC;aACtC;YAED,uBAAuB;YACvB,IAAI,gBAAgB,CAAC,UAAU,EAAE;gBAC/B,MAAM,CAAC,UAAU,GAAG,aAAa,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;aAChE;YAED,oBAAoB;YACpB,IAAI,OAAO,GAAqB,IAAI,CAAC;YACrC,SAAS,YAAY,CAAC,IAAY,EAAE,QAAwB;gBAC1D,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,MAAM,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC/D,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACpB,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YACvB,CAAC;YAED,gBAAgB;YAChB,IAAI,OAAO,GAA4D,IAAI,CAAC;YAC5E,SAAS,kBAAkB,CAAC,IAAY,EAAE,KAAuC;gBAC/E,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;YACxB,CAAC;YAED,KAAK,MAAM,MAAM,IAAI,gBAAgB,CAAC,OAAO,EAAE;gBAC7C,IAAI,aAAa,GAAG,KAAK,CAAC;gBAC1B,QAAQ,MAAM,CAAC,IAAI,EAAE;oBACnB,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;oBAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;wBAClC,aAAa,GAAG,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;wBAC1D,MAAM,MAAM,GAAmD,MAAM,CAAC;wBACtE,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;4BACpB,MAAM,SAAS,GAAG,sBAAsB,CAAuB,MAAM,CAAC,CAAC;4BACvE,IAAI,SAAS,EAAE;gCACb,kBAAkB,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;6BACpD;4BACD,SAAS;yBACV;wBACD,MAAM,gBAAgB,GAAG,aAAa,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;wBAC1D,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;wBACrC,MAAM,sBAAsB,GACyC,EAAE,CAAC;wBACxE,MAAM,cAAc,GAE8B,EAAE,CAAC;wBACrD,IAAI,gBAAgB,GAAY,KAAK,CAAC;wBACtC,IAAI,gBAAgB,GAAY,KAAK,CAAC;wBACtC,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;4BAClC,MAAM,aAAa,GAAG,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;4BAC1D,sBAAsB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;4BAC3C,gBAAgB,GAAG,gBAAgB,IAAI,CAAC,CAAC,aAAa,CAAC;4BACvD,IAAI,aAAa,EAAE;gCACjB,IAAI,SAAS,CAAC,IAAI,EAAE;oCAClB,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;iCACpD;qCAAM;oCACL,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iCAC3B;gCACD,gBAAgB,GAAG,IAAI,CAAC;6BACzB;yBACF;wBACD,MAAM,IAAI,GAAmB,EAAC,UAAU,EAAE,aAAa,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,EAAC,CAAC;wBACpF,MAAM,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;wBACxE,IAAI,gBAAgB,EAAE;4BACpB,IAAI,CAAC,UAAU,GAAG,gBAAgB,CAAC;yBACpC;wBACD,IAAI,gBAAgB,EAAE;4BACpB,IAAI,CAAC,mBAAmB,GAAG,sBAAsB,CAAC;yBACnD;wBACD,IAAI,gBAAgB,EAAE;4BACE,IAAK,CAAC,UAAU,GAAG,cAAc,CAAC;yBACzD;wBACD,IAAI,CAAC,wBAAe,CAAC,IAAI,CAAC,EAAE;4BAC1B,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;yBAC1B;wBACD,MAAM;oBACR,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB,CAAC;oBACvC,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC;oBAC/B,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;wBAC5B,MAAM,QAAQ,GAA2B,MAAM,CAAC;wBAChD,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE;4BACtB,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;4BAC7C,IAAI,CAAC,wBAAe,CAAC,IAAI,CAAC,EAAE;gCAC1B,IAAI,QAAQ,CAAC,WAAW,EAAE;oCACxB,MAAM,KAAK,GAAG,SAAS,CAAC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oCAC3D,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;iCACjC;qCAAM;oCACL,kBAAkB,CAAC,IAAI,EAAE,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;iCAC/E;6BACF;yBACF;wBACD,MAAM,kBAAkB,GAAG,aAAa,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;wBAC9D,IAAI,kBAAkB,EAAE;4BACtB,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;4BAC7C,IAAI,CAAC,wBAAe,CAAC,IAAI,CAAC,EAAE;gCAC1B,YAAY,CAAC,IAAI,EAAE,EAAC,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,kBAAkB,EAAC,CAAC,CAAC;6BAC9E;yBACF;wBACD,MAAM;iBACT;aACF;YACD,IAAI,OAAO,EAAE;gBACX,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;aAC1B;YACD,IAAI,OAAO,EAAE;gBACX,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;aAC1B;YAED,OAAO,WAAW,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QAC/C,CAAC;QAED,uDAAuD;QACvD,MAAM,SAAS,GAAG,IAAI,GAAG,EAAkB,CAAC;QAC5C,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE;YACjC,QAAQ,IAAI,CAAC,IAAI,EAAE;gBACjB,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;oBAClC,MAAM,iBAAiB,GAAyB,IAAI,CAAC;oBACrD,MAAM,EAAC,eAAe,EAAE,YAAY,EAAC,GAAG,iBAAiB,CAAC;oBAE1D,IAAI,CAAC,eAAe,EAAE;wBACpB,+DAA+D;wBAC/D,YAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;4BACrC,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;4BAClC,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;4BACnD,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;wBAClC,CAAC,CAAC,CAAC;qBACJ;aACJ;QACH,CAAC,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,CAAC,IAAa,EAAE,EAAE,CAAC,UAAU,CAAC,iBAAiB;YAC5D,EAAE,CAAC,wBAAwB,CAAC,IAAsB,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC;QAClF,MAAM,oBAAoB,GAAG,CAAC,UAA0B,EAAE,EAAE,CACxD,UAAU,IAAI,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACjD,MAAM,UAAU,GACZ,CAAC,IAC4C,EAAE,EAAE,CAC7C,QAAQ,CAAC,IAAI,CAAC,IAAI,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1D,MAAM,sBAAsB,GAAG,CAAC,UAA0B,EAAE,EAAE,CAC1D,UAAU,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;QACtE,MAAM,YAAY,GACd,CAAC,IAC4C,EAAE,EAAE,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAGxF,oCAAoC;QACpC,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE;YACjC,QAAQ,IAAI,CAAC,IAAI,EAAE;gBACjB,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB;oBACjC,MAAM,gBAAgB,GAAwB,IAAI,CAAC;oBACnD,IAAI,gBAAgB,CAAC,IAAI,EAAE;wBACzB,MAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;wBAC7C,IAAI,UAAU,CAAC,gBAAgB,CAAC,EAAE;4BAChC,MAAM,CAAC,MAAM,CACT,SAAS,EAAE,EAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,YAAY,CAAC,gBAAgB,CAAC,EAAC,CAAC,CAAC;yBACjF;6BAAM;4BACL,MAAM,CAAC,MAAM,CACT,SAAS,EAAE,QAAQ,CAAC,iCAAiC,EAAE,IAAI,EAAE,EAAC,SAAS,EAAC,CAAC,CAAC,CAAC;yBAChF;qBACF;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB;oBACrC,MAAM,oBAAoB,GAA4B,IAAI,CAAC;oBAC3D,IAAI,oBAAoB,CAAC,IAAI,EAAE;wBAC7B,MAAM,aAAa,GAAG,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC;wBACrD,2EAA2E;wBAC3E,MAAM,CAAC,MAAM,CAAC,aAAa,EAAE,EAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC;qBACtE;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;oBACpC,MAAM,mBAAmB,GAA2B,IAAI,CAAC;oBACzD,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,EAAE;wBACpC,kDAAkD;wBAClD,MAAM,QAAQ,GAAG,mBAAmB,CAAC,IAAI,CAAC;wBAC1C,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAI,EAAE;4BAC7B,MAAM,CAAC,MAAM,CACT,QAAQ,CAAC,IAAI,EACb,QAAQ,CACJ,sCAAsC,EAAE,QAAQ,EAAE,EAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAC,CAAC,CAAC,CAAC;yBACnF;qBACF;oBACD,MAAM;aACT;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE;YACjC,QAAQ,IAAI,CAAC,IAAI,EAAE;gBACjB,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;oBAClC,6BAA6B;oBAC7B,MAAM,iBAAiB,GAAyB,IAAI,CAAC;oBACrD,MAAM,EAAC,eAAe,EAAE,YAAY,EAAC,GAAG,iBAAiB,CAAC;oBAE1D,IAAI,CAAC,eAAe,EAAE;wBACpB,oDAAoD;wBACpD,IAAI,YAAY,EAAE;4BAChB,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gCACnC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;gCAC5B,2EAA2E;gCAC3E,yBAAyB;gCACzB,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;oCAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC;oCAChD,MAAM,KAAK,GAAkB,SAAS,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;oCAC9D,IAAI,CAAC,QAAQ;wCAAE,QAAQ,GAAG,EAAE,CAAC;oCAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;iCAC3C;4BACH,CAAC,CAAC,CAAC;yBACJ;qBACF;oBAED,IAAI,eAAe,IAAI,eAAe,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,aAAa,EAAE;wBAC1E,6DAA6D;wBAC7D,qFAAqF;wBACrF,MAAM,IAAI,GAAsB,eAAgB,CAAC,IAAI,CAAC;wBACtD,MAAM,YAAY,GAAyB,EAAC,IAAI,EAAC,CAAC;wBAClD,IAAI,YAAY,EAAE;4BAChB,YAAY,CAAC,MAAM,GAAG,YAAY,CAAC,QAAQ,CAAC,GAAG,CAC3C,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAC,CAAC,CAAC;gCACpD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBACjD;wBACD,IAAI,CAAC,OAAO;4BAAE,OAAO,GAAG,EAAE,CAAC;wBAC3B,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;qBAC5B;oBACD,MAAM;gBACR,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB;oBACjC,MAAM,gBAAgB,GAAwB,IAAI,CAAC;oBACnD,IAAI,gBAAgB,CAAC,IAAI,EAAE;wBACzB,IAAI,UAAU,CAAC,gBAAgB,CAAC,EAAE;4BAChC,MAAM,IAAI,GAAG,YAAY,CAAC,gBAAgB,CAAC,CAAC;4BAC5C,IAAI,IAAI,EAAE;gCACR,IAAI,CAAC,QAAQ;oCAAE,QAAQ,GAAG,EAAE,CAAC;gCAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,gBAAgB,CAAC,CAAC;6BACpD;yBACF;qBACF;oBACD,iDAAiD;oBACjD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB;oBACrC,MAAM,eAAe,GAA4B,IAAI,CAAC;oBACtD,IAAI,eAAe,CAAC,IAAI,IAAI,UAAU,CAAC,eAAe,CAAC,EAAE;wBACvD,MAAM,IAAI,GAAG,YAAY,CAAC,eAAe,CAAC,CAAC;wBAC3C,IAAI,IAAI,EAAE;4BACR,IAAI,CAAC,QAAQ;gCAAE,QAAQ,GAAG,EAAE,CAAC;4BAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAC,UAAU,EAAE,WAAW,EAAC,CAAC;yBAC5C;qBACF;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB;oBACrC,MAAM,oBAAoB,GAA4B,IAAI,CAAC;oBAC3D,IAAI,oBAAoB,CAAC,IAAI,IAAI,UAAU,CAAC,oBAAoB,CAAC,EAAE;wBACjE,MAAM,IAAI,GAAG,YAAY,CAAC,oBAAoB,CAAC,CAAC;wBAChD,IAAI,IAAI,EAAE;4BACR,IAAI,CAAC,QAAQ;gCAAE,QAAQ,GAAG,EAAE,CAAC;4BAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAC,UAAU,EAAE,WAAW,EAAC,CAAC;yBAC5C;qBACF;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;oBACpC,oEAAoE;oBACpE,+DAA+D;oBAC/D,MAAM,mBAAmB,GAA2B,IAAI,CAAC;oBACzD,IAAI,UAAU,CAAC,mBAAmB,CAAC,IAAI,mBAAmB,CAAC,IAAI,EAAE;wBAC/D,MAAM,IAAI,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAC;wBAC/C,MAAM,SAAS,GAAG,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;wBAC9D,IAAI,IAAI,EAAE;4BACR,IAAI,CAAC,QAAQ;gCAAE,QAAQ,GAAG,EAAE,CAAC;4BAC7B,QAAQ,CAAC,IAAI,CAAC;gCACV,SAAS,CAAC,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAC,UAAU,EAAE,UAAU,EAAC,CAAC;yBAC9E;qBACF;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe;oBAChC,MAAM,eAAe,GAAuB,IAAI,CAAC;oBACjD,IAAI,UAAU,CAAC,eAAe,CAAC,EAAE;wBAC/B,MAAM,eAAe,GAAoC,EAAE,CAAC;wBAC5D,MAAM,QAAQ,GAAG,YAAY,CAAC,eAAe,CAAC,CAAC;wBAC/C,IAAI,gBAAgB,GAAkB,CAAC,CAAC;wBACxC,IAAI,cAAc,GAAG,CAAC,CAAC;wBACvB,KAAK,MAAM,MAAM,IAAI,eAAe,CAAC,OAAO,EAAE;4BAC5C,IAAI,SAAwB,CAAC;4BAC7B,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;gCACvB,SAAS,GAAG,gBAAgB,CAAC;6BAC9B;iCAAM;gCACL,SAAS,GAAG,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;6BACxD;4BACD,IAAI,IAAI,GAAqB,SAAS,CAAC;4BACvC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE;gCAChD,MAAM,UAAU,GAAkB,MAAM,CAAC,IAAI,CAAC;gCAC9C,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;gCACvB,eAAe,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;gCAClC,cAAc,EAAE,CAAC;6BAClB;4BACD,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;gCACjC,gBAAgB,GAAG,SAAS,GAAG,CAAC,CAAC;6BAClC;iCAAM,IAAI,IAAI,EAAE;gCACf,gBAAgB,GAAG;oCACjB,UAAU,EAAE,QAAQ;oCACpB,QAAQ,EAAE,GAAG;oCACb,IAAI,EAAE;wCACJ,UAAU,EAAE,QAAQ;wCACpB,UAAU,EAAE,WAAW,CAAC,EAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAC,EAAE,IAAI,CAAC,EAAE,IAAI;qCAC/E;iCACF,CAAC;6BACH;iCAAM;gCACL,gBAAgB;oCACZ,WAAW,CAAC,QAAQ,CAAC,8BAA8B,EAAE,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;6BAC9E;yBACF;wBACD,IAAI,cAAc,EAAE;4BAClB,IAAI,QAAQ,EAAE;gCACZ,IAAI,CAAC,QAAQ;oCAAE,QAAQ,GAAG,EAAE,CAAC;gCAC7B,QAAQ,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;6BACzD;yBACF;qBACF;oBACD,MAAM;gBAER,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;oBAClC,MAAM,iBAAiB,GAAyB,IAAI,CAAC;oBACrD,KAAK,MAAM,mBAAmB,IAAI,iBAAiB,CAAC,eAAe,CAAC,YAAY,EAAE;wBAChF,IAAI,mBAAmB,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE;4BAC7D,MAAM,QAAQ,GAAkB,mBAAmB,CAAC,IAAI,CAAC;4BACzD,IAAI,QAAuB,CAAC;4BAC5B,IAAI,mBAAmB,CAAC,WAAW,EAAE;gCACnC,QAAQ,GAAG,SAAS,CAAC,YAAY,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;6BACpE;iCAAM;gCACL,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;6BAClF;4BACD,IAAI,QAAQ,GAAG,KAAK,CAAC;4BACrB,IAAI,QAAQ,CAAC,iBAAiB,CAAC,IAAI,QAAQ,CAAC,mBAAmB,CAAC;gCAC5D,oBAAoB,CAAC,QAAQ,CAAC,EAAE;gCAClC,MAAM,IAAI,GAAG,sBAAsB,CAAC,QAAQ,CAAC,CAAC;gCAC9C,IAAI,IAAI,EAAE;oCACR,IAAI,CAAC,QAAQ;wCAAE,QAAQ,GAAG,EAAE,CAAC;oCAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;iCAC9C;gCACD,QAAQ,GAAG,IAAI,CAAC;6BACjB;4BACD,IAAI,OAAO,QAAQ,IAAI,QAAQ,IAAI,OAAO,QAAQ,IAAI,QAAQ;gCAC1D,OAAO,QAAQ,IAAI,SAAS,EAAE;gCAChC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gCACvC,IAAI,QAAQ,EAAE;oCACZ,MAAM,CAAC,eAAe,CAClB,QAAQ,CAAC,IAAI,EAAE,EAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAC,CAAC,CAAC;iCACpE;6BACF;iCAAM,IAAI,CAAC,QAAQ,EAAE;gCACpB,IAAI,QAAQ,IAAI,CAAC,wBAAe,CAAC,QAAQ,CAAC,EAAE;oCAC1C,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;iCAC3D;qCAAM;oCACL,MAAM,CAAC,MAAM,CACT,QAAQ,CAAC,IAAI,EACb,WAAW,CACP,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,EAAE,EAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAC,CAAC,EACxE,IAAI,CAAC,CAAC,CAAC;iCAChB;6BACF;yBACF;6BAAM;4BACL,6DAA6D;4BAC7D,sDAAsD;4BACtD,OAAO;4BACP,qDAAqD;4BACrD,qBAAqB;4BACrB,MAAM,MAAM,GAAgC,CAAC,QAAiB,EAAE,EAAE;gCAChE,QAAQ,QAAQ,CAAC,IAAI,EAAE;oCACrB,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU;wCAC3B,MAAM,IAAI,GAAkB,QAAQ,CAAC;wCACrC,MAAM,QAAQ,GAAG,QAAQ,CAAC,6BAA6B,EAAE,IAAI,CAAC,CAAC;wCAC/D,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;wCACnC,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;4CAClB,IAAI,CAAC,QAAQ;gDAAE,QAAQ,GAAG,EAAE,CAAC;4CAC7B,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;yCAChC;wCACD,MAAM;oCACR,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;wCAC/B,MAAM,cAAc,GAAsB,QAAQ,CAAC;wCACnD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;wCAC5B,MAAM;oCACR,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC;oCACxC,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;wCACpC,MAAM,QAAQ,GAAsB,QAAQ,CAAC;wCAC5C,QAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;wCAC3C,MAAM;iCACT;4BACH,CAAC,CAAC;4BACF,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;yBAClC;qBACF;oBACD,MAAM;aACT;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,QAAQ,IAAI,OAAO,EAAE;YACvB,IAAI,CAAC,QAAQ;gBACX,QAAQ,GAAG,EAAE,CAAC;iBACX,IAAI,MAAM,EAAE;gBACf,gBAAgB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;aACjD;YACD,MAAM,MAAM,GAAmB;gBAC7B,UAAU,EAAE,QAAQ;gBACpB,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,yBAAgB,EAAE,QAAQ;aAC5D,CAAC;YACF,IAAI,UAAU,CAAC,UAAU;gBAAE,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC,UAAU,CAAC;YACnE,IAAI,OAAO;gBAAE,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;YACtC,OAAO,MAAM,CAAC;SACf;IACH,CAAC;CACF;AAngBD,8CAmgBC;AAED,sEAAsE;AACtE,SAAS,gBAAgB,CACrB,UAAyB,EAAE,OAAoC,EAC/D,QAAyC;IAC3C,IAAI,MAAM,GAAgB,IAAI,GAAG,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;IAEhG,SAAS,kBAAkB,CACvB,UAAsE;QACxE,IAAI,CAAC,UAAU,EAAE;YACf,OAAO;SACR;aAAM,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YACpC,UAAU,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;SACxC;aAAM,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;YACrF,MAAM,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,kBAAkB,CAAO,UAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAC/F;aAAM,IAAI,wBAAe,CAAC,UAAU,CAAC,EAAE;YACtC,WAAW,CAAC,UAAU,CAAC,CAAC;SACzB;aAAM,IAAI,4CAAmC,CAAC,UAAU,CAAC,EAAE;YAC1D,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gBAChC,MAAM,SAAS,GAAkB,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBAC3D,IAAI,SAAS,EAAE;oBACb,kBAAkB,CAAC,SAAS,CAAC,CAAC;iBAC/B;aACF;SACF;aAAM,IAAI,2BAAkB,CAAC,UAAU,CAAC,EAAE;YACzC,gBAAgB,CAAM,UAAU,CAAC,CAAC;SACnC;aAAM,IAAI,qCAA4B,CAAC,UAAU,CAAC,EAAE;YACnD,QAAQ,UAAU,CAAC,UAAU,EAAE;gBAC7B,KAAK,QAAQ;oBACX,MAAM,gBAAgB,GAAqC,UAAU,CAAC;oBACtE,kBAAkB,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;oBAC1C,kBAAkB,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;oBAC3C,MAAM;gBACR,KAAK,MAAM,CAAC;gBACZ,KAAK,KAAK;oBACR,MAAM,cAAc,GAAmC,UAAU,CAAC;oBAClE,kBAAkB,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;oBAC9C,IAAI,cAAc,CAAC,SAAS;wBAAE,cAAc,CAAC,SAAS,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;oBACnF,MAAM;gBACR,KAAK,OAAO;oBACV,MAAM,eAAe,GAAoC,UAAU,CAAC;oBACpE,kBAAkB,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;oBAC/C,kBAAkB,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;oBAC1C,MAAM;gBACR,KAAK,KAAK;oBACR,MAAM,gBAAgB,GAAqC,UAAU,CAAC;oBACtE,kBAAkB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;oBAC7C,MAAM;gBACR,KAAK,QAAQ;oBACX,MAAM,gBAAgB,GAAqC,UAAU,CAAC;oBACtE,kBAAkB,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;oBAChD,MAAM;gBACR,KAAK,QAAQ;oBACX,MAAM,gBAAgB,GAAqC,UAAU,CAAC;oBACtE,kBAAkB,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;oBAChD,MAAM;gBACR,KAAK,IAAI;oBACP,MAAM,YAAY,GAAiC,UAAU,CAAC;oBAC9D,kBAAkB,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;oBAC3C,kBAAkB,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC;oBAChD,kBAAkB,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC;oBAChD,MAAM;aACT;SACF;IACH,CAAC;IAED,SAAS,cAAc,CAAC,SAAwB,EAAE,MAAsB;QACtE,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;SAC/C;QACD,IAAI,yBAAgB,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,mBAAmB,EAAE;YAC1D,MAAM,CAAC,mBAAmB,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;SACxD;QACD,kFAAkF;QAClF,IAAI,SAAS,CAAC,UAAU,IAAI,8BAAqB,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE;YAC9E,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;SAC/C;IACH,CAAC;IAED,SAAS,aAAa,CAAC,SAAwB;QAC7C,IAAI,SAAS,CAAC,UAAU,EAAE;YACxB,SAAS,CAAC,UAAU,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;SAClD;QACD,IAAI,SAAS,CAAC,OAAO,EAAE;YACrB,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,OAAO,CAAC;iBACxC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,OAAS,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SAC9F;QACD,IAAI,SAAS,CAAC,OAAO,EAAE;YACrB,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC3D,MAAM,YAAY,GAAG,SAAS,CAAC,OAAS,CAAC,IAAI,CAAC,CAAC;gBAC/C,IAAI,2BAAkB,CAAC,YAAY,CAAC,EAAE;oBACpC,kBAAkB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;iBACxC;qBAAM;oBACL,kBAAkB,CAAC,YAAY,CAAC,CAAC;iBAClC;YACH,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED,SAAS,gBAAgB,CAAC,mBAAqC;QAC7D,IAAI,mBAAmB,CAAC,KAAK,EAAE;YAC7B,MAAM,SAAS,GAAG,MAAM,CAAC;YACzB,IAAI,mBAAmB,CAAC,UAAU,EAAE;gBAClC,MAAM,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;gBACrC,IAAI,mBAAmB,CAAC,UAAU;oBAChC,mBAAmB,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aAC9D;YACD,kBAAkB,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;YAC9C,MAAM,GAAG,SAAS,CAAC;SACpB;IACH,CAAC;IAED,SAAS,gBAAgB,CAAC,IAAyB;QACjD,IAAI,IAAI,EAAE;YACR,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClC,OAAO,CAAC,CACJ,IAAI,CAAC,GAAG,IAAI,SAAS;gBACrB,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;SAC9E;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,SAAS,WAAW,CAAC,KAAoB;QACvC,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAChC,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;YAC1B,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC;gBACtC,KAAK,CAAC,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,CAAC,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC;oBAC7C,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC;gBACrD,EAAE,CAAC;YACP,MAAM,IAAI,KAAK,CACX,GAAG,UAAU,CAAC,QAAQ,GAAG,QAAQ,4EAA4E,eAAe,CAAC,KAAK,CAAC,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SACzK;IACH,CAAC;IAED,MAAM,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QAClD,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI;YACF,IAAI,wBAAe,CAAC,KAAK,CAAC,EAAE;gBAC1B,aAAa,CAAC,KAAK,CAAC,CAAC;aACtB;SACF;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAChC,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBAC1B,IAAI,IAAI,EAAE;oBACR,MAAM,EAAC,IAAI,EAAE,SAAS,EAAC,GAAG,UAAU,CAAC,6BAA6B,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;oBACpF,MAAM,IAAI,KAAK,CACX,GAAG,UAAU,CAAC,QAAQ,IAAI,IAAI,GAAG,CAAC,IAAI,SAAS,GAAG,CAAC,kEAAkE,IAAI,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;iBACpJ;gBACD,MAAM,IAAI,KAAK,CACX,+DAA+D,IAAI,QAAQ,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;aAC7F;SACF;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,2CAA2C;AAC3C,SAAS,OAAO,CAAC,UAAiD;IAChE,MAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,SAAS,UAAU,CAAC,IAAuC;QACzD,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE;YACzC,MAAM,UAAU,GAAkB,IAAI,CAAC;YACvC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SAC9B;aAAM;YACL,MAAM,cAAc,GAAsB,IAAI,CAAC;YAC/C,KAAK,MAAM,OAAO,IAAI,cAAc,CAAC,QAAQ,EAAE;gBAC7C,MAAM,IAAI,GAAI,OAAe,CAAC,IAAI,CAAC;gBACnC,IAAI,IAAI,EAAE;oBACR,UAAU,CAAC,IAAI,CAAC,CAAC;iBAClB;aACF;SACF;IACH,CAAC;IAED,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;QAClC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KAC5B;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,eAAe,CAAC,KAAU;IACjC,QAAQ,KAAK,CAAC,OAAO,EAAE;QACrB,KAAK,iCAAiC;YACpC,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE;gBAC5C,OAAO,qCAAqC,KAAK,CAAC,OAAO,CAAC,SAAS,gCAAgC,CAAC;aACrG;YACD,MAAM;QACR,KAAK,0BAA0B;YAC7B,OAAO,kIAAkI,CAAC;QAC5I,KAAK,6BAA6B;YAChC,OAAO,uJAAuJ,CAAC;QACjK,KAAK,wBAAwB;YAC3B,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE;gBAC3C,OAAO,0BAA0B,KAAK,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;aAC3D;YACD,MAAM;QACR,KAAK,6BAA6B;YAChC,IAAI,MAAM,GACN,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,qBAAqB,KAAK,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;YAC9F,OAAO,MAAM;gBACT,qHAAqH,CAAC;QAC5H,KAAK,6BAA6B;YAChC,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE;gBACvC,OAAO,+CAA+C,KAAK,CAAC,OAAO,CAAC,IAAI,kCAAkC,CAAC;aAC5G;KACJ;IACD,OAAO,KAAK,CAAC,OAAO,CAAC;AACvB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Evaluator, errorSymbol, recordMapEntry} from './evaluator';\nimport {ClassMetadata, ConstructorMetadata, FunctionMetadata, InterfaceMetadata, METADATA_VERSION, MemberMetadata, MetadataEntry, MetadataError, MetadataMap, MetadataSymbolicBinaryExpression, MetadataSymbolicCallExpression, MetadataSymbolicExpression, MetadataSymbolicIfExpression, MetadataSymbolicIndexExpression, MetadataSymbolicPrefixExpression, MetadataSymbolicReferenceExpression, MetadataSymbolicSelectExpression, MetadataSymbolicSpreadExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSelectExpression, isMethodMetadata} from './schema';\nimport {Symbols} from './symbols';\n\nconst isStatic = (node: ts.Declaration) =>\n    ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Static;\n\n/**\n * A set of collector options to use when collecting metadata.\n */\nexport interface CollectorOptions {\n  /**\n   * Version of the metadata to collect.\n   */\n  version?: number;\n\n  /**\n   * Collect a hidden field \"$quoted$\" in objects literals that record when the key was quoted in\n   * the source.\n   */\n  quotedNames?: boolean;\n\n  /**\n   * Do not simplify invalid expressions.\n   */\n  verboseInvalidExpression?: boolean;\n\n  /**\n   * An expression substitution callback.\n   */\n  substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue;\n}\n\n/**\n * Collect decorator metadata from a TypeScript module.\n */\nexport class MetadataCollector {\n  constructor(private options: CollectorOptions = {}) {}\n\n  /**\n   * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\n   * the source file that is expected to correspond to a module.\n   */\n  public getMetadata(\n      sourceFile: ts.SourceFile, strict: boolean = false,\n      substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue): ModuleMetadata\n      |undefined {\n    const locals = new Symbols(sourceFile);\n    const nodeMap =\n        new Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>();\n    const composedSubstituter = substituteExpression && this.options.substituteExpression ?\n        (value: MetadataValue, node: ts.Node) =>\n            this.options.substituteExpression !(substituteExpression(value, node), node) :\n        substituteExpression;\n    const evaluatorOptions = substituteExpression ?\n        {...this.options, substituteExpression: composedSubstituter} :\n        this.options;\n    let metadata: {[name: string]: MetadataValue | ClassMetadata | FunctionMetadata}|undefined;\n    const evaluator = new Evaluator(locals, nodeMap, evaluatorOptions, (name, value) => {\n      if (!metadata) metadata = {};\n      metadata[name] = value;\n    });\n    let exports: ModuleExportMetadata[]|undefined = undefined;\n\n    function objFromDecorator(decoratorNode: ts.Decorator): MetadataSymbolicExpression {\n      return <MetadataSymbolicExpression>evaluator.evaluateNode(decoratorNode.expression);\n    }\n\n    function recordEntry<T extends MetadataEntry>(entry: T, node: ts.Node): T {\n      if (composedSubstituter) {\n        entry = composedSubstituter(entry as MetadataValue, node) as T;\n      }\n      return recordMapEntry(entry, node, nodeMap, sourceFile);\n    }\n\n    function errorSym(\n        message: string, node?: ts.Node, context?: {[name: string]: string}): MetadataError {\n      return errorSymbol(message, node, context, sourceFile);\n    }\n\n    function maybeGetSimpleFunction(\n        functionDeclaration: ts.FunctionDeclaration |\n        ts.MethodDeclaration): {func: FunctionMetadata, name: string}|undefined {\n      if (functionDeclaration.name && functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n        const nameNode = <ts.Identifier>functionDeclaration.name;\n        const functionName = nameNode.text;\n        const functionBody = functionDeclaration.body;\n        if (functionBody && functionBody.statements.length == 1) {\n          const statement = functionBody.statements[0];\n          if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n            const returnStatement = <ts.ReturnStatement>statement;\n            if (returnStatement.expression) {\n              const func: FunctionMetadata = {\n                __symbolic: 'function',\n                parameters: namesOf(functionDeclaration.parameters),\n                value: evaluator.evaluateNode(returnStatement.expression)\n              };\n              if (functionDeclaration.parameters.some(p => p.initializer != null)) {\n                func.defaults = functionDeclaration.parameters.map(\n                    p => p.initializer && evaluator.evaluateNode(p.initializer));\n              }\n              return recordEntry({func, name: functionName}, functionDeclaration);\n            }\n          }\n        }\n      }\n    }\n\n    function classMetadataOf(classDeclaration: ts.ClassDeclaration): ClassMetadata {\n      const result: ClassMetadata = {__symbolic: 'class'};\n\n      function getDecorators(decorators: ReadonlyArray<ts.Decorator>| undefined):\n          MetadataSymbolicExpression[]|undefined {\n        if (decorators && decorators.length)\n          return decorators.map(decorator => objFromDecorator(decorator));\n        return undefined;\n      }\n\n      function referenceFrom(node: ts.Node): MetadataSymbolicReferenceExpression|MetadataError|\n          MetadataSymbolicSelectExpression {\n        const result = evaluator.evaluateNode(node);\n        if (isMetadataError(result) || isMetadataSymbolicReferenceExpression(result) ||\n            isMetadataSymbolicSelectExpression(result)) {\n          return result;\n        } else {\n          return errorSym('Symbol reference expected', node);\n        }\n      }\n\n      // Add class parents\n      if (classDeclaration.heritageClauses) {\n        classDeclaration.heritageClauses.forEach((hc) => {\n          if (hc.token === ts.SyntaxKind.ExtendsKeyword && hc.types) {\n            hc.types.forEach(type => result.extends = referenceFrom(type.expression));\n          }\n        });\n      }\n\n      // Add arity if the type is generic\n      const typeParameters = classDeclaration.typeParameters;\n      if (typeParameters && typeParameters.length) {\n        result.arity = typeParameters.length;\n      }\n\n      // Add class decorators\n      if (classDeclaration.decorators) {\n        result.decorators = getDecorators(classDeclaration.decorators);\n      }\n\n      // member decorators\n      let members: MetadataMap|null = null;\n      function recordMember(name: string, metadata: MemberMetadata) {\n        if (!members) members = {};\n        const data = members.hasOwnProperty(name) ? members[name] : [];\n        data.push(metadata);\n        members[name] = data;\n      }\n\n      // static member\n      let statics: {[name: string]: MetadataValue | FunctionMetadata}|null = null;\n      function recordStaticMember(name: string, value: MetadataValue | FunctionMetadata) {\n        if (!statics) statics = {};\n        statics[name] = value;\n      }\n\n      for (const member of classDeclaration.members) {\n        let isConstructor = false;\n        switch (member.kind) {\n          case ts.SyntaxKind.Constructor:\n          case ts.SyntaxKind.MethodDeclaration:\n            isConstructor = member.kind === ts.SyntaxKind.Constructor;\n            const method = <ts.MethodDeclaration|ts.ConstructorDeclaration>member;\n            if (isStatic(method)) {\n              const maybeFunc = maybeGetSimpleFunction(<ts.MethodDeclaration>method);\n              if (maybeFunc) {\n                recordStaticMember(maybeFunc.name, maybeFunc.func);\n              }\n              continue;\n            }\n            const methodDecorators = getDecorators(method.decorators);\n            const parameters = method.parameters;\n            const parameterDecoratorData:\n                ((MetadataSymbolicExpression | MetadataError)[] | undefined)[] = [];\n            const parametersData:\n                (MetadataSymbolicReferenceExpression | MetadataError |\n                 MetadataSymbolicSelectExpression | null)[] = [];\n            let hasDecoratorData: boolean = false;\n            let hasParameterData: boolean = false;\n            for (const parameter of parameters) {\n              const parameterData = getDecorators(parameter.decorators);\n              parameterDecoratorData.push(parameterData);\n              hasDecoratorData = hasDecoratorData || !!parameterData;\n              if (isConstructor) {\n                if (parameter.type) {\n                  parametersData.push(referenceFrom(parameter.type));\n                } else {\n                  parametersData.push(null);\n                }\n                hasParameterData = true;\n              }\n            }\n            const data: MethodMetadata = {__symbolic: isConstructor ? 'constructor' : 'method'};\n            const name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);\n            if (methodDecorators) {\n              data.decorators = methodDecorators;\n            }\n            if (hasDecoratorData) {\n              data.parameterDecorators = parameterDecoratorData;\n            }\n            if (hasParameterData) {\n              (<ConstructorMetadata>data).parameters = parametersData;\n            }\n            if (!isMetadataError(name)) {\n              recordMember(name, data);\n            }\n            break;\n          case ts.SyntaxKind.PropertyDeclaration:\n          case ts.SyntaxKind.GetAccessor:\n          case ts.SyntaxKind.SetAccessor:\n            const property = <ts.PropertyDeclaration>member;\n            if (isStatic(property)) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name)) {\n                if (property.initializer) {\n                  const value = evaluator.evaluateNode(property.initializer);\n                  recordStaticMember(name, value);\n                } else {\n                  recordStaticMember(name, errorSym('Variable not initialized', property.name));\n                }\n              }\n            }\n            const propertyDecorators = getDecorators(property.decorators);\n            if (propertyDecorators) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name)) {\n                recordMember(name, {__symbolic: 'property', decorators: propertyDecorators});\n              }\n            }\n            break;\n        }\n      }\n      if (members) {\n        result.members = members;\n      }\n      if (statics) {\n        result.statics = statics;\n      }\n\n      return recordEntry(result, classDeclaration);\n    }\n\n    // Collect all exported symbols from an exports clause.\n    const exportMap = new Map<string, string>();\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ExportDeclaration:\n          const exportDeclaration = <ts.ExportDeclaration>node;\n          const {moduleSpecifier, exportClause} = exportDeclaration;\n\n          if (!moduleSpecifier) {\n            // If there is a module specifier there is also an exportClause\n            exportClause !.elements.forEach(spec => {\n              const exportedAs = spec.name.text;\n              const name = (spec.propertyName || spec.name).text;\n              exportMap.set(name, exportedAs);\n            });\n          }\n      }\n    });\n\n    const isExport = (node: ts.Node) => sourceFile.isDeclarationFile ||\n        ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export;\n    const isExportedIdentifier = (identifier?: ts.Identifier) =>\n        identifier && exportMap.has(identifier.text);\n    const isExported =\n        (node: ts.FunctionDeclaration | ts.ClassDeclaration | ts.TypeAliasDeclaration |\n         ts.InterfaceDeclaration | ts.EnumDeclaration) =>\n            isExport(node) || isExportedIdentifier(node.name);\n    const exportedIdentifierName = (identifier?: ts.Identifier) =>\n        identifier && (exportMap.get(identifier.text) || identifier.text);\n    const exportedName =\n        (node: ts.FunctionDeclaration | ts.ClassDeclaration | ts.InterfaceDeclaration |\n         ts.TypeAliasDeclaration | ts.EnumDeclaration) => exportedIdentifierName(node.name);\n\n\n    // Pre-declare classes and functions\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          if (classDeclaration.name) {\n            const className = classDeclaration.name.text;\n            if (isExported(classDeclaration)) {\n              locals.define(\n                  className, {__symbolic: 'reference', name: exportedName(classDeclaration)});\n            } else {\n              locals.define(\n                  className, errorSym('Reference to non-exported class', node, {className}));\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n          if (interfaceDeclaration.name) {\n            const interfaceName = interfaceDeclaration.name.text;\n            // All references to interfaces should be converted to references to `any`.\n            locals.define(interfaceName, {__symbolic: 'reference', name: 'any'});\n          }\n          break;\n\n        case ts.SyntaxKind.FunctionDeclaration:\n          const functionDeclaration = <ts.FunctionDeclaration>node;\n          if (!isExported(functionDeclaration)) {\n            // Report references to this function as an error.\n            const nameNode = functionDeclaration.name;\n            if (nameNode && nameNode.text) {\n              locals.define(\n                  nameNode.text,\n                  errorSym(\n                      'Reference to a non-exported function', nameNode, {name: nameNode.text}));\n            }\n          }\n          break;\n      }\n    });\n\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ExportDeclaration:\n          // Record export declarations\n          const exportDeclaration = <ts.ExportDeclaration>node;\n          const {moduleSpecifier, exportClause} = exportDeclaration;\n\n          if (!moduleSpecifier) {\n            // no module specifier -> export {propName as name};\n            if (exportClause) {\n              exportClause.elements.forEach(spec => {\n                const name = spec.name.text;\n                // If the symbol was not already exported, export a reference since it is a\n                // reference to an import\n                if (!metadata || !metadata[name]) {\n                  const propNode = spec.propertyName || spec.name;\n                  const value: MetadataValue = evaluator.evaluateNode(propNode);\n                  if (!metadata) metadata = {};\n                  metadata[name] = recordEntry(value, node);\n                }\n              });\n            }\n          }\n\n          if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {\n            // Ignore exports that don't have string literals as exports.\n            // This is allowed by the syntax but will be flagged as an error by the type checker.\n            const from = (<ts.StringLiteral>moduleSpecifier).text;\n            const moduleExport: ModuleExportMetadata = {from};\n            if (exportClause) {\n              moduleExport.export = exportClause.elements.map(\n                  spec => spec.propertyName ? {name: spec.propertyName.text, as: spec.name.text} :\n                                              spec.name.text);\n            }\n            if (!exports) exports = [];\n            exports.push(moduleExport);\n          }\n          break;\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          if (classDeclaration.name) {\n            if (isExported(classDeclaration)) {\n              const name = exportedName(classDeclaration);\n              if (name) {\n                if (!metadata) metadata = {};\n                metadata[name] = classMetadataOf(classDeclaration);\n              }\n            }\n          }\n          // Otherwise don't record metadata for the class.\n          break;\n\n        case ts.SyntaxKind.TypeAliasDeclaration:\n          const typeDeclaration = <ts.TypeAliasDeclaration>node;\n          if (typeDeclaration.name && isExported(typeDeclaration)) {\n            const name = exportedName(typeDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              metadata[name] = {__symbolic: 'interface'};\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n          if (interfaceDeclaration.name && isExported(interfaceDeclaration)) {\n            const name = exportedName(interfaceDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              metadata[name] = {__symbolic: 'interface'};\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.FunctionDeclaration:\n          // Record functions that return a single value. Record the parameter\n          // names substitution will be performed by the StaticReflector.\n          const functionDeclaration = <ts.FunctionDeclaration>node;\n          if (isExported(functionDeclaration) && functionDeclaration.name) {\n            const name = exportedName(functionDeclaration);\n            const maybeFunc = maybeGetSimpleFunction(functionDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              metadata[name] =\n                  maybeFunc ? recordEntry(maybeFunc.func, node) : {__symbolic: 'function'};\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.EnumDeclaration:\n          const enumDeclaration = <ts.EnumDeclaration>node;\n          if (isExported(enumDeclaration)) {\n            const enumValueHolder: {[name: string]: MetadataValue} = {};\n            const enumName = exportedName(enumDeclaration);\n            let nextDefaultValue: MetadataValue = 0;\n            let writtenMembers = 0;\n            for (const member of enumDeclaration.members) {\n              let enumValue: MetadataValue;\n              if (!member.initializer) {\n                enumValue = nextDefaultValue;\n              } else {\n                enumValue = evaluator.evaluateNode(member.initializer);\n              }\n              let name: string|undefined = undefined;\n              if (member.name.kind == ts.SyntaxKind.Identifier) {\n                const identifier = <ts.Identifier>member.name;\n                name = identifier.text;\n                enumValueHolder[name] = enumValue;\n                writtenMembers++;\n              }\n              if (typeof enumValue === 'number') {\n                nextDefaultValue = enumValue + 1;\n              } else if (name) {\n                nextDefaultValue = {\n                  __symbolic: 'binary',\n                  operator: '+',\n                  left: {\n                    __symbolic: 'select',\n                    expression: recordEntry({__symbolic: 'reference', name: enumName}, node), name\n                  }\n                };\n              } else {\n                nextDefaultValue =\n                    recordEntry(errorSym('Unsupported enum member name', member.name), node);\n              }\n            }\n            if (writtenMembers) {\n              if (enumName) {\n                if (!metadata) metadata = {};\n                metadata[enumName] = recordEntry(enumValueHolder, node);\n              }\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.VariableStatement:\n          const variableStatement = <ts.VariableStatement>node;\n          for (const variableDeclaration of variableStatement.declarationList.declarations) {\n            if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n              const nameNode = <ts.Identifier>variableDeclaration.name;\n              let varValue: MetadataValue;\n              if (variableDeclaration.initializer) {\n                varValue = evaluator.evaluateNode(variableDeclaration.initializer);\n              } else {\n                varValue = recordEntry(errorSym('Variable not initialized', nameNode), nameNode);\n              }\n              let exported = false;\n              if (isExport(variableStatement) || isExport(variableDeclaration) ||\n                  isExportedIdentifier(nameNode)) {\n                const name = exportedIdentifierName(nameNode);\n                if (name) {\n                  if (!metadata) metadata = {};\n                  metadata[name] = recordEntry(varValue, node);\n                }\n                exported = true;\n              }\n              if (typeof varValue == 'string' || typeof varValue == 'number' ||\n                  typeof varValue == 'boolean') {\n                locals.define(nameNode.text, varValue);\n                if (exported) {\n                  locals.defineReference(\n                      nameNode.text, {__symbolic: 'reference', name: nameNode.text});\n                }\n              } else if (!exported) {\n                if (varValue && !isMetadataError(varValue)) {\n                  locals.define(nameNode.text, recordEntry(varValue, node));\n                } else {\n                  locals.define(\n                      nameNode.text,\n                      recordEntry(\n                          errorSym('Reference to a local symbol', nameNode, {name: nameNode.text}),\n                          node));\n                }\n              }\n            } else {\n              // Destructuring (or binding) declarations are not supported,\n              // var {<identifier>[, <identifier>]+} = <expression>;\n              //   or\n              // var [<identifier>[, <identifier}+] = <expression>;\n              // are not supported.\n              const report: (nameNode: ts.Node) => void = (nameNode: ts.Node) => {\n                switch (nameNode.kind) {\n                  case ts.SyntaxKind.Identifier:\n                    const name = <ts.Identifier>nameNode;\n                    const varValue = errorSym('Destructuring not supported', name);\n                    locals.define(name.text, varValue);\n                    if (isExport(node)) {\n                      if (!metadata) metadata = {};\n                      metadata[name.text] = varValue;\n                    }\n                    break;\n                  case ts.SyntaxKind.BindingElement:\n                    const bindingElement = <ts.BindingElement>nameNode;\n                    report(bindingElement.name);\n                    break;\n                  case ts.SyntaxKind.ObjectBindingPattern:\n                  case ts.SyntaxKind.ArrayBindingPattern:\n                    const bindings = <ts.BindingPattern>nameNode;\n                    (bindings as any).elements.forEach(report);\n                    break;\n                }\n              };\n              report(variableDeclaration.name);\n            }\n          }\n          break;\n      }\n    });\n\n    if (metadata || exports) {\n      if (!metadata)\n        metadata = {};\n      else if (strict) {\n        validateMetadata(sourceFile, nodeMap, metadata);\n      }\n      const result: ModuleMetadata = {\n        __symbolic: 'module',\n        version: this.options.version || METADATA_VERSION, metadata\n      };\n      if (sourceFile.moduleName) result.importAs = sourceFile.moduleName;\n      if (exports) result.exports = exports;\n      return result;\n    }\n  }\n}\n\n// This will throw if the metadata entry given contains an error node.\nfunction validateMetadata(\n    sourceFile: ts.SourceFile, nodeMap: Map<MetadataEntry, ts.Node>,\n    metadata: {[name: string]: MetadataEntry}) {\n  let locals: Set<string> = new Set(['Array', 'Object', 'Set', 'Map', 'string', 'number', 'any']);\n\n  function validateExpression(\n      expression: MetadataValue | MetadataSymbolicExpression | MetadataError) {\n    if (!expression) {\n      return;\n    } else if (Array.isArray(expression)) {\n      expression.forEach(validateExpression);\n    } else if (typeof expression === 'object' && !expression.hasOwnProperty('__symbolic')) {\n      Object.getOwnPropertyNames(expression).forEach(v => validateExpression((<any>expression)[v]));\n    } else if (isMetadataError(expression)) {\n      reportError(expression);\n    } else if (isMetadataGlobalReferenceExpression(expression)) {\n      if (!locals.has(expression.name)) {\n        const reference = <MetadataValue>metadata[expression.name];\n        if (reference) {\n          validateExpression(reference);\n        }\n      }\n    } else if (isFunctionMetadata(expression)) {\n      validateFunction(<any>expression);\n    } else if (isMetadataSymbolicExpression(expression)) {\n      switch (expression.__symbolic) {\n        case 'binary':\n          const binaryExpression = <MetadataSymbolicBinaryExpression>expression;\n          validateExpression(binaryExpression.left);\n          validateExpression(binaryExpression.right);\n          break;\n        case 'call':\n        case 'new':\n          const callExpression = <MetadataSymbolicCallExpression>expression;\n          validateExpression(callExpression.expression);\n          if (callExpression.arguments) callExpression.arguments.forEach(validateExpression);\n          break;\n        case 'index':\n          const indexExpression = <MetadataSymbolicIndexExpression>expression;\n          validateExpression(indexExpression.expression);\n          validateExpression(indexExpression.index);\n          break;\n        case 'pre':\n          const prefixExpression = <MetadataSymbolicPrefixExpression>expression;\n          validateExpression(prefixExpression.operand);\n          break;\n        case 'select':\n          const selectExpression = <MetadataSymbolicSelectExpression>expression;\n          validateExpression(selectExpression.expression);\n          break;\n        case 'spread':\n          const spreadExpression = <MetadataSymbolicSpreadExpression>expression;\n          validateExpression(spreadExpression.expression);\n          break;\n        case 'if':\n          const ifExpression = <MetadataSymbolicIfExpression>expression;\n          validateExpression(ifExpression.condition);\n          validateExpression(ifExpression.elseExpression);\n          validateExpression(ifExpression.thenExpression);\n          break;\n      }\n    }\n  }\n\n  function validateMember(classData: ClassMetadata, member: MemberMetadata) {\n    if (member.decorators) {\n      member.decorators.forEach(validateExpression);\n    }\n    if (isMethodMetadata(member) && member.parameterDecorators) {\n      member.parameterDecorators.forEach(validateExpression);\n    }\n    // Only validate parameters of classes for which we know that are used with our DI\n    if (classData.decorators && isConstructorMetadata(member) && member.parameters) {\n      member.parameters.forEach(validateExpression);\n    }\n  }\n\n  function validateClass(classData: ClassMetadata) {\n    if (classData.decorators) {\n      classData.decorators.forEach(validateExpression);\n    }\n    if (classData.members) {\n      Object.getOwnPropertyNames(classData.members)\n          .forEach(name => classData.members ![name].forEach((m) => validateMember(classData, m)));\n    }\n    if (classData.statics) {\n      Object.getOwnPropertyNames(classData.statics).forEach(name => {\n        const staticMember = classData.statics ![name];\n        if (isFunctionMetadata(staticMember)) {\n          validateExpression(staticMember.value);\n        } else {\n          validateExpression(staticMember);\n        }\n      });\n    }\n  }\n\n  function validateFunction(functionDeclaration: FunctionMetadata) {\n    if (functionDeclaration.value) {\n      const oldLocals = locals;\n      if (functionDeclaration.parameters) {\n        locals = new Set(oldLocals.values());\n        if (functionDeclaration.parameters)\n          functionDeclaration.parameters.forEach(n => locals.add(n));\n      }\n      validateExpression(functionDeclaration.value);\n      locals = oldLocals;\n    }\n  }\n\n  function shouldReportNode(node: ts.Node | undefined) {\n    if (node) {\n      const nodeStart = node.getStart();\n      return !(\n          node.pos != nodeStart &&\n          sourceFile.text.substring(node.pos, nodeStart).indexOf('@dynamic') >= 0);\n    }\n    return true;\n  }\n\n  function reportError(error: MetadataError) {\n    const node = nodeMap.get(error);\n    if (shouldReportNode(node)) {\n      const lineInfo = error.line != undefined ?\n          error.character != undefined ? `:${error.line + 1}:${error.character + 1}` :\n                                         `:${error.line + 1}` :\n          '';\n      throw new Error(\n          `${sourceFile.fileName}${lineInfo}: Metadata collected contains an error that will be reported at runtime: ${expandedMessage(error)}.\\n  ${JSON.stringify(error)}`);\n    }\n  }\n\n  Object.getOwnPropertyNames(metadata).forEach(name => {\n    const entry = metadata[name];\n    try {\n      if (isClassMetadata(entry)) {\n        validateClass(entry);\n      }\n    } catch (e) {\n      const node = nodeMap.get(entry);\n      if (shouldReportNode(node)) {\n        if (node) {\n          const {line, character} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n          throw new Error(\n              `${sourceFile.fileName}:${line + 1}:${character + 1}: Error encountered in metadata generated for exported symbol '${name}': \\n ${e.message}`);\n        }\n        throw new Error(\n            `Error encountered in metadata generated for exported symbol ${name}: \\n ${e.message}`);\n      }\n    }\n  });\n}\n\n// Collect parameter names from a function.\nfunction namesOf(parameters: ts.NodeArray<ts.ParameterDeclaration>): string[] {\n  const result: string[] = [];\n\n  function addNamesOf(name: ts.Identifier | ts.BindingPattern) {\n    if (name.kind == ts.SyntaxKind.Identifier) {\n      const identifier = <ts.Identifier>name;\n      result.push(identifier.text);\n    } else {\n      const bindingPattern = <ts.BindingPattern>name;\n      for (const element of bindingPattern.elements) {\n        const name = (element as any).name;\n        if (name) {\n          addNamesOf(name);\n        }\n      }\n    }\n  }\n\n  for (const parameter of parameters) {\n    addNamesOf(parameter.name);\n  }\n\n  return result;\n}\n\nfunction expandedMessage(error: any): string {\n  switch (error.message) {\n    case 'Reference to non-exported class':\n      if (error.context && error.context.className) {\n        return `Reference to a non-exported class ${error.context.className}. Consider exporting the class`;\n      }\n      break;\n    case 'Variable not initialized':\n      return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n    case 'Destructuring not supported':\n      return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n    case 'Could not resolve type':\n      if (error.context && error.context.typeName) {\n        return `Could not resolve type ${error.context.typeName}`;\n      }\n      break;\n    case 'Function call not supported':\n      let prefix =\n          error.context && error.context.name ? `Calling function '${error.context.name}', f` : 'F';\n      return prefix +\n          'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n    case 'Reference to a local symbol':\n      if (error.context && error.context.name) {\n        return `Reference to a local (non-exported) symbol '${error.context.name}'. Consider exporting the symbol`;\n      }\n  }\n  return error.message;\n}\n"]}