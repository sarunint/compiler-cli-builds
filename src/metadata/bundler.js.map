{"version":3,"file":"bundler.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/metadata/bundler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {MetadataCache} from '../transformers/metadata_cache';\n\nimport {MetadataCollector} from './collector';\nimport {ClassMetadata, ConstructorMetadata, FunctionMetadata, METADATA_VERSION, MemberMetadata, MetadataEntry, MetadataError, MetadataImportedSymbolReferenceExpression, MetadataMap, MetadataObject, MetadataSymbolicExpression, MetadataSymbolicReferenceExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isInterfaceMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicExpression, isMethodMetadata} from './schema';\n\n\n\n// The character set used to produce private names.\nconst PRIVATE_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n\ninterface Symbol {\n  module: string;\n  name: string;\n\n  // Produced by indirectly by exportAll() for symbols re-export another symbol.\n  exports?: Symbol;\n\n  // Produced by indirectly by exportAll() for symbols are re-exported by another symbol.\n  reexportedAs?: Symbol;\n\n  // Produced by canonicalizeSymbols() for all symbols. A symbol is private if it is not\n  // exported by the index.\n  isPrivate?: boolean;\n\n  // Produced by canonicalizeSymbols() for all symbols. This is the one symbol that\n  // respresents all other symbols and is the only symbol that, among all the re-exported\n  // aliases, whose fields can be trusted to contain the correct information.\n  // For private symbols this is the declaration symbol. For public symbols this is the\n  // symbol that is exported.\n  canonicalSymbol?: Symbol;\n\n  // Produced by canonicalizeSymbols() for all symbols. This the symbol that originally\n  // declared the value and should be used to fetch the value.\n  declaration?: Symbol;\n\n  // A symbol is referenced if it is exported from index or referenced by the value of\n  // a referenced symbol's value.\n  referenced?: boolean;\n\n  // A symbol is marked as a re-export the symbol was rexported from a module that is\n  // not part of the flat module bundle.\n  reexport?: boolean;\n\n  // Only valid for referenced canonical symbols. Produces by convertSymbols().\n  value?: MetadataEntry;\n\n  // Only valid for referenced private symbols. It is the name to use to import the symbol from\n  // the bundle index. Produce by assignPrivateNames();\n  privateName?: string;\n}\n\nexport interface BundleEntries { [name: string]: MetadataEntry; }\n\nexport interface BundlePrivateEntry {\n  privateName: string;\n  name: string;\n  module: string;\n}\n\nexport interface BundledModule {\n  metadata: ModuleMetadata;\n  privates: BundlePrivateEntry[];\n}\n\nexport interface MetadataBundlerHost {\n  getMetadataFor(moduleName: string, containingFile: string): ModuleMetadata|undefined;\n}\n\ntype StaticsMetadata = {\n  [name: string]: MetadataValue | FunctionMetadata;\n};\n\nexport class MetadataBundler {\n  private symbolMap = new Map<string, Symbol>();\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n  private exports = new Map<string, Symbol[]>();\n  private rootModule: string;\n  private privateSymbolPrefix: string;\n  // TODO(issue/24571): remove '!'.\n  private exported !: Set<Symbol>;\n\n  constructor(\n      private root: string, private importAs: string|undefined, private host: MetadataBundlerHost,\n      privateSymbolPrefix?: string) {\n    this.rootModule = `./${path.basename(root)}`;\n    this.privateSymbolPrefix = (privateSymbolPrefix || '').replace(/\\W/g, '_');\n  }\n\n  getMetadataBundle(): BundledModule {\n    // Export the root module. This also collects the transitive closure of all values referenced by\n    // the exports.\n    const exportedSymbols = this.exportAll(this.rootModule);\n    this.canonicalizeSymbols(exportedSymbols);\n    // TODO: exports? e.g. a module re-exports a symbol from another bundle\n    const metadata = this.getEntries(exportedSymbols);\n    const privates = Array.from(this.symbolMap.values())\n                         .filter(s => s.referenced && s.isPrivate)\n                         .map(s => ({\n                                privateName: s.privateName !,\n                                name: s.declaration !.name,\n                                module: s.declaration !.module\n                              }));\n    const origins = Array.from(this.symbolMap.values())\n                        .filter(s => s.referenced && !s.reexport)\n                        .reduce<{[name: string]: string}>((p, s) => {\n                          p[s.isPrivate ? s.privateName ! : s.name] = s.declaration !.module;\n                          return p;\n                        }, {});\n    const exports = this.getReExports(exportedSymbols);\n    return {\n      metadata: {\n        __symbolic: 'module',\n        version: METADATA_VERSION,\n        exports: exports.length ? exports : undefined, metadata, origins,\n        importAs: this.importAs !\n      },\n      privates\n    };\n  }\n\n  static resolveModule(importName: string, from: string): string {\n    return resolveModule(importName, from);\n  }\n\n  private getMetadata(moduleName: string): ModuleMetadata|undefined {\n    let result = this.metadataCache.get(moduleName);\n    if (!result) {\n      if (moduleName.startsWith('.')) {\n        const fullModuleName = resolveModule(moduleName, this.root);\n        result = this.host.getMetadataFor(fullModuleName, this.root);\n      }\n      this.metadataCache.set(moduleName, result);\n    }\n    return result;\n  }\n\n  private exportAll(moduleName: string): Symbol[] {\n    const module = this.getMetadata(moduleName);\n    let result = this.exports.get(moduleName);\n\n    if (result) {\n      return result;\n    }\n\n    result = [];\n\n    const exportSymbol = (exportedSymbol: Symbol, exportAs: string) => {\n      const symbol = this.symbolOf(moduleName, exportAs);\n      result !.push(symbol);\n      exportedSymbol.reexportedAs = symbol;\n      symbol.exports = exportedSymbol;\n    };\n\n    // Export all the symbols defined in this module.\n    if (module && module.metadata) {\n      for (let key in module.metadata) {\n        const data = module.metadata[key];\n        if (isMetadataImportedSymbolReferenceExpression(data)) {\n          // This is a re-export of an imported symbol. Record this as a re-export.\n          const exportFrom = resolveModule(data.module, moduleName);\n          this.exportAll(exportFrom);\n          const symbol = this.symbolOf(exportFrom, data.name);\n          exportSymbol(symbol, key);\n        } else {\n          // Record that this symbol is exported by this module.\n          result.push(this.symbolOf(moduleName, key));\n        }\n      }\n    }\n\n    // Export all the re-exports from this module\n    if (module && module.exports) {\n      for (const exportDeclaration of module.exports) {\n        const exportFrom = resolveModule(exportDeclaration.from, moduleName);\n        // Record all the exports from the module even if we don't use it directly.\n        const exportedSymbols = this.exportAll(exportFrom);\n        if (exportDeclaration.export) {\n          // Re-export all the named exports from a module.\n          for (const exportItem of exportDeclaration.export) {\n            const name = typeof exportItem == 'string' ? exportItem : exportItem.name;\n            const exportAs = typeof exportItem == 'string' ? exportItem : exportItem.as;\n            const symbol = this.symbolOf(exportFrom, name);\n            if (exportedSymbols && exportedSymbols.length == 1 && exportedSymbols[0].reexport &&\n                exportedSymbols[0].name == '*') {\n              // This is a named export from a module we have no metadata about. Record the named\n              // export as a re-export.\n              symbol.reexport = true;\n            }\n            exportSymbol(this.symbolOf(exportFrom, name), exportAs);\n          }\n        } else {\n          // Re-export all the symbols from the module\n          const exportedSymbols = this.exportAll(exportFrom);\n          for (const exportedSymbol of exportedSymbols) {\n            const name = exportedSymbol.name;\n            exportSymbol(exportedSymbol, name);\n          }\n        }\n      }\n    }\n\n    if (!module) {\n      // If no metadata is found for this import then it is considered external to the\n      // library and should be recorded as a re-export in the final metadata if it is\n      // eventually re-exported.\n      const symbol = this.symbolOf(moduleName, '*');\n      symbol.reexport = true;\n      result.push(symbol);\n    }\n    this.exports.set(moduleName, result);\n\n    return result;\n  }\n\n  /**\n   * Fill in the canonicalSymbol which is the symbol that should be imported by factories.\n   * The canonical symbol is the one exported by the index file for the bundle or definition\n   * symbol for private symbols that are not exported by bundle index.\n   */\n  private canonicalizeSymbols(exportedSymbols: Symbol[]) {\n    const symbols = Array.from(this.symbolMap.values());\n    this.exported = new Set(exportedSymbols);\n    symbols.forEach(this.canonicalizeSymbol, this);\n  }\n\n  private canonicalizeSymbol(symbol: Symbol) {\n    const rootExport = getRootExport(symbol);\n    const declaration = getSymbolDeclaration(symbol);\n    const isPrivate = !this.exported.has(rootExport);\n    const canonicalSymbol = isPrivate ? declaration : rootExport;\n    symbol.isPrivate = isPrivate;\n    symbol.declaration = declaration;\n    symbol.canonicalSymbol = canonicalSymbol;\n    symbol.reexport = declaration.reexport;\n  }\n\n  private getEntries(exportedSymbols: Symbol[]): BundleEntries {\n    const result: BundleEntries = {};\n\n    const exportedNames = new Set(exportedSymbols.map(s => s.name));\n    let privateName = 0;\n\n    function newPrivateName(prefix: string): string {\n      while (true) {\n        let digits: string[] = [];\n        let index = privateName++;\n        let base = PRIVATE_NAME_CHARS;\n        while (!digits.length || index > 0) {\n          digits.unshift(base[index % base.length]);\n          index = Math.floor(index / base.length);\n        }\n        const result = `\\u0275${prefix}${digits.join('')}`;\n        if (!exportedNames.has(result)) return result;\n      }\n    }\n\n    exportedSymbols.forEach(symbol => this.convertSymbol(symbol));\n\n    const symbolsMap = new Map<string, string[]>();\n    Array.from(this.symbolMap.values()).forEach(symbol => {\n      if (symbol.referenced && !symbol.reexport) {\n        let name = symbol.name;\n        const identifier = `${symbol.declaration!.module}:${symbol.declaration !.name}`;\n        if (symbol.isPrivate && !symbol.privateName) {\n          name = newPrivateName(this.privateSymbolPrefix);\n          symbol.privateName = name;\n        }\n        if (symbolsMap.has(identifier)) {\n          const names = symbolsMap.get(identifier);\n          names !.push(name);\n        } else {\n          symbolsMap.set(identifier, [name]);\n        }\n        result[name] = symbol.value !;\n      }\n    });\n\n    // check for duplicated entries\n    symbolsMap.forEach((names: string[], identifier: string) => {\n      if (names.length > 1) {\n        const [module, declaredName] = identifier.split(':');\n        // prefer the export that uses the declared name (if any)\n        let reference = names.indexOf(declaredName);\n        if (reference === -1) {\n          reference = 0;\n        }\n\n        // keep one entry and replace the others by references\n        names.forEach((name: string, i: number) => {\n          if (i !== reference) {\n            result[name] = {__symbolic: 'reference', name: names[reference]};\n          }\n        });\n      }\n    });\n\n    return result;\n  }\n\n  private getReExports(exportedSymbols: Symbol[]): ModuleExportMetadata[] {\n    type ExportClause = {name: string, as: string}[];\n    const modules = new Map<string, ExportClause>();\n    const exportAlls = new Set<string>();\n    for (const symbol of exportedSymbols) {\n      if (symbol.reexport) {\n        // symbol.declaration is guaranteed to be defined during the phase this method is called.\n        const declaration = symbol.declaration !;\n        const module = declaration.module;\n        if (declaration !.name == '*') {\n          // Reexport all the symbols.\n          exportAlls.add(declaration.module);\n        } else {\n          // Re-export the symbol as the exported name.\n          let entry = modules.get(module);\n          if (!entry) {\n            entry = [];\n            modules.set(module, entry);\n          }\n          const as = symbol.name;\n          const name = declaration.name;\n          entry.push({name, as});\n        }\n      }\n    }\n    return [\n      ...Array.from(exportAlls.values()).map(from => ({from})),\n      ...Array.from(modules.entries()).map(([from, exports]) => ({export: exports, from}))\n    ];\n  }\n\n  private convertSymbol(symbol: Symbol) {\n    // canonicalSymbol is ensured to be defined before this is called.\n    const canonicalSymbol = symbol.canonicalSymbol !;\n\n    if (!canonicalSymbol.referenced) {\n      canonicalSymbol.referenced = true;\n      // declaration is ensured to be definded before this method is called.\n      const declaration = canonicalSymbol.declaration !;\n      const module = this.getMetadata(declaration.module);\n      if (module) {\n        const value = module.metadata[declaration.name];\n        if (value && !declaration.name.startsWith('___')) {\n          canonicalSymbol.value = this.convertEntry(declaration.module, value);\n        }\n      }\n    }\n  }\n\n  private convertEntry(moduleName: string, value: MetadataEntry): MetadataEntry {\n    if (isClassMetadata(value)) {\n      return this.convertClass(moduleName, value);\n    }\n    if (isFunctionMetadata(value)) {\n      return this.convertFunction(moduleName, value);\n    }\n    if (isInterfaceMetadata(value)) {\n      return value;\n    }\n    return this.convertValue(moduleName, value);\n  }\n\n  private convertClass(moduleName: string, value: ClassMetadata): ClassMetadata {\n    return {\n      __symbolic: 'class',\n      arity: value.arity,\n      extends: this.convertExpression(moduleName, value.extends) !,\n      decorators:\n          value.decorators && value.decorators.map(d => this.convertExpression(moduleName, d) !),\n      members: this.convertMembers(moduleName, value.members !),\n      statics: value.statics && this.convertStatics(moduleName, value.statics)\n    };\n  }\n\n  private convertMembers(moduleName: string, members: MetadataMap): MetadataMap {\n    const result: MetadataMap = {};\n    for (const name in members) {\n      const value = members[name];\n      result[name] = value.map(v => this.convertMember(moduleName, v));\n    }\n    return result;\n  }\n\n  private convertMember(moduleName: string, member: MemberMetadata) {\n    const result: MemberMetadata = {__symbolic: member.__symbolic};\n    result.decorators =\n        member.decorators && member.decorators.map(d => this.convertExpression(moduleName, d) !);\n    if (isMethodMetadata(member)) {\n      (result as MethodMetadata).parameterDecorators = member.parameterDecorators &&\n          member.parameterDecorators.map(\n              d => d && d.map(p => this.convertExpression(moduleName, p) !));\n      if (isConstructorMetadata(member)) {\n        if (member.parameters) {\n          (result as ConstructorMetadata).parameters =\n              member.parameters.map(p => this.convertExpression(moduleName, p));\n        }\n      }\n    }\n    return result;\n  }\n\n  private convertStatics(moduleName: string, statics: StaticsMetadata): StaticsMetadata {\n    let result: StaticsMetadata = {};\n    for (const key in statics) {\n      const value = statics[key];\n      result[key] = isFunctionMetadata(value) ? this.convertFunction(moduleName, value) : value;\n    }\n    return result;\n  }\n\n  private convertFunction(moduleName: string, value: FunctionMetadata): FunctionMetadata {\n    return {\n      __symbolic: 'function',\n      parameters: value.parameters,\n      defaults: value.defaults && value.defaults.map(v => this.convertValue(moduleName, v)),\n      value: this.convertValue(moduleName, value.value)\n    };\n  }\n\n  private convertValue(moduleName: string, value: MetadataValue): MetadataValue {\n    if (isPrimitive(value)) {\n      return value;\n    }\n    if (isMetadataError(value)) {\n      return this.convertError(moduleName, value);\n    }\n    if (isMetadataSymbolicExpression(value)) {\n      return this.convertExpression(moduleName, value) !;\n    }\n    if (Array.isArray(value)) {\n      return value.map(v => this.convertValue(moduleName, v));\n    }\n\n    // Otherwise it is a metadata object.\n    const object = value as MetadataObject;\n    const result: MetadataObject = {};\n    for (const key in object) {\n      result[key] = this.convertValue(moduleName, object[key]);\n    }\n    return result;\n  }\n\n  private convertExpression(\n      moduleName: string, value: MetadataSymbolicExpression|MetadataError|null|\n      undefined): MetadataSymbolicExpression|MetadataError|undefined|null {\n    if (value) {\n      switch (value.__symbolic) {\n        case 'error':\n          return this.convertError(moduleName, value as MetadataError);\n        case 'reference':\n          return this.convertReference(moduleName, value as MetadataSymbolicReferenceExpression);\n        default:\n          return this.convertExpressionNode(moduleName, value);\n      }\n    }\n    return value;\n  }\n\n  private convertError(module: string, value: MetadataError): MetadataError {\n    return {\n      __symbolic: 'error',\n      message: value.message,\n      line: value.line,\n      character: value.character,\n      context: value.context, module\n    };\n  }\n\n  private convertReference(moduleName: string, value: MetadataSymbolicReferenceExpression):\n      MetadataSymbolicReferenceExpression|MetadataError|undefined {\n    const createReference = (symbol: Symbol): MetadataSymbolicReferenceExpression => {\n      const declaration = symbol.declaration !;\n      if (declaration.module.startsWith('.')) {\n        // Reference to a symbol defined in the module. Ensure it is converted then return a\n        // references to the final symbol.\n        this.convertSymbol(symbol);\n        return {\n          __symbolic: 'reference',\n          get name() {\n            // Resolved lazily because private names are assigned late.\n            const canonicalSymbol = symbol.canonicalSymbol !;\n            if (canonicalSymbol.isPrivate == null) {\n              throw Error('Invalid state: isPrivate was not initialized');\n            }\n            return canonicalSymbol.isPrivate ? canonicalSymbol.privateName ! : canonicalSymbol.name;\n          }\n        };\n      } else {\n        // The symbol was a re-exported symbol from another module. Return a reference to the\n        // original imported symbol.\n        return {__symbolic: 'reference', name: declaration.name, module: declaration.module};\n      }\n    };\n\n    if (isMetadataGlobalReferenceExpression(value)) {\n      const metadata = this.getMetadata(moduleName);\n      if (metadata && metadata.metadata && metadata.metadata[value.name]) {\n        // Reference to a symbol defined in the module\n        return createReference(this.canonicalSymbolOf(moduleName, value.name));\n      }\n\n      // If a reference has arguments, the arguments need to be converted.\n      if (value.arguments) {\n        return {\n          __symbolic: 'reference',\n          name: value.name,\n          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n        };\n      }\n\n      // Global references without arguments (such as to Math or JSON) are unmodified.\n      return value;\n    }\n\n    if (isMetadataImportedSymbolReferenceExpression(value)) {\n      // References to imported symbols are separated into two, references to bundled modules and\n      // references to modules external to the bundle. If the module reference is relative it is\n      // assumed to be in the bundle. If it is Global it is assumed to be outside the bundle.\n      // References to symbols outside the bundle are left unmodified. References to symbol inside\n      // the bundle need to be converted to a bundle import reference reachable from the bundle\n      // index.\n\n      if (value.module.startsWith('.')) {\n        // Reference is to a symbol defined inside the module. Convert the reference to a reference\n        // to the canonical symbol.\n        const referencedModule = resolveModule(value.module, moduleName);\n        const referencedName = value.name;\n        return createReference(this.canonicalSymbolOf(referencedModule, referencedName));\n      }\n\n      // Value is a reference to a symbol defined outside the module.\n      if (value.arguments) {\n        // If a reference has arguments the arguments need to be converted.\n        return {\n          __symbolic: 'reference',\n          name: value.name,\n          module: value.module,\n          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n        };\n      }\n      return value;\n    }\n\n    if (isMetadataModuleReferenceExpression(value)) {\n      // Cannot support references to bundled modules as the internal modules of a bundle are erased\n      // by the bundler.\n      if (value.module.startsWith('.')) {\n        return {\n          __symbolic: 'error',\n          message: 'Unsupported bundled module reference',\n          context: {module: value.module}\n        };\n      }\n\n      // References to unbundled modules are unmodified.\n      return value;\n    }\n  }\n\n  private convertExpressionNode(moduleName: string, value: MetadataSymbolicExpression):\n      MetadataSymbolicExpression {\n    const result: MetadataSymbolicExpression = { __symbolic: value.__symbolic } as any;\n    for (const key in value) {\n      (result as any)[key] = this.convertValue(moduleName, (value as any)[key]);\n    }\n    return result;\n  }\n\n  private symbolOf(module: string, name: string): Symbol {\n    const symbolKey = `${module}:${name}`;\n    let symbol = this.symbolMap.get(symbolKey);\n    if (!symbol) {\n      symbol = {module, name};\n      this.symbolMap.set(symbolKey, symbol);\n    }\n    return symbol;\n  }\n\n  private canonicalSymbolOf(module: string, name: string): Symbol {\n    // Ensure the module has been seen.\n    this.exportAll(module);\n    const symbol = this.symbolOf(module, name);\n    if (!symbol.canonicalSymbol) {\n      this.canonicalizeSymbol(symbol);\n    }\n    return symbol;\n  }\n}\n\nexport class CompilerHostAdapter implements MetadataBundlerHost {\n  private collector = new MetadataCollector();\n\n  constructor(\n      private host: ts.CompilerHost, private cache: MetadataCache|null,\n      private options: ts.CompilerOptions) {}\n\n  getMetadataFor(fileName: string, containingFile: string): ModuleMetadata|undefined {\n    const {resolvedModule} =\n        ts.resolveModuleName(fileName, containingFile, this.options, this.host);\n\n    let sourceFile: ts.SourceFile|undefined;\n    if (resolvedModule) {\n      let {resolvedFileName} = resolvedModule;\n      if (resolvedModule.extension !== '.ts') {\n        resolvedFileName = resolvedFileName.replace(/(\\.d\\.ts|\\.js)$/, '.ts');\n      }\n      sourceFile = this.host.getSourceFile(resolvedFileName, ts.ScriptTarget.Latest);\n    } else {\n      // If typescript is unable to resolve the file, fallback on old behavior\n      if (!this.host.fileExists(fileName + '.ts')) return undefined;\n      sourceFile = this.host.getSourceFile(fileName + '.ts', ts.ScriptTarget.Latest);\n    }\n\n    // If there is a metadata cache, use it to get the metadata for this source file. Otherwise,\n    // fall back on the locally created MetadataCollector.\n    if (!sourceFile) {\n      return undefined;\n    } else if (this.cache) {\n      return this.cache.getMetadata(sourceFile);\n    } else {\n      return this.collector.getMetadata(sourceFile);\n    }\n  }\n}\n\nfunction resolveModule(importName: string, from: string): string {\n  if (importName.startsWith('.') && from) {\n    let normalPath = path.normalize(path.join(path.dirname(from), importName));\n    if (!normalPath.startsWith('.') && from.startsWith('.')) {\n      // path.normalize() preserves leading '../' but not './'. This adds it back.\n      normalPath = `.${path.sep}${normalPath}`;\n    }\n    // Replace windows path delimiters with forward-slashes. Otherwise the paths are not\n    // TypeScript compatible when building the bundle.\n    return normalPath.replace(/\\\\/g, '/');\n  }\n  return importName;\n}\n\nfunction isPrimitive(o: any): o is boolean|string|number {\n  return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n\nfunction getRootExport(symbol: Symbol): Symbol {\n  return symbol.reexportedAs ? getRootExport(symbol.reexportedAs) : symbol;\n}\n\nfunction getSymbolDeclaration(symbol: Symbol): Symbol {\n  return symbol.exports ? getSymbolDeclaration(symbol.exports) : symbol;\n}\n"]}