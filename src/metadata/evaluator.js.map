{"version":3,"file":"evaluator.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/metadata/evaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {CollectorOptions} from './collector';\nimport {ClassMetadata, FunctionMetadata, InterfaceMetadata, MetadataEntry, MetadataError, MetadataImportedSymbolReferenceExpression, MetadataSourceLocationInfo, MetadataSymbolicCallExpression, MetadataValue, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSpreadExpression} from './schema';\nimport {Symbols} from './symbols';\n\n\n\n// In TypeScript 2.1 the spread element kind was renamed.\nconst spreadElementSyntaxKind: ts.SyntaxKind =\n    (ts.SyntaxKind as any).SpreadElement || (ts.SyntaxKind as any).SpreadElementExpression;\n\nfunction isMethodCallOf(callExpression: ts.CallExpression, memberName: string): boolean {\n  const expression = callExpression.expression;\n  if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n    const propertyAccessExpression = <ts.PropertyAccessExpression>expression;\n    const name = propertyAccessExpression.name;\n    if (name.kind == ts.SyntaxKind.Identifier) {\n      return name.text === memberName;\n    }\n  }\n  return false;\n}\n\nfunction isCallOf(callExpression: ts.CallExpression, ident: string): boolean {\n  const expression = callExpression.expression;\n  if (expression.kind === ts.SyntaxKind.Identifier) {\n    const identifier = <ts.Identifier>expression;\n    return identifier.text === ident;\n  }\n  return false;\n}\n\n/* @internal */\nexport function recordMapEntry<T extends MetadataEntry>(\n    entry: T, node: ts.Node,\n    nodeMap: Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>,\n    sourceFile?: ts.SourceFile) {\n  if (!nodeMap.has(entry)) {\n    nodeMap.set(entry, node);\n    if (node && (isMetadataImportedSymbolReferenceExpression(entry) ||\n                 isMetadataImportDefaultReference(entry)) &&\n        entry.line == null) {\n      const info = sourceInfo(node, sourceFile);\n      if (info.line != null) entry.line = info.line;\n      if (info.character != null) entry.character = info.character;\n    }\n  }\n  return entry;\n}\n\n/**\n * ts.forEachChild stops iterating children when the callback return a truthy value.\n * This method inverts this to implement an `every` style iterator. It will return\n * true if every call to `cb` returns `true`.\n */\nfunction everyNodeChild(node: ts.Node, cb: (node: ts.Node) => boolean) {\n  return !ts.forEachChild(node, node => !cb(node));\n}\n\nexport function isPrimitive(value: any): boolean {\n  return Object(value) !== value;\n}\n\nfunction isDefined(obj: any): boolean {\n  return obj !== undefined;\n}\n\n// import {propertyName as name} from 'place'\n// import {name} from 'place'\nexport interface ImportSpecifierMetadata {\n  name: string;\n  propertyName?: string;\n}\nexport interface ImportMetadata {\n  defaultName?: string;                      // import d from 'place'\n  namespace?: string;                        // import * as d from 'place'\n  namedImports?: ImportSpecifierMetadata[];  // import {a} from 'place'\n  from: string;                              // from 'place'\n}\n\n\nfunction getSourceFileOfNode(node: ts.Node | undefined): ts.SourceFile {\n  while (node && node.kind != ts.SyntaxKind.SourceFile) {\n    node = node.parent;\n  }\n  return <ts.SourceFile>node;\n}\n\n/* @internal */\nexport function sourceInfo(\n    node: ts.Node | undefined, sourceFile: ts.SourceFile | undefined): MetadataSourceLocationInfo {\n  if (node) {\n    sourceFile = sourceFile || getSourceFileOfNode(node);\n    if (sourceFile) {\n      return ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));\n    }\n  }\n  return {};\n}\n\n/* @internal */\nexport function errorSymbol(\n    message: string, node?: ts.Node, context?: {[name: string]: string},\n    sourceFile?: ts.SourceFile): MetadataError {\n  const result: MetadataError = {__symbolic: 'error', message, ...sourceInfo(node, sourceFile)};\n  if (context) {\n    result.context = context;\n  }\n  return result;\n}\n\n/**\n * Produce a symbolic representation of an expression folding values into their final value when\n * possible.\n */\nexport class Evaluator {\n  constructor(\n      private symbols: Symbols, private nodeMap: Map<MetadataEntry, ts.Node>,\n      private options: CollectorOptions = {},\n      private recordExport?: (name: string, value: MetadataValue) => void) {}\n\n  nameOf(node: ts.Node|undefined): string|MetadataError {\n    if (node && node.kind == ts.SyntaxKind.Identifier) {\n      return (<ts.Identifier>node).text;\n    }\n    const result = node && this.evaluateNode(node);\n    if (isMetadataError(result) || typeof result === 'string') {\n      return result;\n    } else {\n      return errorSymbol(\n          'Name expected', node, {received: (node && node.getText()) || '<missing>'});\n    }\n  }\n\n  /**\n   * Returns true if the expression represented by `node` can be folded into a literal expression.\n   *\n   * For example, a literal is always foldable. This means that literal expressions such as `1.2`\n   * `\"Some value\"` `true` `false` are foldable.\n   *\n   * - An object literal is foldable if all the properties in the literal are foldable.\n   * - An array literal is foldable if all the elements are foldable.\n   * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.\n   * - A property access is foldable if the object is foldable.\n   * - A array index is foldable if index expression is foldable and the array is foldable.\n   * - Binary operator expressions are foldable if the left and right expressions are foldable and\n   *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.\n   * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol\n   *   table.\n   */\n  public isFoldable(node: ts.Node): boolean {\n    return this.isFoldableWorker(node, new Map<ts.Node, boolean>());\n  }\n\n  private isFoldableWorker(node: ts.Node|undefined, folding: Map<ts.Node, boolean>): boolean {\n    if (node) {\n      switch (node.kind) {\n        case ts.SyntaxKind.ObjectLiteralExpression:\n          return everyNodeChild(node, child => {\n            if (child.kind === ts.SyntaxKind.PropertyAssignment) {\n              const propertyAssignment = <ts.PropertyAssignment>child;\n              return this.isFoldableWorker(propertyAssignment.initializer, folding);\n            }\n            return false;\n          });\n        case ts.SyntaxKind.ArrayLiteralExpression:\n          return everyNodeChild(node, child => this.isFoldableWorker(child, folding));\n        case ts.SyntaxKind.CallExpression:\n          const callExpression = <ts.CallExpression>node;\n          // We can fold a <array>.concat(<v>).\n          if (isMethodCallOf(callExpression, 'concat') &&\n              arrayOrEmpty(callExpression.arguments).length === 1) {\n            const arrayNode = (<ts.PropertyAccessExpression>callExpression.expression).expression;\n            if (this.isFoldableWorker(arrayNode, folding) &&\n                this.isFoldableWorker(callExpression.arguments[0], folding)) {\n              // It needs to be an array.\n              const arrayValue = this.evaluateNode(arrayNode);\n              if (arrayValue && Array.isArray(arrayValue)) {\n                return true;\n              }\n            }\n          }\n\n          // We can fold a call to CONST_EXPR\n          if (isCallOf(callExpression, 'CONST_EXPR') &&\n              arrayOrEmpty(callExpression.arguments).length === 1)\n            return this.isFoldableWorker(callExpression.arguments[0], folding);\n          return false;\n        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.NumericLiteral:\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.TrueKeyword:\n        case ts.SyntaxKind.FalseKeyword:\n        case ts.SyntaxKind.TemplateHead:\n        case ts.SyntaxKind.TemplateMiddle:\n        case ts.SyntaxKind.TemplateTail:\n          return true;\n        case ts.SyntaxKind.ParenthesizedExpression:\n          const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n          return this.isFoldableWorker(parenthesizedExpression.expression, folding);\n        case ts.SyntaxKind.BinaryExpression:\n          const binaryExpression = <ts.BinaryExpression>node;\n          switch (binaryExpression.operatorToken.kind) {\n            case ts.SyntaxKind.PlusToken:\n            case ts.SyntaxKind.MinusToken:\n            case ts.SyntaxKind.AsteriskToken:\n            case ts.SyntaxKind.SlashToken:\n            case ts.SyntaxKind.PercentToken:\n            case ts.SyntaxKind.AmpersandAmpersandToken:\n            case ts.SyntaxKind.BarBarToken:\n              return this.isFoldableWorker(binaryExpression.left, folding) &&\n                  this.isFoldableWorker(binaryExpression.right, folding);\n            default:\n              return false;\n          }\n        case ts.SyntaxKind.PropertyAccessExpression:\n          const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n          return this.isFoldableWorker(propertyAccessExpression.expression, folding);\n        case ts.SyntaxKind.ElementAccessExpression:\n          const elementAccessExpression = <ts.ElementAccessExpression>node;\n          return this.isFoldableWorker(elementAccessExpression.expression, folding) &&\n              this.isFoldableWorker(elementAccessExpression.argumentExpression, folding);\n        case ts.SyntaxKind.Identifier:\n          let identifier = <ts.Identifier>node;\n          let reference = this.symbols.resolve(identifier.text);\n          if (reference !== undefined && isPrimitive(reference)) {\n            return true;\n          }\n          break;\n        case ts.SyntaxKind.TemplateExpression:\n          const templateExpression = <ts.TemplateExpression>node;\n          return templateExpression.templateSpans.every(\n              span => this.isFoldableWorker(span.expression, folding));\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Produce a JSON serialiable object representing `node`. The foldable values in the expression\n   * tree are folded. For example, a node representing `1 + 2` is folded into `3`.\n   */\n  public evaluateNode(node: ts.Node, preferReference?: boolean): MetadataValue {\n    const t = this;\n    let error: MetadataError|undefined;\n\n    function recordEntry(entry: MetadataValue, node: ts.Node): MetadataValue {\n      if (t.options.substituteExpression) {\n        const newEntry = t.options.substituteExpression(entry, node);\n        if (t.recordExport && newEntry != entry && isMetadataGlobalReferenceExpression(newEntry)) {\n          t.recordExport(newEntry.name, entry);\n        }\n        entry = newEntry;\n      }\n      return recordMapEntry(entry, node, t.nodeMap);\n    }\n\n    function isFoldableError(value: any): value is MetadataError {\n      return !t.options.verboseInvalidExpression && isMetadataError(value);\n    }\n\n    const resolveName = (name: string, preferReference?: boolean): MetadataValue => {\n      const reference = this.symbols.resolve(name, preferReference);\n      if (reference === undefined) {\n        // Encode as a global reference. StaticReflector will check the reference.\n        return recordEntry({__symbolic: 'reference', name}, node);\n      }\n      if (reference && isMetadataSymbolicReferenceExpression(reference)) {\n        return recordEntry({...reference}, node);\n      }\n      return reference;\n    };\n\n    switch (node.kind) {\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        let obj: {[name: string]: any} = {};\n        let quoted: string[] = [];\n        ts.forEachChild(node, child => {\n          switch (child.kind) {\n            case ts.SyntaxKind.ShorthandPropertyAssignment:\n            case ts.SyntaxKind.PropertyAssignment:\n              const assignment = <ts.PropertyAssignment|ts.ShorthandPropertyAssignment>child;\n              if (assignment.name.kind == ts.SyntaxKind.StringLiteral) {\n                const name = (assignment.name as ts.StringLiteral).text;\n                quoted.push(name);\n              }\n              const propertyName = this.nameOf(assignment.name);\n              if (isFoldableError(propertyName)) {\n                error = propertyName;\n                return true;\n              }\n              const propertyValue = isPropertyAssignment(assignment) ?\n                  this.evaluateNode(assignment.initializer, /* preferReference */ true) :\n                  resolveName(propertyName, /* preferReference */ true);\n              if (isFoldableError(propertyValue)) {\n                error = propertyValue;\n                return true;  // Stop the forEachChild.\n              } else {\n                obj[<string>propertyName] = isPropertyAssignment(assignment) ?\n                    recordEntry(propertyValue, assignment.initializer) :\n                    propertyValue;\n              }\n          }\n        });\n        if (error) return error;\n        if (this.options.quotedNames && quoted.length) {\n          obj['$quoted$'] = quoted;\n        }\n        return recordEntry(obj, node);\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        let arr: MetadataValue[] = [];\n        ts.forEachChild(node, child => {\n          const value = this.evaluateNode(child, /* preferReference */ true);\n\n          // Check for error\n          if (isFoldableError(value)) {\n            error = value;\n            return true;  // Stop the forEachChild.\n          }\n\n          // Handle spread expressions\n          if (isMetadataSymbolicSpreadExpression(value)) {\n            if (Array.isArray(value.expression)) {\n              for (const spreadValue of value.expression) {\n                arr.push(spreadValue);\n              }\n              return;\n            }\n          }\n\n          arr.push(value);\n        });\n        if (error) return error;\n        return recordEntry(arr, node);\n      case spreadElementSyntaxKind:\n        let spreadExpression = this.evaluateNode((node as any).expression);\n        return recordEntry({__symbolic: 'spread', expression: spreadExpression}, node);\n      case ts.SyntaxKind.CallExpression:\n        const callExpression = <ts.CallExpression>node;\n        if (isCallOf(callExpression, 'forwardRef') &&\n            arrayOrEmpty(callExpression.arguments).length === 1) {\n          const firstArgument = callExpression.arguments[0];\n          if (firstArgument.kind == ts.SyntaxKind.ArrowFunction) {\n            const arrowFunction = <ts.ArrowFunction>firstArgument;\n            return recordEntry(this.evaluateNode(arrowFunction.body), node);\n          }\n        }\n        const args = arrayOrEmpty(callExpression.arguments).map(arg => this.evaluateNode(arg));\n        if (this.isFoldable(callExpression)) {\n          if (isMethodCallOf(callExpression, 'concat')) {\n            const arrayValue = <MetadataValue[]>this.evaluateNode(\n                (<ts.PropertyAccessExpression>callExpression.expression).expression);\n            if (isFoldableError(arrayValue)) return arrayValue;\n            return arrayValue.concat(args[0]);\n          }\n        }\n        // Always fold a CONST_EXPR even if the argument is not foldable.\n        if (isCallOf(callExpression, 'CONST_EXPR') &&\n            arrayOrEmpty(callExpression.arguments).length === 1) {\n          return recordEntry(args[0], node);\n        }\n        const expression = this.evaluateNode(callExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        let result: MetadataSymbolicCallExpression = {__symbolic: 'call', expression: expression};\n        if (args && args.length) {\n          result.arguments = args;\n        }\n        return recordEntry(result, node);\n      case ts.SyntaxKind.NewExpression:\n        const newExpression = <ts.NewExpression>node;\n        const newArgs = arrayOrEmpty(newExpression.arguments).map(arg => this.evaluateNode(arg));\n        const newTarget = this.evaluateNode(newExpression.expression);\n        if (isMetadataError(newTarget)) {\n          return recordEntry(newTarget, node);\n        }\n        const call: MetadataSymbolicCallExpression = {__symbolic: 'new', expression: newTarget};\n        if (newArgs.length) {\n          call.arguments = newArgs;\n        }\n        return recordEntry(call, node);\n      case ts.SyntaxKind.PropertyAccessExpression: {\n        const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n        const expression = this.evaluateNode(propertyAccessExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        const member = this.nameOf(propertyAccessExpression.name);\n        if (isFoldableError(member)) {\n          return recordEntry(member, node);\n        }\n        if (expression && this.isFoldable(propertyAccessExpression.expression))\n          return (<any>expression)[<string>member];\n        if (isMetadataModuleReferenceExpression(expression)) {\n          // A select into a module reference and be converted into a reference to the symbol\n          // in the module\n          return recordEntry(\n              {__symbolic: 'reference', module: expression.module, name: member}, node);\n        }\n        return recordEntry({__symbolic: 'select', expression, member}, node);\n      }\n      case ts.SyntaxKind.ElementAccessExpression: {\n        const elementAccessExpression = <ts.ElementAccessExpression>node;\n        const expression = this.evaluateNode(elementAccessExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        if (!elementAccessExpression.argumentExpression) {\n          return recordEntry(errorSymbol('Expression form not supported', node), node);\n        }\n        const index = this.evaluateNode(elementAccessExpression.argumentExpression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        if (this.isFoldable(elementAccessExpression.expression) &&\n            this.isFoldable(elementAccessExpression.argumentExpression))\n          return (<any>expression)[<string|number>index];\n        return recordEntry({__symbolic: 'index', expression, index}, node);\n      }\n      case ts.SyntaxKind.Identifier:\n        const identifier = <ts.Identifier>node;\n        const name = identifier.text;\n        return resolveName(name, preferReference);\n      case ts.SyntaxKind.TypeReference:\n        const typeReferenceNode = <ts.TypeReferenceNode>node;\n        const typeNameNode = typeReferenceNode.typeName;\n        const getReference: (typeNameNode: ts.Identifier | ts.QualifiedName) => MetadataValue =\n            node => {\n              if (typeNameNode.kind === ts.SyntaxKind.QualifiedName) {\n                const qualifiedName = <ts.QualifiedName>node;\n                const left = this.evaluateNode(qualifiedName.left);\n                if (isMetadataModuleReferenceExpression(left)) {\n                  return recordEntry(\n                      <MetadataImportedSymbolReferenceExpression>{\n                        __symbolic: 'reference',\n                        module: left.module,\n                        name: qualifiedName.right.text\n                      },\n                      node);\n                }\n                // Record a type reference to a declared type as a select.\n                return {__symbolic: 'select', expression: left, member: qualifiedName.right.text};\n              } else {\n                const identifier = <ts.Identifier>typeNameNode;\n                const symbol = this.symbols.resolve(identifier.text);\n                if (isFoldableError(symbol) || isMetadataSymbolicReferenceExpression(symbol)) {\n                  return recordEntry(symbol, node);\n                }\n                return recordEntry(\n                    errorSymbol('Could not resolve type', node, {typeName: identifier.text}), node);\n              }\n            };\n        const typeReference = getReference(typeNameNode);\n        if (isFoldableError(typeReference)) {\n          return recordEntry(typeReference, node);\n        }\n        if (!isMetadataModuleReferenceExpression(typeReference) &&\n            typeReferenceNode.typeArguments && typeReferenceNode.typeArguments.length) {\n          const args = typeReferenceNode.typeArguments.map(element => this.evaluateNode(element));\n          // TODO: Remove typecast when upgraded to 2.0 as it will be correctly inferred.\n          // Some versions of 1.9 do not infer this correctly.\n          (<MetadataImportedSymbolReferenceExpression>typeReference).arguments = args;\n        }\n        return recordEntry(typeReference, node);\n      case ts.SyntaxKind.UnionType:\n        const unionType = <ts.UnionTypeNode>node;\n\n        // Remove null and undefined from the list of unions.\n        const references = unionType.types\n                               .filter(\n                                   n => n.kind != ts.SyntaxKind.NullKeyword &&\n                                       n.kind != ts.SyntaxKind.UndefinedKeyword)\n                               .map(n => this.evaluateNode(n));\n\n        // The remmaining reference must be the same. If two have type arguments consider them\n        // different even if the type arguments are the same.\n        let candidate: any = null;\n        for (let i = 0; i < references.length; i++) {\n          const reference = references[i];\n          if (isMetadataSymbolicReferenceExpression(reference)) {\n            if (candidate) {\n              if ((reference as any).name == candidate.name &&\n                  (reference as any).module == candidate.module && !(reference as any).arguments) {\n                candidate = reference;\n              }\n            } else {\n              candidate = reference;\n            }\n          } else {\n            return reference;\n          }\n        }\n        if (candidate) return candidate;\n        break;\n      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.TemplateHead:\n      case ts.SyntaxKind.TemplateTail:\n      case ts.SyntaxKind.TemplateMiddle:\n        return (<ts.LiteralLikeNode>node).text;\n      case ts.SyntaxKind.NumericLiteral:\n        return parseFloat((<ts.LiteralExpression>node).text);\n      case ts.SyntaxKind.AnyKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'any'}, node);\n      case ts.SyntaxKind.StringKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'string'}, node);\n      case ts.SyntaxKind.NumberKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'number'}, node);\n      case ts.SyntaxKind.BooleanKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'boolean'}, node);\n      case ts.SyntaxKind.ArrayType:\n        const arrayTypeNode = <ts.ArrayTypeNode>node;\n        return recordEntry(\n            {\n              __symbolic: 'reference',\n              name: 'Array',\n              arguments: [this.evaluateNode(arrayTypeNode.elementType)]\n            },\n            node);\n      case ts.SyntaxKind.NullKeyword:\n        return null;\n      case ts.SyntaxKind.TrueKeyword:\n        return true;\n      case ts.SyntaxKind.FalseKeyword:\n        return false;\n      case ts.SyntaxKind.ParenthesizedExpression:\n        const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n        return this.evaluateNode(parenthesizedExpression.expression);\n      case ts.SyntaxKind.TypeAssertionExpression:\n        const typeAssertion = <ts.TypeAssertion>node;\n        return this.evaluateNode(typeAssertion.expression);\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        const prefixUnaryExpression = <ts.PrefixUnaryExpression>node;\n        const operand = this.evaluateNode(prefixUnaryExpression.operand);\n        if (isDefined(operand) && isPrimitive(operand)) {\n          switch (prefixUnaryExpression.operator) {\n            case ts.SyntaxKind.PlusToken:\n              return +(operand as any);\n            case ts.SyntaxKind.MinusToken:\n              return -(operand as any);\n            case ts.SyntaxKind.TildeToken:\n              return ~(operand as any);\n            case ts.SyntaxKind.ExclamationToken:\n              return !operand;\n          }\n        }\n        let operatorText: string;\n        switch (prefixUnaryExpression.operator) {\n          case ts.SyntaxKind.PlusToken:\n            operatorText = '+';\n            break;\n          case ts.SyntaxKind.MinusToken:\n            operatorText = '-';\n            break;\n          case ts.SyntaxKind.TildeToken:\n            operatorText = '~';\n            break;\n          case ts.SyntaxKind.ExclamationToken:\n            operatorText = '!';\n            break;\n          default:\n            return undefined;\n        }\n        return recordEntry({__symbolic: 'pre', operator: operatorText, operand: operand}, node);\n      case ts.SyntaxKind.BinaryExpression:\n        const binaryExpression = <ts.BinaryExpression>node;\n        const left = this.evaluateNode(binaryExpression.left);\n        const right = this.evaluateNode(binaryExpression.right);\n        if (isDefined(left) && isDefined(right)) {\n          if (isPrimitive(left) && isPrimitive(right))\n            switch (binaryExpression.operatorToken.kind) {\n              case ts.SyntaxKind.BarBarToken:\n                return <any>left || <any>right;\n              case ts.SyntaxKind.AmpersandAmpersandToken:\n                return <any>left && <any>right;\n              case ts.SyntaxKind.AmpersandToken:\n                return <any>left & <any>right;\n              case ts.SyntaxKind.BarToken:\n                return <any>left | <any>right;\n              case ts.SyntaxKind.CaretToken:\n                return <any>left ^ <any>right;\n              case ts.SyntaxKind.EqualsEqualsToken:\n                return <any>left == <any>right;\n              case ts.SyntaxKind.ExclamationEqualsToken:\n                return <any>left != <any>right;\n              case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                return <any>left === <any>right;\n              case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                return <any>left !== <any>right;\n              case ts.SyntaxKind.LessThanToken:\n                return <any>left < <any>right;\n              case ts.SyntaxKind.GreaterThanToken:\n                return <any>left > <any>right;\n              case ts.SyntaxKind.LessThanEqualsToken:\n                return <any>left <= <any>right;\n              case ts.SyntaxKind.GreaterThanEqualsToken:\n                return <any>left >= <any>right;\n              case ts.SyntaxKind.LessThanLessThanToken:\n                return (<any>left) << (<any>right);\n              case ts.SyntaxKind.GreaterThanGreaterThanToken:\n                return <any>left >> <any>right;\n              case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n                return <any>left >>> <any>right;\n              case ts.SyntaxKind.PlusToken:\n                return <any>left + <any>right;\n              case ts.SyntaxKind.MinusToken:\n                return <any>left - <any>right;\n              case ts.SyntaxKind.AsteriskToken:\n                return <any>left * <any>right;\n              case ts.SyntaxKind.SlashToken:\n                return <any>left / <any>right;\n              case ts.SyntaxKind.PercentToken:\n                return <any>left % <any>right;\n            }\n          return recordEntry(\n              {\n                __symbolic: 'binop',\n                operator: binaryExpression.operatorToken.getText(),\n                left: left,\n                right: right\n              },\n              node);\n        }\n        break;\n      case ts.SyntaxKind.ConditionalExpression:\n        const conditionalExpression = <ts.ConditionalExpression>node;\n        const condition = this.evaluateNode(conditionalExpression.condition);\n        const thenExpression = this.evaluateNode(conditionalExpression.whenTrue);\n        const elseExpression = this.evaluateNode(conditionalExpression.whenFalse);\n        if (isPrimitive(condition)) {\n          return condition ? thenExpression : elseExpression;\n        }\n        return recordEntry({__symbolic: 'if', condition, thenExpression, elseExpression}, node);\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.ArrowFunction:\n        return recordEntry(errorSymbol('Lambda not supported', node), node);\n      case ts.SyntaxKind.TaggedTemplateExpression:\n        return recordEntry(\n            errorSymbol('Tagged template expressions are not supported in metadata', node), node);\n      case ts.SyntaxKind.TemplateExpression:\n        const templateExpression = <ts.TemplateExpression>node;\n        if (this.isFoldable(node)) {\n          return templateExpression.templateSpans.reduce(\n              (previous, current) => previous + <string>this.evaluateNode(current.expression) +\n                  <string>this.evaluateNode(current.literal),\n              this.evaluateNode(templateExpression.head));\n        } else {\n          return templateExpression.templateSpans.reduce((previous, current) => {\n            const expr = this.evaluateNode(current.expression);\n            const literal = this.evaluateNode(current.literal);\n            if (isFoldableError(expr)) return expr;\n            if (isFoldableError(literal)) return literal;\n            if (typeof previous === 'string' && typeof expr === 'string' &&\n                typeof literal === 'string') {\n              return previous + expr + literal;\n            }\n            let result = expr;\n            if (previous !== '') {\n              result = {__symbolic: 'binop', operator: '+', left: previous, right: expr};\n            }\n            if (literal != '') {\n              result = {__symbolic: 'binop', operator: '+', left: result, right: literal};\n            }\n            return result;\n          }, this.evaluateNode(templateExpression.head));\n        }\n      case ts.SyntaxKind.AsExpression:\n        const asExpression = <ts.AsExpression>node;\n        return this.evaluateNode(asExpression.expression);\n      case ts.SyntaxKind.ClassExpression:\n        return {__symbolic: 'class'};\n    }\n    return recordEntry(errorSymbol('Expression form not supported', node), node);\n  }\n}\n\nfunction isPropertyAssignment(node: ts.Node): node is ts.PropertyAssignment {\n  return node.kind == ts.SyntaxKind.PropertyAssignment;\n}\n\nconst empty = ts.createNodeArray<any>();\n\nfunction arrayOrEmpty<T extends ts.Node>(v: ts.NodeArray<T>| undefined): ts.NodeArray<T> {\n  return v || empty;\n}"]}