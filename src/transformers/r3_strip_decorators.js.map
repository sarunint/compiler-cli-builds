{"version":3,"file":"r3_strip_decorators.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/r3_strip_decorators.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticReflector, StaticSymbol} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {MetadataValue, isClassMetadata, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicCallExpression} from '../metadata';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport type Transformer = (sourceFile: ts.SourceFile) => ts.SourceFile;\nexport type TransformerFactory = (context: ts.TransformationContext) => Transformer;\n\nexport function getDecoratorStripTransformerFactory(\n    coreDecorators: Set<StaticSymbol>, reflector: StaticReflector,\n    checker: ts.TypeChecker): TransformerFactory {\n  return function(context: ts.TransformationContext) {\n    return function(sourceFile: ts.SourceFile): ts.SourceFile {\n      const stripDecoratorsFromClassDeclaration =\n          (node: ts.ClassDeclaration): ts.ClassDeclaration => {\n            if (node.decorators === undefined) {\n              return node;\n            }\n            const decorators = node.decorators.filter(decorator => {\n              const callExpr = decorator.expression;\n              if (ts.isCallExpression(callExpr)) {\n                const id = callExpr.expression;\n                if (ts.isIdentifier(id)) {\n                  const symbol = resolveToStaticSymbol(id, sourceFile.fileName, reflector, checker);\n                  return symbol && coreDecorators.has(symbol);\n                }\n              }\n              return true;\n            });\n            if (decorators.length !== node.decorators.length) {\n              return ts.updateClassDeclaration(\n                  node, decorators, node.modifiers, node.name, node.typeParameters,\n                  node.heritageClauses || [], node.members, );\n            }\n            return node;\n          };\n\n      const stripDecoratorPropertyAssignment = (node: ts.ClassDeclaration): ts.ClassDeclaration => {\n        return ts.visitEachChild(node, member => {\n          if (!ts.isPropertyDeclaration(member) || !isDecoratorAssignment(member) ||\n              !member.initializer || !ts.isArrayLiteralExpression(member.initializer)) {\n            return member;\n          }\n\n          const newInitializer = ts.visitEachChild(member.initializer, decorator => {\n            if (!ts.isObjectLiteralExpression(decorator)) {\n              return decorator;\n            }\n            const type = lookupProperty(decorator, 'type');\n            if (!type || !ts.isIdentifier(type)) {\n              return decorator;\n            }\n            const symbol = resolveToStaticSymbol(type, sourceFile.fileName, reflector, checker);\n            if (!symbol || !coreDecorators.has(symbol)) {\n              return decorator;\n            }\n            return undefined;\n          }, context);\n\n          if (newInitializer === member.initializer) {\n            return member;\n          } else if (newInitializer.elements.length === 0) {\n            return undefined;\n          } else {\n            return ts.updateProperty(\n                member, member.decorators, member.modifiers, member.name, member.questionToken,\n                member.type, newInitializer);\n          }\n        }, context);\n      };\n\n      return ts.visitEachChild(sourceFile, stmt => {\n        if (ts.isClassDeclaration(stmt)) {\n          let decl = stmt;\n          if (stmt.decorators) {\n            decl = stripDecoratorsFromClassDeclaration(stmt);\n          }\n          return stripDecoratorPropertyAssignment(decl);\n        }\n        return stmt;\n      }, context);\n    };\n  };\n}\n\nfunction isDecoratorAssignment(member: ts.ClassElement): boolean {\n  if (!ts.isPropertyDeclaration(member)) {\n    return false;\n  }\n  if (!member.modifiers ||\n      !member.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword)) {\n    return false;\n  }\n  if (!ts.isIdentifier(member.name) || member.name.text !== 'decorators') {\n    return false;\n  }\n  if (!member.initializer || !ts.isArrayLiteralExpression(member.initializer)) {\n    return false;\n  }\n  return true;\n}\n\nfunction lookupProperty(expr: ts.ObjectLiteralExpression, prop: string): ts.Expression|undefined {\n  const decl = expr.properties.find(\n      elem => !!elem.name && ts.isIdentifier(elem.name) && elem.name.text === prop);\n  if (decl === undefined || !ts.isPropertyAssignment(decl)) {\n    return undefined;\n  }\n  return decl.initializer;\n}\n\nfunction resolveToStaticSymbol(\n    id: ts.Identifier, containingFile: string, reflector: StaticReflector,\n    checker: ts.TypeChecker): StaticSymbol|null {\n  const res = checker.getSymbolAtLocation(id);\n  if (!res || !res.declarations || res.declarations.length === 0) {\n    return null;\n  }\n  const decl = res.declarations[0];\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n  const moduleSpecifier = decl.parent !.parent !.parent !.moduleSpecifier;\n  if (!ts.isStringLiteral(moduleSpecifier)) {\n    return null;\n  }\n  return reflector.tryFindDeclaration(moduleSpecifier.text, id.text, containingFile);\n}\n\nexport class StripDecoratorsMetadataTransformer implements MetadataTransformer {\n  constructor(private coreDecorators: Set<StaticSymbol>, private reflector: StaticReflector) {}\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n        value.decorators = value.decorators.filter(d => {\n          if (isMetadataSymbolicCallExpression(d) &&\n              isMetadataImportedSymbolReferenceExpression(d.expression)) {\n            const declaration = this.reflector.tryFindDeclaration(\n                d.expression.module, d.expression.name, sourceFile.fileName);\n            if (declaration && this.coreDecorators.has(declaration)) {\n              return false;\n            }\n          }\n          return true;\n        });\n      }\n      return value;\n    };\n  }\n}\n"]}