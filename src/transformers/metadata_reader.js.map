{"version":3,"file":"metadata_reader.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/metadata_reader.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {METADATA_VERSION, ModuleMetadata} from '../metadata';\n\nimport {DTS} from './util';\n\nexport interface MetadataReaderHost {\n  getSourceFileMetadata(filePath: string): ModuleMetadata|undefined;\n  cacheMetadata?(fileName: string): boolean;\n  fileExists(filePath: string): boolean;\n  readFile(filePath: string): string;\n}\n\nexport interface MetadataReaderCache {\n  /**\n   * @internal\n   */\n  data: Map<string, ModuleMetadata[]|undefined>;\n}\n\nexport function createMetadataReaderCache(): MetadataReaderCache {\n  const data = new Map<string, ModuleMetadata[]|undefined>();\n  return {data};\n}\n\nexport function readMetadata(\n    filePath: string, host: MetadataReaderHost, cache?: MetadataReaderCache): ModuleMetadata[]|\n    undefined {\n  let metadatas = cache && cache.data.get(filePath);\n  if (metadatas) {\n    return metadatas;\n  }\n  if (host.fileExists(filePath)) {\n    // If the file doesn't exists then we cannot return metadata for the file.\n    // This will occur if the user referenced a declared module for which no file\n    // exists for the module (i.e. jQuery or angularjs).\n    if (DTS.test(filePath)) {\n      metadatas = readMetadataFile(host, filePath);\n      if (!metadatas) {\n        // If there is a .d.ts file but no metadata file we need to produce a\n        // metadata from the .d.ts file as metadata files capture reexports\n        // (starting with v3).\n        metadatas = [upgradeMetadataWithDtsData(\n            host, {'__symbolic': 'module', 'version': 1, 'metadata': {}}, filePath)];\n      }\n    } else {\n      const metadata = host.getSourceFileMetadata(filePath);\n      metadatas = metadata ? [metadata] : [];\n    }\n  }\n  if (cache && (!host.cacheMetadata || host.cacheMetadata(filePath))) {\n    cache.data.set(filePath, metadatas);\n  }\n  return metadatas;\n}\n\n\nfunction readMetadataFile(host: MetadataReaderHost, dtsFilePath: string): ModuleMetadata[]|\n    undefined {\n  const metadataPath = dtsFilePath.replace(DTS, '.metadata.json');\n  if (!host.fileExists(metadataPath)) {\n    return undefined;\n  }\n  try {\n    const metadataOrMetadatas = JSON.parse(host.readFile(metadataPath));\n    const metadatas: ModuleMetadata[] = metadataOrMetadatas ?\n        (Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas]) :\n        [];\n    if (metadatas.length) {\n      let maxMetadata = metadatas.reduce((p, c) => p.version > c.version ? p : c);\n      if (maxMetadata.version < METADATA_VERSION) {\n        metadatas.push(upgradeMetadataWithDtsData(host, maxMetadata, dtsFilePath));\n      }\n    }\n    return metadatas;\n  } catch (e) {\n    console.error(`Failed to read JSON file ${metadataPath}`);\n    throw e;\n  }\n}\n\nfunction upgradeMetadataWithDtsData(\n    host: MetadataReaderHost, oldMetadata: ModuleMetadata, dtsFilePath: string): ModuleMetadata {\n  // patch v1 to v3 by adding exports and the `extends` clause.\n  // patch v3 to v4 by adding `interface` symbols for TypeAlias\n  let newMetadata: ModuleMetadata = {\n    '__symbolic': 'module',\n    'version': METADATA_VERSION,\n    'metadata': {...oldMetadata.metadata},\n  };\n  if (oldMetadata.exports) {\n    newMetadata.exports = oldMetadata.exports;\n  }\n  if (oldMetadata.importAs) {\n    newMetadata.importAs = oldMetadata.importAs;\n  }\n  if (oldMetadata.origins) {\n    newMetadata.origins = oldMetadata.origins;\n  }\n  const dtsMetadata = host.getSourceFileMetadata(dtsFilePath);\n  if (dtsMetadata) {\n    for (let prop in dtsMetadata.metadata) {\n      if (!newMetadata.metadata[prop]) {\n        newMetadata.metadata[prop] = dtsMetadata.metadata[prop];\n      }\n    }\n    if (dtsMetadata['importAs']) newMetadata['importAs'] = dtsMetadata['importAs'];\n\n    // Only copy exports from exports from metadata prior to version 3.\n    // Starting with version 3 the collector began collecting exports and\n    // this should be redundant. Also, with bundler will rewrite the exports\n    // which will hoist the exports from modules referenced indirectly causing\n    // the imports to be different than the .d.ts files and using the .d.ts file\n    // exports would cause the StaticSymbolResolver to redirect symbols to the\n    // incorrect location.\n    if ((!oldMetadata.version || oldMetadata.version < 3) && dtsMetadata.exports) {\n      newMetadata.exports = dtsMetadata.exports;\n    }\n  }\n  return newMetadata;\n}\n"]}