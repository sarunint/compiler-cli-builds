{"version":3,"file":"lower_expressions.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/lower_expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createLoweredSymbol, isLoweredSymbol} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {CollectorOptions, MetadataCollector, MetadataValue, ModuleMetadata, isMetadataGlobalReferenceExpression} from '../metadata/index';\nimport {MetadataCache, MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport interface LoweringRequest {\n  kind: ts.SyntaxKind;\n  location: number;\n  end: number;\n  name: string;\n}\n\nexport type RequestLocationMap = Map<number, LoweringRequest>;\n\nconst enum DeclarationOrder { BeforeStmt, AfterStmt }\n\ninterface Declaration {\n  name: string;\n  node: ts.Node;\n  order: DeclarationOrder;\n}\n\ninterface DeclarationInsert {\n  declarations: Declaration[];\n  relativeTo: ts.Node;\n}\n\nfunction toMap<T, K>(items: T[], select: (item: T) => K): Map<K, T> {\n  return new Map(items.map<[K, T]>(i => [select(i), i]));\n}\n\n// We will never lower expressions in a nested lexical scope so avoid entering them.\n// This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n// when using visitEachChild.\nfunction isLexicalScope(node: ts.Node): boolean {\n  switch (node.kind) {\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.TypeLiteral:\n    case ts.SyntaxKind.ArrayType:\n      return true;\n  }\n  return false;\n}\n\nfunction transformSourceFile(\n    sourceFile: ts.SourceFile, requests: RequestLocationMap,\n    context: ts.TransformationContext): ts.SourceFile {\n  const inserts: DeclarationInsert[] = [];\n\n  // Calculate the range of interesting locations. The transform will only visit nodes in this\n  // range to improve the performance on large files.\n  const locations = Array.from(requests.keys());\n  const min = Math.min(...locations);\n  const max = Math.max(...locations);\n\n  // Visit nodes matching the request and synthetic nodes added by tsickle\n  function shouldVisit(pos: number, end: number): boolean {\n    return (pos <= max && end >= min) || pos == -1;\n  }\n\n  function visitSourceFile(sourceFile: ts.SourceFile): ts.SourceFile {\n    function topLevelStatement(node: ts.Statement): ts.Statement {\n      const declarations: Declaration[] = [];\n\n      function visitNode(node: ts.Node): ts.Node {\n        // Get the original node before tsickle\n        const {pos, end, kind, parent: originalParent} = ts.getOriginalNode(node);\n        const nodeRequest = requests.get(pos);\n        if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n          // This node is requested to be rewritten as a reference to the exported name.\n          if (originalParent && originalParent.kind === ts.SyntaxKind.VariableDeclaration) {\n            // As the value represents the whole initializer of a variable declaration,\n            // just refer to that variable. This e.g. helps to preserve closure comments\n            // at the right place.\n            const varParent = originalParent as ts.VariableDeclaration;\n            if (varParent.name.kind === ts.SyntaxKind.Identifier) {\n              const varName = varParent.name.text;\n              const exportName = nodeRequest.name;\n              declarations.push({\n                name: exportName,\n                node: ts.createIdentifier(varName),\n                order: DeclarationOrder.AfterStmt\n              });\n              return node;\n            }\n          }\n          // Record that the node needs to be moved to an exported variable with the given name\n          const exportName = nodeRequest.name;\n          declarations.push({name: exportName, node, order: DeclarationOrder.BeforeStmt});\n          return ts.createIdentifier(exportName);\n        }\n        let result = node;\n        if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n          result = ts.visitEachChild(node, visitNode, context);\n        }\n        return result;\n      }\n\n      // Get the original node before tsickle\n      const {pos, end} = ts.getOriginalNode(node);\n      let resultStmt: ts.Statement;\n      if (shouldVisit(pos, end)) {\n        resultStmt = ts.visitEachChild(node, visitNode, context);\n      } else {\n        resultStmt = node;\n      }\n\n      if (declarations.length) {\n        inserts.push({relativeTo: resultStmt, declarations});\n      }\n      return resultStmt;\n    }\n\n    let newStatements = sourceFile.statements.map(topLevelStatement);\n\n    if (inserts.length) {\n      // Insert the declarations relative to the rewritten statement that references them.\n      const insertMap = toMap(inserts, i => i.relativeTo);\n      const tmpStatements: ts.Statement[] = [];\n      newStatements.forEach(statement => {\n        const insert = insertMap.get(statement);\n        if (insert) {\n          const before = insert.declarations.filter(d => d.order === DeclarationOrder.BeforeStmt);\n          if (before.length) {\n            tmpStatements.push(createVariableStatementForDeclarations(before));\n          }\n          tmpStatements.push(statement);\n          const after = insert.declarations.filter(d => d.order === DeclarationOrder.AfterStmt);\n          if (after.length) {\n            tmpStatements.push(createVariableStatementForDeclarations(after));\n          }\n        } else {\n          tmpStatements.push(statement);\n        }\n      });\n\n      // Insert an exports clause to export the declarations\n      tmpStatements.push(ts.createExportDeclaration(\n          /* decorators */ undefined,\n          /* modifiers */ undefined,\n          ts.createNamedExports(\n              inserts\n                  .reduce(\n                      (accumulator, insert) => [...accumulator, ...insert.declarations],\n                      [] as Declaration[])\n                  .map(\n                      declaration => ts.createExportSpecifier(\n                          /* propertyName */ undefined, declaration.name)))));\n\n      newStatements = tmpStatements;\n    }\n    // Note: We cannot use ts.updateSourcefile here as\n    // it does not work well with decorators.\n    // See https://github.com/Microsoft/TypeScript/issues/17384\n    const newSf = ts.getMutableClone(sourceFile);\n    if (!(sourceFile.flags & ts.NodeFlags.Synthesized)) {\n      newSf.flags &= ~ts.NodeFlags.Synthesized;\n    }\n    newSf.statements = ts.setTextRange(ts.createNodeArray(newStatements), sourceFile.statements);\n    return newSf;\n  }\n\n  return visitSourceFile(sourceFile);\n}\n\nfunction createVariableStatementForDeclarations(declarations: Declaration[]): ts.VariableStatement {\n  const varDecls = declarations.map(\n      i => ts.createVariableDeclaration(i.name, /* type */ undefined, i.node as ts.Expression));\n  return ts.createVariableStatement(\n      /* modifiers */ undefined, ts.createVariableDeclarationList(varDecls, ts.NodeFlags.Const));\n}\n\nexport function getExpressionLoweringTransformFactory(\n    requestsMap: RequestsMap, program: ts.Program): (context: ts.TransformationContext) =>\n    (sourceFile: ts.SourceFile) => ts.SourceFile {\n  // Return the factory\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile): ts.SourceFile => {\n    // We need to use the original SourceFile for reading metadata, and not the transformed one.\n    const originalFile = program.getSourceFile(sourceFile.fileName);\n    if (originalFile) {\n      const requests = requestsMap.getRequests(originalFile);\n      if (requests && requests.size) {\n        return transformSourceFile(sourceFile, requests, context);\n      }\n    }\n    return sourceFile;\n  };\n}\n\nexport interface RequestsMap { getRequests(sourceFile: ts.SourceFile): RequestLocationMap; }\n\ninterface MetadataAndLoweringRequests {\n  metadata: ModuleMetadata|undefined;\n  requests: RequestLocationMap;\n}\n\nfunction isEligibleForLowering(node: ts.Node | undefined): boolean {\n  if (node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n      case ts.SyntaxKind.Decorator:\n        // Lower expressions that are local to the module scope or\n        // in a decorator.\n        return true;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n        // Don't lower expressions in a declaration.\n        return false;\n      case ts.SyntaxKind.VariableDeclaration:\n        // Avoid lowering expressions already in an exported variable declaration\n        return (ts.getCombinedModifierFlags(node as ts.VariableDeclaration) &\n                ts.ModifierFlags.Export) == 0;\n    }\n    return isEligibleForLowering(node.parent);\n  }\n  return true;\n}\n\nfunction isPrimitive(value: any): boolean {\n  return Object(value) !== value;\n}\n\nfunction isRewritten(value: any): boolean {\n  return isMetadataGlobalReferenceExpression(value) && isLoweredSymbol(value.name);\n}\n\nfunction isLiteralFieldNamed(node: ts.Node, names: Set<string>): boolean {\n  if (node.parent && node.parent.kind == ts.SyntaxKind.PropertyAssignment) {\n    const property = node.parent as ts.PropertyAssignment;\n    if (property.parent && property.parent.kind == ts.SyntaxKind.ObjectLiteralExpression &&\n        property.name && property.name.kind == ts.SyntaxKind.Identifier) {\n      const propertyName = property.name as ts.Identifier;\n      return names.has(propertyName.text);\n    }\n  }\n  return false;\n}\n\nexport class LowerMetadataTransform implements RequestsMap, MetadataTransformer {\n  // TODO(issue/24571): remove '!'.\n  private cache !: MetadataCache;\n  private requests = new Map<string, RequestLocationMap>();\n  private lowerableFieldNames: Set<string>;\n\n  constructor(lowerableFieldNames: string[]) {\n    this.lowerableFieldNames = new Set<string>(lowerableFieldNames);\n  }\n\n  // RequestMap\n  getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n    let result = this.requests.get(sourceFile.fileName);\n    if (!result) {\n      // Force the metadata for this source file to be collected which\n      // will recursively call start() populating the request map;\n      this.cache.getMetadata(sourceFile);\n\n      // If we still don't have the requested metadata, the file is not a module\n      // or is a declaration file so return an empty map.\n      result = this.requests.get(sourceFile.fileName) || new Map<number, LoweringRequest>();\n    }\n    return result;\n  }\n\n  // MetadataTransformer\n  connect(cache: MetadataCache): void { this.cache = cache; }\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    let identNumber = 0;\n    const freshIdent = () => createLoweredSymbol(identNumber++);\n    const requests = new Map<number, LoweringRequest>();\n    this.requests.set(sourceFile.fileName, requests);\n\n    const replaceNode = (node: ts.Node) => {\n      const name = freshIdent();\n      requests.set(node.pos, {name, kind: node.kind, location: node.pos, end: node.end});\n      return {__symbolic: 'reference', name};\n    };\n\n    const isExportedSymbol = (() => {\n      let exportTable: Set<string>;\n      return (node: ts.Node) => {\n        if (node.kind == ts.SyntaxKind.Identifier) {\n          const ident = node as ts.Identifier;\n\n          if (!exportTable) {\n            exportTable = createExportTableFor(sourceFile);\n          }\n          return exportTable.has(ident.text);\n        }\n        return false;\n      };\n    })();\n\n    const isExportedPropertyAccess = (node: ts.Node) => {\n      if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n        const pae = node as ts.PropertyAccessExpression;\n        if (isExportedSymbol(pae.expression)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    const hasLowerableParentCache = new Map<ts.Node, boolean>();\n\n    const shouldBeLowered = (node: ts.Node | undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      let lowerable: boolean = false;\n      if ((node.kind === ts.SyntaxKind.ArrowFunction ||\n           node.kind === ts.SyntaxKind.FunctionExpression) &&\n          isEligibleForLowering(node)) {\n        lowerable = true;\n      } else if (\n          isLiteralFieldNamed(node, this.lowerableFieldNames) && isEligibleForLowering(node) &&\n          !isExportedSymbol(node) && !isExportedPropertyAccess(node)) {\n        lowerable = true;\n      }\n      return lowerable;\n    };\n\n    const hasLowerableParent = (node: ts.Node | undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      if (!hasLowerableParentCache.has(node)) {\n        hasLowerableParentCache.set(\n            node, shouldBeLowered(node.parent) || hasLowerableParent(node.parent));\n      }\n      return hasLowerableParentCache.get(node) !;\n    };\n\n    const isLowerable = (node: ts.Node | undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      return shouldBeLowered(node) && !hasLowerableParent(node);\n    };\n\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (!isPrimitive(value) && !isRewritten(value) && isLowerable(node)) {\n        return replaceNode(node);\n      }\n      return value;\n    };\n  }\n}\n\nfunction createExportTableFor(sourceFile: ts.SourceFile): Set<string> {\n  const exportTable = new Set<string>();\n  // Lazily collect all the exports from the source file\n  ts.forEachChild(sourceFile, function scan(node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        if ((ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export) != 0) {\n          const classDeclaration =\n              node as(ts.ClassDeclaration | ts.FunctionDeclaration | ts.InterfaceDeclaration);\n          const name = classDeclaration.name;\n          if (name) exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        const variableStatement = node as ts.VariableStatement;\n        for (const declaration of variableStatement.declarationList.declarations) {\n          scan(declaration);\n        }\n        break;\n      case ts.SyntaxKind.VariableDeclaration:\n        const variableDeclaration = node as ts.VariableDeclaration;\n        if ((ts.getCombinedModifierFlags(variableDeclaration) & ts.ModifierFlags.Export) != 0 &&\n            variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n          const name = variableDeclaration.name as ts.Identifier;\n          exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.ExportDeclaration:\n        const exportDeclaration = node as ts.ExportDeclaration;\n        const {moduleSpecifier, exportClause} = exportDeclaration;\n        if (!moduleSpecifier && exportClause) {\n          exportClause.elements.forEach(spec => { exportTable.add(spec.name.text); });\n        }\n    }\n  });\n  return exportTable;\n}\n"]}