{"version":3,"file":"inline_resources.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/inline_resources.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataObject, MetadataValue, isClassMetadata, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicCallExpression} from '../metadata/index';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nconst PRECONDITIONS_TEXT =\n    'angularCompilerOptions.enableResourceInlining requires all resources to be statically resolvable.';\n\n/** A subset of members from AotCompilerHost */\nexport type ResourcesHost = {\n  resourceNameToFileName(resourceName: string, containingFileName: string): string | null;\n  loadResource(path: string): Promise<string>| string;\n};\n\nexport type StaticResourceLoader = {\n  get(url: string | MetadataValue): string;\n};\n\nfunction getResourceLoader(host: ResourcesHost, containingFileName: string): StaticResourceLoader {\n  return {\n    get(url: string | MetadataValue): string{\n      if (typeof url !== 'string') {\n        throw new Error('templateUrl and stylesUrl must be string literals. ' + PRECONDITIONS_TEXT);\n      } const fileName = host.resourceNameToFileName(url, containingFileName);\n      if (fileName) {\n        const content = host.loadResource(fileName);\n        if (typeof content !== 'string') {\n          throw new Error('Cannot handle async resource. ' + PRECONDITIONS_TEXT);\n        }\n        return content;\n      } throw new Error(`Failed to resolve ${url} from ${containingFileName}. ${PRECONDITIONS_TEXT}`);\n    }\n  };\n}\n\nexport class InlineResourcesMetadataTransformer implements MetadataTransformer {\n  constructor(private host: ResourcesHost) {}\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    const loader = getResourceLoader(this.host, sourceFile.fileName);\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n        value.decorators.forEach(d => {\n          if (isMetadataSymbolicCallExpression(d) &&\n              isMetadataImportedSymbolReferenceExpression(d.expression) &&\n              d.expression.module === '@angular/core' && d.expression.name === 'Component' &&\n              d.arguments) {\n            d.arguments = d.arguments.map(this.updateDecoratorMetadata.bind(this, loader));\n          }\n        });\n      }\n      return value;\n    };\n  }\n\n  updateDecoratorMetadata(loader: StaticResourceLoader, arg: MetadataObject): MetadataObject {\n    if (arg['templateUrl']) {\n      arg['template'] = loader.get(arg['templateUrl']);\n      delete arg.templateUrl;\n    }\n\n    const styles = arg['styles'] || [];\n    const styleUrls = arg['styleUrls'] || [];\n    if (!Array.isArray(styles)) throw new Error('styles should be an array');\n    if (!Array.isArray(styleUrls)) throw new Error('styleUrls should be an array');\n\n    styles.push(...styleUrls.map(styleUrl => loader.get(styleUrl)));\n    if (styles.length > 0) {\n      arg['styles'] = styles;\n      delete arg.styleUrls;\n    }\n\n    return arg;\n  }\n}\n\nexport function getInlineResourcesTransformFactory(\n    program: ts.Program, host: ResourcesHost): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => {\n    const loader = getResourceLoader(host, sourceFile.fileName);\n    const visitor: ts.Visitor = node => {\n      // Components are always classes; skip any other node\n      if (!ts.isClassDeclaration(node)) {\n        return node;\n      }\n\n      // Decorator case - before or without decorator downleveling\n      // @Component()\n      const newDecorators = ts.visitNodes(node.decorators, (node: ts.Decorator) => {\n        if (isComponentDecorator(node, program.getTypeChecker())) {\n          return updateDecorator(node, loader);\n        }\n        return node;\n      });\n\n      // Annotation case - after decorator downleveling\n      // static decorators: {type: Function, args?: any[]}[]\n      const newMembers = ts.visitNodes(\n          node.members,\n          (node: ts.ClassElement) => updateAnnotations(node, loader, program.getTypeChecker()));\n\n      // Create a new AST subtree with our modifications\n      return ts.updateClassDeclaration(\n          node, newDecorators, node.modifiers, node.name, node.typeParameters,\n          node.heritageClauses || [], newMembers);\n    };\n\n    return ts.visitEachChild(sourceFile, visitor, context);\n  };\n}\n\n/**\n * Update a Decorator AST node to inline the resources\n * @param node the @Component decorator\n * @param loader provides access to load resources\n */\nfunction updateDecorator(node: ts.Decorator, loader: StaticResourceLoader): ts.Decorator {\n  if (!ts.isCallExpression(node.expression)) {\n    // User will get an error somewhere else with bare @Component\n    return node;\n  }\n  const expr = node.expression;\n  const newArguments = updateComponentProperties(expr.arguments, loader);\n  return ts.updateDecorator(\n      node, ts.updateCall(expr, expr.expression, expr.typeArguments, newArguments));\n}\n\n/**\n * Update an Annotations AST node to inline the resources\n * @param node the static decorators property\n * @param loader provides access to load resources\n * @param typeChecker provides access to symbol table\n */\nfunction updateAnnotations(\n    node: ts.ClassElement, loader: StaticResourceLoader,\n    typeChecker: ts.TypeChecker): ts.ClassElement {\n  // Looking for a member of this shape:\n  // PropertyDeclaration called decorators, with static modifier\n  // Initializer is ArrayLiteralExpression\n  // One element is the Component type, its initializer is the @angular/core Component symbol\n  // One element is the component args, its initializer is the Component arguments to change\n  // e.g.\n  //   static decorators: {type: Function, args?: any[]}[] =\n  //   [{\n  //     type: Component,\n  //     args: [{\n  //       templateUrl: './my.component.html',\n  //       styleUrls: ['./my.component.css'],\n  //     }],\n  //   }];\n  if (!ts.isPropertyDeclaration(node) ||  // ts.ModifierFlags.Static &&\n      !ts.isIdentifier(node.name) || node.name.text !== 'decorators' || !node.initializer ||\n      !ts.isArrayLiteralExpression(node.initializer)) {\n    return node;\n  }\n\n  const newAnnotations = node.initializer.elements.map(annotation => {\n    // No-op if there's a non-object-literal mixed in the decorators values\n    if (!ts.isObjectLiteralExpression(annotation)) return annotation;\n\n    const decoratorType = annotation.properties.find(p => isIdentifierNamed(p, 'type'));\n\n    // No-op if there's no 'type' property, or if it's not initialized to the Component symbol\n    if (!decoratorType || !ts.isPropertyAssignment(decoratorType) ||\n        !ts.isIdentifier(decoratorType.initializer) ||\n        !isComponentSymbol(decoratorType.initializer, typeChecker)) {\n      return annotation;\n    }\n\n    const newAnnotation = annotation.properties.map(prop => {\n      // No-op if this isn't the 'args' property or if it's not initialized to an array\n      if (!isIdentifierNamed(prop, 'args') || !ts.isPropertyAssignment(prop) ||\n          !ts.isArrayLiteralExpression(prop.initializer))\n        return prop;\n\n      const newDecoratorArgs = ts.updatePropertyAssignment(\n          prop, prop.name,\n          ts.createArrayLiteral(updateComponentProperties(prop.initializer.elements, loader)));\n\n      return newDecoratorArgs;\n    });\n\n    return ts.updateObjectLiteral(annotation, newAnnotation);\n  });\n\n  return ts.updateProperty(\n      node, node.decorators, node.modifiers, node.name, node.questionToken, node.type,\n      ts.updateArrayLiteral(node.initializer, newAnnotations));\n}\n\nfunction isIdentifierNamed(p: ts.ObjectLiteralElementLike, name: string): boolean {\n  return !!p.name && ts.isIdentifier(p.name) && p.name.text === name;\n}\n\n/**\n * Check that the node we are visiting is the actual Component decorator defined in @angular/core.\n */\nfunction isComponentDecorator(node: ts.Decorator, typeChecker: ts.TypeChecker): boolean {\n  if (!ts.isCallExpression(node.expression)) {\n    return false;\n  }\n  const callExpr = node.expression;\n\n  let identifier: ts.Node;\n\n  if (ts.isIdentifier(callExpr.expression)) {\n    identifier = callExpr.expression;\n  } else {\n    return false;\n  }\n  return isComponentSymbol(identifier, typeChecker);\n}\n\nfunction isComponentSymbol(identifier: ts.Node, typeChecker: ts.TypeChecker) {\n  // Only handle identifiers, not expressions\n  if (!ts.isIdentifier(identifier)) return false;\n\n  // NOTE: resolver.getReferencedImportDeclaration would work as well but is internal\n  const symbol = typeChecker.getSymbolAtLocation(identifier);\n\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n    console.error(\n        `Unable to resolve symbol '${identifier.text}' in the program, does it type-check?`);\n    return false;\n  }\n\n  const declaration = symbol.declarations[0];\n\n  if (!declaration || !ts.isImportSpecifier(declaration)) {\n    return false;\n  }\n\n  const name = (declaration.propertyName || declaration.name).text;\n  // We know that parent pointers are set because we created the SourceFile ourselves.\n  // The number of parent references here match the recursion depth at this point.\n  const moduleId =\n      (declaration.parent !.parent !.parent !.moduleSpecifier as ts.StringLiteral).text;\n  return moduleId === '@angular/core' && name === 'Component';\n}\n\n/**\n * For each property in the object literal, if it's templateUrl or styleUrls, replace it\n * with content.\n * @param node the arguments to @Component() or args property of decorators: [{type:Component}]\n * @param loader provides access to the loadResource method of the host\n * @returns updated arguments\n */\nfunction updateComponentProperties(\n    args: ts.NodeArray<ts.Expression>, loader: StaticResourceLoader): ts.NodeArray<ts.Expression> {\n  if (args.length !== 1) {\n    // User should have gotten a type-check error because @Component takes one argument\n    return args;\n  }\n  const componentArg = args[0];\n  if (!ts.isObjectLiteralExpression(componentArg)) {\n    // User should have gotten a type-check error because @Component takes an object literal\n    // argument\n    return args;\n  }\n\n  const newProperties: ts.ObjectLiteralElementLike[] = [];\n  const newStyleExprs: ts.Expression[] = [];\n  componentArg.properties.forEach(prop => {\n    if (!ts.isPropertyAssignment(prop) || ts.isComputedPropertyName(prop.name)) {\n      newProperties.push(prop);\n      return;\n    }\n\n    switch (prop.name.text) {\n      case 'styles':\n        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n          throw new Error('styles takes an array argument');\n        }\n        newStyleExprs.push(...prop.initializer.elements);\n        break;\n\n      case 'styleUrls':\n        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n          throw new Error('styleUrls takes an array argument');\n        }\n        newStyleExprs.push(...prop.initializer.elements.map((expr: ts.Expression) => {\n          if (!ts.isStringLiteral(expr) && !ts.isNoSubstitutionTemplateLiteral(expr)) {\n            throw new Error(\n                'Can only accept string literal arguments to styleUrls. ' + PRECONDITIONS_TEXT);\n          }\n          const styles = loader.get(expr.text);\n          return ts.createLiteral(styles);\n        }));\n        break;\n\n      case 'templateUrl':\n        if (!ts.isStringLiteral(prop.initializer) &&\n            !ts.isNoSubstitutionTemplateLiteral(prop.initializer)) {\n          throw new Error(\n              'Can only accept a string literal argument to templateUrl. ' + PRECONDITIONS_TEXT);\n        }\n        const template = loader.get(prop.initializer.text);\n        newProperties.push(ts.updatePropertyAssignment(\n            prop, ts.createIdentifier('template'), ts.createLiteral(template)));\n        break;\n\n      default:\n        newProperties.push(prop);\n    }\n  });\n\n  // Add the non-inline styles\n  if (newStyleExprs.length > 0) {\n    const newStyles = ts.createPropertyAssignment(\n        ts.createIdentifier('styles'), ts.createArrayLiteral(newStyleExprs));\n    newProperties.push(newStyles);\n  }\n\n  return ts.createNodeArray([ts.updateObjectLiteral(componentArg, newProperties)]);\n}\n"]}