{"version":3,"file":"metadata_cache.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/metadata_cache.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,iCAAiC;AAKjC,iCAA0B;AAS1B;;GAEG;AACH,MAAa,aAAa;IAGxB,YACY,SAA4B,EAAmB,MAAe,EAC9D,YAAmC;QADnC,cAAS,GAAT,SAAS,CAAmB;QAAmB,WAAM,GAAN,MAAM,CAAS;QAC9D,iBAAY,GAAZ,YAAY,CAAuB;QAJvC,kBAAa,GAAG,IAAI,GAAG,EAAoC,CAAC;QAKlE,KAAK,IAAI,WAAW,IAAI,YAAY,EAAE;YACpC,IAAI,WAAW,CAAC,OAAO,EAAE;gBACvB,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aAC3B;SACF;IACH,CAAC;IAED,WAAW,CAAC,UAAyB;QACnC,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YAC/C,OAAO,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;SACpD;QACD,IAAI,UAAU,GAA6B,SAAS,CAAC;QAErD,uEAAuE;QACvE,MAAM,eAAe,GAAG,UAAU,CAAC,iBAAiB,CAAC;QACrD,MAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACnD,IAAI,CAAC,eAAe,IAAI,UAAU,EAAE;YAClC,KAAK,IAAI,SAAS,IAAI,IAAI,CAAC,YAAY,EAAE;gBACvC,MAAM,mBAAmB,GAAG,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBACxD,IAAI,mBAAmB,EAAE;oBACvB,IAAI,UAAU,EAAE;wBACd,MAAM,QAAQ,GAAmB,UAAU,CAAC;wBAC5C,UAAU,GAAG,CAAC,KAAoB,EAAE,IAAa,EAAE,EAAE,CACjD,mBAAmB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;qBACtD;yBAAM;wBACL,UAAU,GAAG,mBAAmB,CAAC;qBAClC;iBACF;aACF;SACF;QAED,MAAM,QAAQ,GAAG,SAAE,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC3F,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QACpD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA1CD,sCA0CC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataProvider} from './compiler_host';\nimport {TS} from './util';\n\nexport type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\n\nexport interface MetadataTransformer {\n  connect?(cache: MetadataCache): void;\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined;\n}\n\n/**\n * Cache, and potentially transform, metadata as it is being collected.\n */\nexport class MetadataCache implements MetadataProvider {\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n\n  constructor(\n      private collector: MetadataCollector, private readonly strict: boolean,\n      private transformers: MetadataTransformer[]) {\n    for (let transformer of transformers) {\n      if (transformer.connect) {\n        transformer.connect(this);\n      }\n    }\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    if (this.metadataCache.has(sourceFile.fileName)) {\n      return this.metadataCache.get(sourceFile.fileName);\n    }\n    let substitute: ValueTransform|undefined = undefined;\n\n    // Only process transformers on modules that are not declaration files.\n    const declarationFile = sourceFile.isDeclarationFile;\n    const moduleFile = ts.isExternalModule(sourceFile);\n    if (!declarationFile && moduleFile) {\n      for (let transform of this.transformers) {\n        const transformSubstitute = transform.start(sourceFile);\n        if (transformSubstitute) {\n          if (substitute) {\n            const previous: ValueTransform = substitute;\n            substitute = (value: MetadataValue, node: ts.Node) =>\n                transformSubstitute(previous(value, node), node);\n          } else {\n            substitute = transformSubstitute;\n          }\n        }\n      }\n    }\n\n    const isTsFile = TS.test(sourceFile.fileName);\n    const result = this.collector.getMetadata(sourceFile, this.strict && isTsFile, substitute);\n    this.metadataCache.set(sourceFile.fileName, result);\n    return result;\n  }\n}"]}